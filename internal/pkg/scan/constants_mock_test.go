// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package scan

//go:generate minimock -i github.com/unhandled-exception/sophiadb/internal/pkg/scan.Constant -o constants_mock_test.go -n ConstantMock -p scan

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/unhandled-exception/sophiadb/internal/pkg/records"
)

// ConstantMock implements Constant
type ConstantMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCompareTo          func(c1 Constant) (c2 CompResult)
	inspectFuncCompareTo   func(c1 Constant)
	afterCompareToCounter  uint64
	beforeCompareToCounter uint64
	CompareToMock          mConstantMockCompareTo

	funcHash          func() (u1 uint64)
	inspectFuncHash   func()
	afterHashCounter  uint64
	beforeHashCounter uint64
	HashMock          mConstantMockHash

	funcString          func() (s1 string)
	inspectFuncString   func()
	afterStringCounter  uint64
	beforeStringCounter uint64
	StringMock          mConstantMockString

	funcType          func() (f1 records.FieldType)
	inspectFuncType   func()
	afterTypeCounter  uint64
	beforeTypeCounter uint64
	TypeMock          mConstantMockType

	funcValue          func() (a1 any)
	inspectFuncValue   func()
	afterValueCounter  uint64
	beforeValueCounter uint64
	ValueMock          mConstantMockValue
}

// NewConstantMock returns a mock for Constant
func NewConstantMock(t minimock.Tester) *ConstantMock {
	m := &ConstantMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CompareToMock = mConstantMockCompareTo{mock: m}
	m.CompareToMock.callArgs = []*ConstantMockCompareToParams{}

	m.HashMock = mConstantMockHash{mock: m}

	m.StringMock = mConstantMockString{mock: m}

	m.TypeMock = mConstantMockType{mock: m}

	m.ValueMock = mConstantMockValue{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mConstantMockCompareTo struct {
	optional           bool
	mock               *ConstantMock
	defaultExpectation *ConstantMockCompareToExpectation
	expectations       []*ConstantMockCompareToExpectation

	callArgs []*ConstantMockCompareToParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ConstantMockCompareToExpectation specifies expectation struct of the Constant.CompareTo
type ConstantMockCompareToExpectation struct {
	mock      *ConstantMock
	params    *ConstantMockCompareToParams
	paramPtrs *ConstantMockCompareToParamPtrs
	results   *ConstantMockCompareToResults
	Counter   uint64
}

// ConstantMockCompareToParams contains parameters of the Constant.CompareTo
type ConstantMockCompareToParams struct {
	c1 Constant
}

// ConstantMockCompareToParamPtrs contains pointers to parameters of the Constant.CompareTo
type ConstantMockCompareToParamPtrs struct {
	c1 *Constant
}

// ConstantMockCompareToResults contains results of the Constant.CompareTo
type ConstantMockCompareToResults struct {
	c2 CompResult
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCompareTo *mConstantMockCompareTo) Optional() *mConstantMockCompareTo {
	mmCompareTo.optional = true
	return mmCompareTo
}

// Expect sets up expected params for Constant.CompareTo
func (mmCompareTo *mConstantMockCompareTo) Expect(c1 Constant) *mConstantMockCompareTo {
	if mmCompareTo.mock.funcCompareTo != nil {
		mmCompareTo.mock.t.Fatalf("ConstantMock.CompareTo mock is already set by Set")
	}

	if mmCompareTo.defaultExpectation == nil {
		mmCompareTo.defaultExpectation = &ConstantMockCompareToExpectation{}
	}

	if mmCompareTo.defaultExpectation.paramPtrs != nil {
		mmCompareTo.mock.t.Fatalf("ConstantMock.CompareTo mock is already set by ExpectParams functions")
	}

	mmCompareTo.defaultExpectation.params = &ConstantMockCompareToParams{c1}
	for _, e := range mmCompareTo.expectations {
		if minimock.Equal(e.params, mmCompareTo.defaultExpectation.params) {
			mmCompareTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCompareTo.defaultExpectation.params)
		}
	}

	return mmCompareTo
}

// ExpectC1Param1 sets up expected param c1 for Constant.CompareTo
func (mmCompareTo *mConstantMockCompareTo) ExpectC1Param1(c1 Constant) *mConstantMockCompareTo {
	if mmCompareTo.mock.funcCompareTo != nil {
		mmCompareTo.mock.t.Fatalf("ConstantMock.CompareTo mock is already set by Set")
	}

	if mmCompareTo.defaultExpectation == nil {
		mmCompareTo.defaultExpectation = &ConstantMockCompareToExpectation{}
	}

	if mmCompareTo.defaultExpectation.params != nil {
		mmCompareTo.mock.t.Fatalf("ConstantMock.CompareTo mock is already set by Expect")
	}

	if mmCompareTo.defaultExpectation.paramPtrs == nil {
		mmCompareTo.defaultExpectation.paramPtrs = &ConstantMockCompareToParamPtrs{}
	}
	mmCompareTo.defaultExpectation.paramPtrs.c1 = &c1

	return mmCompareTo
}

// Inspect accepts an inspector function that has same arguments as the Constant.CompareTo
func (mmCompareTo *mConstantMockCompareTo) Inspect(f func(c1 Constant)) *mConstantMockCompareTo {
	if mmCompareTo.mock.inspectFuncCompareTo != nil {
		mmCompareTo.mock.t.Fatalf("Inspect function is already set for ConstantMock.CompareTo")
	}

	mmCompareTo.mock.inspectFuncCompareTo = f

	return mmCompareTo
}

// Return sets up results that will be returned by Constant.CompareTo
func (mmCompareTo *mConstantMockCompareTo) Return(c2 CompResult) *ConstantMock {
	if mmCompareTo.mock.funcCompareTo != nil {
		mmCompareTo.mock.t.Fatalf("ConstantMock.CompareTo mock is already set by Set")
	}

	if mmCompareTo.defaultExpectation == nil {
		mmCompareTo.defaultExpectation = &ConstantMockCompareToExpectation{mock: mmCompareTo.mock}
	}
	mmCompareTo.defaultExpectation.results = &ConstantMockCompareToResults{c2}
	return mmCompareTo.mock
}

// Set uses given function f to mock the Constant.CompareTo method
func (mmCompareTo *mConstantMockCompareTo) Set(f func(c1 Constant) (c2 CompResult)) *ConstantMock {
	if mmCompareTo.defaultExpectation != nil {
		mmCompareTo.mock.t.Fatalf("Default expectation is already set for the Constant.CompareTo method")
	}

	if len(mmCompareTo.expectations) > 0 {
		mmCompareTo.mock.t.Fatalf("Some expectations are already set for the Constant.CompareTo method")
	}

	mmCompareTo.mock.funcCompareTo = f
	return mmCompareTo.mock
}

// When sets expectation for the Constant.CompareTo which will trigger the result defined by the following
// Then helper
func (mmCompareTo *mConstantMockCompareTo) When(c1 Constant) *ConstantMockCompareToExpectation {
	if mmCompareTo.mock.funcCompareTo != nil {
		mmCompareTo.mock.t.Fatalf("ConstantMock.CompareTo mock is already set by Set")
	}

	expectation := &ConstantMockCompareToExpectation{
		mock:   mmCompareTo.mock,
		params: &ConstantMockCompareToParams{c1},
	}
	mmCompareTo.expectations = append(mmCompareTo.expectations, expectation)
	return expectation
}

// Then sets up Constant.CompareTo return parameters for the expectation previously defined by the When method
func (e *ConstantMockCompareToExpectation) Then(c2 CompResult) *ConstantMock {
	e.results = &ConstantMockCompareToResults{c2}
	return e.mock
}

// Times sets number of times Constant.CompareTo should be invoked
func (mmCompareTo *mConstantMockCompareTo) Times(n uint64) *mConstantMockCompareTo {
	if n == 0 {
		mmCompareTo.mock.t.Fatalf("Times of ConstantMock.CompareTo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCompareTo.expectedInvocations, n)
	return mmCompareTo
}

func (mmCompareTo *mConstantMockCompareTo) invocationsDone() bool {
	if len(mmCompareTo.expectations) == 0 && mmCompareTo.defaultExpectation == nil && mmCompareTo.mock.funcCompareTo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCompareTo.mock.afterCompareToCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCompareTo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CompareTo implements Constant
func (mmCompareTo *ConstantMock) CompareTo(c1 Constant) (c2 CompResult) {
	mm_atomic.AddUint64(&mmCompareTo.beforeCompareToCounter, 1)
	defer mm_atomic.AddUint64(&mmCompareTo.afterCompareToCounter, 1)

	if mmCompareTo.inspectFuncCompareTo != nil {
		mmCompareTo.inspectFuncCompareTo(c1)
	}

	mm_params := ConstantMockCompareToParams{c1}

	// Record call args
	mmCompareTo.CompareToMock.mutex.Lock()
	mmCompareTo.CompareToMock.callArgs = append(mmCompareTo.CompareToMock.callArgs, &mm_params)
	mmCompareTo.CompareToMock.mutex.Unlock()

	for _, e := range mmCompareTo.CompareToMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2
		}
	}

	if mmCompareTo.CompareToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCompareTo.CompareToMock.defaultExpectation.Counter, 1)
		mm_want := mmCompareTo.CompareToMock.defaultExpectation.params
		mm_want_ptrs := mmCompareTo.CompareToMock.defaultExpectation.paramPtrs

		mm_got := ConstantMockCompareToParams{c1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.c1 != nil && !minimock.Equal(*mm_want_ptrs.c1, mm_got.c1) {
				mmCompareTo.t.Errorf("ConstantMock.CompareTo got unexpected parameter c1, want: %#v, got: %#v%s\n", *mm_want_ptrs.c1, mm_got.c1, minimock.Diff(*mm_want_ptrs.c1, mm_got.c1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCompareTo.t.Errorf("ConstantMock.CompareTo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCompareTo.CompareToMock.defaultExpectation.results
		if mm_results == nil {
			mmCompareTo.t.Fatal("No results are set for the ConstantMock.CompareTo")
		}
		return (*mm_results).c2
	}
	if mmCompareTo.funcCompareTo != nil {
		return mmCompareTo.funcCompareTo(c1)
	}
	mmCompareTo.t.Fatalf("Unexpected call to ConstantMock.CompareTo. %v", c1)
	return
}

// CompareToAfterCounter returns a count of finished ConstantMock.CompareTo invocations
func (mmCompareTo *ConstantMock) CompareToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCompareTo.afterCompareToCounter)
}

// CompareToBeforeCounter returns a count of ConstantMock.CompareTo invocations
func (mmCompareTo *ConstantMock) CompareToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCompareTo.beforeCompareToCounter)
}

// Calls returns a list of arguments used in each call to ConstantMock.CompareTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCompareTo *mConstantMockCompareTo) Calls() []*ConstantMockCompareToParams {
	mmCompareTo.mutex.RLock()

	argCopy := make([]*ConstantMockCompareToParams, len(mmCompareTo.callArgs))
	copy(argCopy, mmCompareTo.callArgs)

	mmCompareTo.mutex.RUnlock()

	return argCopy
}

// MinimockCompareToDone returns true if the count of the CompareTo invocations corresponds
// the number of defined expectations
func (m *ConstantMock) MinimockCompareToDone() bool {
	if m.CompareToMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CompareToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CompareToMock.invocationsDone()
}

// MinimockCompareToInspect logs each unmet expectation
func (m *ConstantMock) MinimockCompareToInspect() {
	for _, e := range m.CompareToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConstantMock.CompareTo with params: %#v", *e.params)
		}
	}

	afterCompareToCounter := mm_atomic.LoadUint64(&m.afterCompareToCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CompareToMock.defaultExpectation != nil && afterCompareToCounter < 1 {
		if m.CompareToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConstantMock.CompareTo")
		} else {
			m.t.Errorf("Expected call to ConstantMock.CompareTo with params: %#v", *m.CompareToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCompareTo != nil && afterCompareToCounter < 1 {
		m.t.Error("Expected call to ConstantMock.CompareTo")
	}

	if !m.CompareToMock.invocationsDone() && afterCompareToCounter > 0 {
		m.t.Errorf("Expected %d calls to ConstantMock.CompareTo but found %d calls",
			mm_atomic.LoadUint64(&m.CompareToMock.expectedInvocations), afterCompareToCounter)
	}
}

type mConstantMockHash struct {
	optional           bool
	mock               *ConstantMock
	defaultExpectation *ConstantMockHashExpectation
	expectations       []*ConstantMockHashExpectation

	expectedInvocations uint64
}

// ConstantMockHashExpectation specifies expectation struct of the Constant.Hash
type ConstantMockHashExpectation struct {
	mock *ConstantMock

	results *ConstantMockHashResults
	Counter uint64
}

// ConstantMockHashResults contains results of the Constant.Hash
type ConstantMockHashResults struct {
	u1 uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHash *mConstantMockHash) Optional() *mConstantMockHash {
	mmHash.optional = true
	return mmHash
}

// Expect sets up expected params for Constant.Hash
func (mmHash *mConstantMockHash) Expect() *mConstantMockHash {
	if mmHash.mock.funcHash != nil {
		mmHash.mock.t.Fatalf("ConstantMock.Hash mock is already set by Set")
	}

	if mmHash.defaultExpectation == nil {
		mmHash.defaultExpectation = &ConstantMockHashExpectation{}
	}

	return mmHash
}

// Inspect accepts an inspector function that has same arguments as the Constant.Hash
func (mmHash *mConstantMockHash) Inspect(f func()) *mConstantMockHash {
	if mmHash.mock.inspectFuncHash != nil {
		mmHash.mock.t.Fatalf("Inspect function is already set for ConstantMock.Hash")
	}

	mmHash.mock.inspectFuncHash = f

	return mmHash
}

// Return sets up results that will be returned by Constant.Hash
func (mmHash *mConstantMockHash) Return(u1 uint64) *ConstantMock {
	if mmHash.mock.funcHash != nil {
		mmHash.mock.t.Fatalf("ConstantMock.Hash mock is already set by Set")
	}

	if mmHash.defaultExpectation == nil {
		mmHash.defaultExpectation = &ConstantMockHashExpectation{mock: mmHash.mock}
	}
	mmHash.defaultExpectation.results = &ConstantMockHashResults{u1}
	return mmHash.mock
}

// Set uses given function f to mock the Constant.Hash method
func (mmHash *mConstantMockHash) Set(f func() (u1 uint64)) *ConstantMock {
	if mmHash.defaultExpectation != nil {
		mmHash.mock.t.Fatalf("Default expectation is already set for the Constant.Hash method")
	}

	if len(mmHash.expectations) > 0 {
		mmHash.mock.t.Fatalf("Some expectations are already set for the Constant.Hash method")
	}

	mmHash.mock.funcHash = f
	return mmHash.mock
}

// Times sets number of times Constant.Hash should be invoked
func (mmHash *mConstantMockHash) Times(n uint64) *mConstantMockHash {
	if n == 0 {
		mmHash.mock.t.Fatalf("Times of ConstantMock.Hash mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHash.expectedInvocations, n)
	return mmHash
}

func (mmHash *mConstantMockHash) invocationsDone() bool {
	if len(mmHash.expectations) == 0 && mmHash.defaultExpectation == nil && mmHash.mock.funcHash == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHash.mock.afterHashCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHash.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Hash implements Constant
func (mmHash *ConstantMock) Hash() (u1 uint64) {
	mm_atomic.AddUint64(&mmHash.beforeHashCounter, 1)
	defer mm_atomic.AddUint64(&mmHash.afterHashCounter, 1)

	if mmHash.inspectFuncHash != nil {
		mmHash.inspectFuncHash()
	}

	if mmHash.HashMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHash.HashMock.defaultExpectation.Counter, 1)

		mm_results := mmHash.HashMock.defaultExpectation.results
		if mm_results == nil {
			mmHash.t.Fatal("No results are set for the ConstantMock.Hash")
		}
		return (*mm_results).u1
	}
	if mmHash.funcHash != nil {
		return mmHash.funcHash()
	}
	mmHash.t.Fatalf("Unexpected call to ConstantMock.Hash.")
	return
}

// HashAfterCounter returns a count of finished ConstantMock.Hash invocations
func (mmHash *ConstantMock) HashAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHash.afterHashCounter)
}

// HashBeforeCounter returns a count of ConstantMock.Hash invocations
func (mmHash *ConstantMock) HashBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHash.beforeHashCounter)
}

// MinimockHashDone returns true if the count of the Hash invocations corresponds
// the number of defined expectations
func (m *ConstantMock) MinimockHashDone() bool {
	if m.HashMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HashMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HashMock.invocationsDone()
}

// MinimockHashInspect logs each unmet expectation
func (m *ConstantMock) MinimockHashInspect() {
	for _, e := range m.HashMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConstantMock.Hash")
		}
	}

	afterHashCounter := mm_atomic.LoadUint64(&m.afterHashCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HashMock.defaultExpectation != nil && afterHashCounter < 1 {
		m.t.Error("Expected call to ConstantMock.Hash")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHash != nil && afterHashCounter < 1 {
		m.t.Error("Expected call to ConstantMock.Hash")
	}

	if !m.HashMock.invocationsDone() && afterHashCounter > 0 {
		m.t.Errorf("Expected %d calls to ConstantMock.Hash but found %d calls",
			mm_atomic.LoadUint64(&m.HashMock.expectedInvocations), afterHashCounter)
	}
}

type mConstantMockString struct {
	optional           bool
	mock               *ConstantMock
	defaultExpectation *ConstantMockStringExpectation
	expectations       []*ConstantMockStringExpectation

	expectedInvocations uint64
}

// ConstantMockStringExpectation specifies expectation struct of the Constant.String
type ConstantMockStringExpectation struct {
	mock *ConstantMock

	results *ConstantMockStringResults
	Counter uint64
}

// ConstantMockStringResults contains results of the Constant.String
type ConstantMockStringResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmString *mConstantMockString) Optional() *mConstantMockString {
	mmString.optional = true
	return mmString
}

// Expect sets up expected params for Constant.String
func (mmString *mConstantMockString) Expect() *mConstantMockString {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("ConstantMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &ConstantMockStringExpectation{}
	}

	return mmString
}

// Inspect accepts an inspector function that has same arguments as the Constant.String
func (mmString *mConstantMockString) Inspect(f func()) *mConstantMockString {
	if mmString.mock.inspectFuncString != nil {
		mmString.mock.t.Fatalf("Inspect function is already set for ConstantMock.String")
	}

	mmString.mock.inspectFuncString = f

	return mmString
}

// Return sets up results that will be returned by Constant.String
func (mmString *mConstantMockString) Return(s1 string) *ConstantMock {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("ConstantMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &ConstantMockStringExpectation{mock: mmString.mock}
	}
	mmString.defaultExpectation.results = &ConstantMockStringResults{s1}
	return mmString.mock
}

// Set uses given function f to mock the Constant.String method
func (mmString *mConstantMockString) Set(f func() (s1 string)) *ConstantMock {
	if mmString.defaultExpectation != nil {
		mmString.mock.t.Fatalf("Default expectation is already set for the Constant.String method")
	}

	if len(mmString.expectations) > 0 {
		mmString.mock.t.Fatalf("Some expectations are already set for the Constant.String method")
	}

	mmString.mock.funcString = f
	return mmString.mock
}

// Times sets number of times Constant.String should be invoked
func (mmString *mConstantMockString) Times(n uint64) *mConstantMockString {
	if n == 0 {
		mmString.mock.t.Fatalf("Times of ConstantMock.String mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmString.expectedInvocations, n)
	return mmString
}

func (mmString *mConstantMockString) invocationsDone() bool {
	if len(mmString.expectations) == 0 && mmString.defaultExpectation == nil && mmString.mock.funcString == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmString.mock.afterStringCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmString.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// String implements Constant
func (mmString *ConstantMock) String() (s1 string) {
	mm_atomic.AddUint64(&mmString.beforeStringCounter, 1)
	defer mm_atomic.AddUint64(&mmString.afterStringCounter, 1)

	if mmString.inspectFuncString != nil {
		mmString.inspectFuncString()
	}

	if mmString.StringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmString.StringMock.defaultExpectation.Counter, 1)

		mm_results := mmString.StringMock.defaultExpectation.results
		if mm_results == nil {
			mmString.t.Fatal("No results are set for the ConstantMock.String")
		}
		return (*mm_results).s1
	}
	if mmString.funcString != nil {
		return mmString.funcString()
	}
	mmString.t.Fatalf("Unexpected call to ConstantMock.String.")
	return
}

// StringAfterCounter returns a count of finished ConstantMock.String invocations
func (mmString *ConstantMock) StringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.afterStringCounter)
}

// StringBeforeCounter returns a count of ConstantMock.String invocations
func (mmString *ConstantMock) StringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.beforeStringCounter)
}

// MinimockStringDone returns true if the count of the String invocations corresponds
// the number of defined expectations
func (m *ConstantMock) MinimockStringDone() bool {
	if m.StringMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StringMock.invocationsDone()
}

// MinimockStringInspect logs each unmet expectation
func (m *ConstantMock) MinimockStringInspect() {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConstantMock.String")
		}
	}

	afterStringCounter := mm_atomic.LoadUint64(&m.afterStringCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && afterStringCounter < 1 {
		m.t.Error("Expected call to ConstantMock.String")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && afterStringCounter < 1 {
		m.t.Error("Expected call to ConstantMock.String")
	}

	if !m.StringMock.invocationsDone() && afterStringCounter > 0 {
		m.t.Errorf("Expected %d calls to ConstantMock.String but found %d calls",
			mm_atomic.LoadUint64(&m.StringMock.expectedInvocations), afterStringCounter)
	}
}

type mConstantMockType struct {
	optional           bool
	mock               *ConstantMock
	defaultExpectation *ConstantMockTypeExpectation
	expectations       []*ConstantMockTypeExpectation

	expectedInvocations uint64
}

// ConstantMockTypeExpectation specifies expectation struct of the Constant.Type
type ConstantMockTypeExpectation struct {
	mock *ConstantMock

	results *ConstantMockTypeResults
	Counter uint64
}

// ConstantMockTypeResults contains results of the Constant.Type
type ConstantMockTypeResults struct {
	f1 records.FieldType
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmType *mConstantMockType) Optional() *mConstantMockType {
	mmType.optional = true
	return mmType
}

// Expect sets up expected params for Constant.Type
func (mmType *mConstantMockType) Expect() *mConstantMockType {
	if mmType.mock.funcType != nil {
		mmType.mock.t.Fatalf("ConstantMock.Type mock is already set by Set")
	}

	if mmType.defaultExpectation == nil {
		mmType.defaultExpectation = &ConstantMockTypeExpectation{}
	}

	return mmType
}

// Inspect accepts an inspector function that has same arguments as the Constant.Type
func (mmType *mConstantMockType) Inspect(f func()) *mConstantMockType {
	if mmType.mock.inspectFuncType != nil {
		mmType.mock.t.Fatalf("Inspect function is already set for ConstantMock.Type")
	}

	mmType.mock.inspectFuncType = f

	return mmType
}

// Return sets up results that will be returned by Constant.Type
func (mmType *mConstantMockType) Return(f1 records.FieldType) *ConstantMock {
	if mmType.mock.funcType != nil {
		mmType.mock.t.Fatalf("ConstantMock.Type mock is already set by Set")
	}

	if mmType.defaultExpectation == nil {
		mmType.defaultExpectation = &ConstantMockTypeExpectation{mock: mmType.mock}
	}
	mmType.defaultExpectation.results = &ConstantMockTypeResults{f1}
	return mmType.mock
}

// Set uses given function f to mock the Constant.Type method
func (mmType *mConstantMockType) Set(f func() (f1 records.FieldType)) *ConstantMock {
	if mmType.defaultExpectation != nil {
		mmType.mock.t.Fatalf("Default expectation is already set for the Constant.Type method")
	}

	if len(mmType.expectations) > 0 {
		mmType.mock.t.Fatalf("Some expectations are already set for the Constant.Type method")
	}

	mmType.mock.funcType = f
	return mmType.mock
}

// Times sets number of times Constant.Type should be invoked
func (mmType *mConstantMockType) Times(n uint64) *mConstantMockType {
	if n == 0 {
		mmType.mock.t.Fatalf("Times of ConstantMock.Type mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmType.expectedInvocations, n)
	return mmType
}

func (mmType *mConstantMockType) invocationsDone() bool {
	if len(mmType.expectations) == 0 && mmType.defaultExpectation == nil && mmType.mock.funcType == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmType.mock.afterTypeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmType.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Type implements Constant
func (mmType *ConstantMock) Type() (f1 records.FieldType) {
	mm_atomic.AddUint64(&mmType.beforeTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmType.afterTypeCounter, 1)

	if mmType.inspectFuncType != nil {
		mmType.inspectFuncType()
	}

	if mmType.TypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmType.TypeMock.defaultExpectation.Counter, 1)

		mm_results := mmType.TypeMock.defaultExpectation.results
		if mm_results == nil {
			mmType.t.Fatal("No results are set for the ConstantMock.Type")
		}
		return (*mm_results).f1
	}
	if mmType.funcType != nil {
		return mmType.funcType()
	}
	mmType.t.Fatalf("Unexpected call to ConstantMock.Type.")
	return
}

// TypeAfterCounter returns a count of finished ConstantMock.Type invocations
func (mmType *ConstantMock) TypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmType.afterTypeCounter)
}

// TypeBeforeCounter returns a count of ConstantMock.Type invocations
func (mmType *ConstantMock) TypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmType.beforeTypeCounter)
}

// MinimockTypeDone returns true if the count of the Type invocations corresponds
// the number of defined expectations
func (m *ConstantMock) MinimockTypeDone() bool {
	if m.TypeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TypeMock.invocationsDone()
}

// MinimockTypeInspect logs each unmet expectation
func (m *ConstantMock) MinimockTypeInspect() {
	for _, e := range m.TypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConstantMock.Type")
		}
	}

	afterTypeCounter := mm_atomic.LoadUint64(&m.afterTypeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TypeMock.defaultExpectation != nil && afterTypeCounter < 1 {
		m.t.Error("Expected call to ConstantMock.Type")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcType != nil && afterTypeCounter < 1 {
		m.t.Error("Expected call to ConstantMock.Type")
	}

	if !m.TypeMock.invocationsDone() && afterTypeCounter > 0 {
		m.t.Errorf("Expected %d calls to ConstantMock.Type but found %d calls",
			mm_atomic.LoadUint64(&m.TypeMock.expectedInvocations), afterTypeCounter)
	}
}

type mConstantMockValue struct {
	optional           bool
	mock               *ConstantMock
	defaultExpectation *ConstantMockValueExpectation
	expectations       []*ConstantMockValueExpectation

	expectedInvocations uint64
}

// ConstantMockValueExpectation specifies expectation struct of the Constant.Value
type ConstantMockValueExpectation struct {
	mock *ConstantMock

	results *ConstantMockValueResults
	Counter uint64
}

// ConstantMockValueResults contains results of the Constant.Value
type ConstantMockValueResults struct {
	a1 any
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValue *mConstantMockValue) Optional() *mConstantMockValue {
	mmValue.optional = true
	return mmValue
}

// Expect sets up expected params for Constant.Value
func (mmValue *mConstantMockValue) Expect() *mConstantMockValue {
	if mmValue.mock.funcValue != nil {
		mmValue.mock.t.Fatalf("ConstantMock.Value mock is already set by Set")
	}

	if mmValue.defaultExpectation == nil {
		mmValue.defaultExpectation = &ConstantMockValueExpectation{}
	}

	return mmValue
}

// Inspect accepts an inspector function that has same arguments as the Constant.Value
func (mmValue *mConstantMockValue) Inspect(f func()) *mConstantMockValue {
	if mmValue.mock.inspectFuncValue != nil {
		mmValue.mock.t.Fatalf("Inspect function is already set for ConstantMock.Value")
	}

	mmValue.mock.inspectFuncValue = f

	return mmValue
}

// Return sets up results that will be returned by Constant.Value
func (mmValue *mConstantMockValue) Return(a1 any) *ConstantMock {
	if mmValue.mock.funcValue != nil {
		mmValue.mock.t.Fatalf("ConstantMock.Value mock is already set by Set")
	}

	if mmValue.defaultExpectation == nil {
		mmValue.defaultExpectation = &ConstantMockValueExpectation{mock: mmValue.mock}
	}
	mmValue.defaultExpectation.results = &ConstantMockValueResults{a1}
	return mmValue.mock
}

// Set uses given function f to mock the Constant.Value method
func (mmValue *mConstantMockValue) Set(f func() (a1 any)) *ConstantMock {
	if mmValue.defaultExpectation != nil {
		mmValue.mock.t.Fatalf("Default expectation is already set for the Constant.Value method")
	}

	if len(mmValue.expectations) > 0 {
		mmValue.mock.t.Fatalf("Some expectations are already set for the Constant.Value method")
	}

	mmValue.mock.funcValue = f
	return mmValue.mock
}

// Times sets number of times Constant.Value should be invoked
func (mmValue *mConstantMockValue) Times(n uint64) *mConstantMockValue {
	if n == 0 {
		mmValue.mock.t.Fatalf("Times of ConstantMock.Value mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValue.expectedInvocations, n)
	return mmValue
}

func (mmValue *mConstantMockValue) invocationsDone() bool {
	if len(mmValue.expectations) == 0 && mmValue.defaultExpectation == nil && mmValue.mock.funcValue == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValue.mock.afterValueCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValue.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Value implements Constant
func (mmValue *ConstantMock) Value() (a1 any) {
	mm_atomic.AddUint64(&mmValue.beforeValueCounter, 1)
	defer mm_atomic.AddUint64(&mmValue.afterValueCounter, 1)

	if mmValue.inspectFuncValue != nil {
		mmValue.inspectFuncValue()
	}

	if mmValue.ValueMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValue.ValueMock.defaultExpectation.Counter, 1)

		mm_results := mmValue.ValueMock.defaultExpectation.results
		if mm_results == nil {
			mmValue.t.Fatal("No results are set for the ConstantMock.Value")
		}
		return (*mm_results).a1
	}
	if mmValue.funcValue != nil {
		return mmValue.funcValue()
	}
	mmValue.t.Fatalf("Unexpected call to ConstantMock.Value.")
	return
}

// ValueAfterCounter returns a count of finished ConstantMock.Value invocations
func (mmValue *ConstantMock) ValueAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValue.afterValueCounter)
}

// ValueBeforeCounter returns a count of ConstantMock.Value invocations
func (mmValue *ConstantMock) ValueBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValue.beforeValueCounter)
}

// MinimockValueDone returns true if the count of the Value invocations corresponds
// the number of defined expectations
func (m *ConstantMock) MinimockValueDone() bool {
	if m.ValueMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValueMock.invocationsDone()
}

// MinimockValueInspect logs each unmet expectation
func (m *ConstantMock) MinimockValueInspect() {
	for _, e := range m.ValueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConstantMock.Value")
		}
	}

	afterValueCounter := mm_atomic.LoadUint64(&m.afterValueCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValueMock.defaultExpectation != nil && afterValueCounter < 1 {
		m.t.Error("Expected call to ConstantMock.Value")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValue != nil && afterValueCounter < 1 {
		m.t.Error("Expected call to ConstantMock.Value")
	}

	if !m.ValueMock.invocationsDone() && afterValueCounter > 0 {
		m.t.Errorf("Expected %d calls to ConstantMock.Value but found %d calls",
			mm_atomic.LoadUint64(&m.ValueMock.expectedInvocations), afterValueCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ConstantMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCompareToInspect()

			m.MinimockHashInspect()

			m.MinimockStringInspect()

			m.MinimockTypeInspect()

			m.MinimockValueInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ConstantMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ConstantMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCompareToDone() &&
		m.MinimockHashDone() &&
		m.MinimockStringDone() &&
		m.MinimockTypeDone() &&
		m.MinimockValueDone()
}
