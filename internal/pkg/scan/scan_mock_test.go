// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package scan

//go:generate minimock -i github.com/unhandled-exception/sophiadb/internal/pkg/scan.Scan -o scan_mock_test.go -n ScanMock -p scan

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/unhandled-exception/sophiadb/internal/pkg/records"
)

// ScanMock implements Scan
type ScanMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBeforeFirst          func() (err error)
	inspectFuncBeforeFirst   func()
	afterBeforeFirstCounter  uint64
	beforeBeforeFirstCounter uint64
	BeforeFirstMock          mScanMockBeforeFirst

	funcClose          func()
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mScanMockClose

	funcGetInt64          func(fieldName string) (i1 int64, err error)
	inspectFuncGetInt64   func(fieldName string)
	afterGetInt64Counter  uint64
	beforeGetInt64Counter uint64
	GetInt64Mock          mScanMockGetInt64

	funcGetInt8          func(fieldName string) (i1 int8, err error)
	inspectFuncGetInt8   func(fieldName string)
	afterGetInt8Counter  uint64
	beforeGetInt8Counter uint64
	GetInt8Mock          mScanMockGetInt8

	funcGetString          func(fieldName string) (s1 string, err error)
	inspectFuncGetString   func(fieldName string)
	afterGetStringCounter  uint64
	beforeGetStringCounter uint64
	GetStringMock          mScanMockGetString

	funcGetVal          func(fieldName string) (c1 Constant, err error)
	inspectFuncGetVal   func(fieldName string)
	afterGetValCounter  uint64
	beforeGetValCounter uint64
	GetValMock          mScanMockGetVal

	funcHasField          func(fieldName string) (b1 bool)
	inspectFuncHasField   func(fieldName string)
	afterHasFieldCounter  uint64
	beforeHasFieldCounter uint64
	HasFieldMock          mScanMockHasField

	funcNext          func() (b1 bool, err error)
	inspectFuncNext   func()
	afterNextCounter  uint64
	beforeNextCounter uint64
	NextMock          mScanMockNext

	funcSchema          func() (s1 records.Schema)
	inspectFuncSchema   func()
	afterSchemaCounter  uint64
	beforeSchemaCounter uint64
	SchemaMock          mScanMockSchema
}

// NewScanMock returns a mock for Scan
func NewScanMock(t minimock.Tester) *ScanMock {
	m := &ScanMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeforeFirstMock = mScanMockBeforeFirst{mock: m}

	m.CloseMock = mScanMockClose{mock: m}

	m.GetInt64Mock = mScanMockGetInt64{mock: m}
	m.GetInt64Mock.callArgs = []*ScanMockGetInt64Params{}

	m.GetInt8Mock = mScanMockGetInt8{mock: m}
	m.GetInt8Mock.callArgs = []*ScanMockGetInt8Params{}

	m.GetStringMock = mScanMockGetString{mock: m}
	m.GetStringMock.callArgs = []*ScanMockGetStringParams{}

	m.GetValMock = mScanMockGetVal{mock: m}
	m.GetValMock.callArgs = []*ScanMockGetValParams{}

	m.HasFieldMock = mScanMockHasField{mock: m}
	m.HasFieldMock.callArgs = []*ScanMockHasFieldParams{}

	m.NextMock = mScanMockNext{mock: m}

	m.SchemaMock = mScanMockSchema{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mScanMockBeforeFirst struct {
	optional           bool
	mock               *ScanMock
	defaultExpectation *ScanMockBeforeFirstExpectation
	expectations       []*ScanMockBeforeFirstExpectation

	expectedInvocations uint64
}

// ScanMockBeforeFirstExpectation specifies expectation struct of the Scan.BeforeFirst
type ScanMockBeforeFirstExpectation struct {
	mock *ScanMock

	results *ScanMockBeforeFirstResults
	Counter uint64
}

// ScanMockBeforeFirstResults contains results of the Scan.BeforeFirst
type ScanMockBeforeFirstResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBeforeFirst *mScanMockBeforeFirst) Optional() *mScanMockBeforeFirst {
	mmBeforeFirst.optional = true
	return mmBeforeFirst
}

// Expect sets up expected params for Scan.BeforeFirst
func (mmBeforeFirst *mScanMockBeforeFirst) Expect() *mScanMockBeforeFirst {
	if mmBeforeFirst.mock.funcBeforeFirst != nil {
		mmBeforeFirst.mock.t.Fatalf("ScanMock.BeforeFirst mock is already set by Set")
	}

	if mmBeforeFirst.defaultExpectation == nil {
		mmBeforeFirst.defaultExpectation = &ScanMockBeforeFirstExpectation{}
	}

	return mmBeforeFirst
}

// Inspect accepts an inspector function that has same arguments as the Scan.BeforeFirst
func (mmBeforeFirst *mScanMockBeforeFirst) Inspect(f func()) *mScanMockBeforeFirst {
	if mmBeforeFirst.mock.inspectFuncBeforeFirst != nil {
		mmBeforeFirst.mock.t.Fatalf("Inspect function is already set for ScanMock.BeforeFirst")
	}

	mmBeforeFirst.mock.inspectFuncBeforeFirst = f

	return mmBeforeFirst
}

// Return sets up results that will be returned by Scan.BeforeFirst
func (mmBeforeFirst *mScanMockBeforeFirst) Return(err error) *ScanMock {
	if mmBeforeFirst.mock.funcBeforeFirst != nil {
		mmBeforeFirst.mock.t.Fatalf("ScanMock.BeforeFirst mock is already set by Set")
	}

	if mmBeforeFirst.defaultExpectation == nil {
		mmBeforeFirst.defaultExpectation = &ScanMockBeforeFirstExpectation{mock: mmBeforeFirst.mock}
	}
	mmBeforeFirst.defaultExpectation.results = &ScanMockBeforeFirstResults{err}
	return mmBeforeFirst.mock
}

// Set uses given function f to mock the Scan.BeforeFirst method
func (mmBeforeFirst *mScanMockBeforeFirst) Set(f func() (err error)) *ScanMock {
	if mmBeforeFirst.defaultExpectation != nil {
		mmBeforeFirst.mock.t.Fatalf("Default expectation is already set for the Scan.BeforeFirst method")
	}

	if len(mmBeforeFirst.expectations) > 0 {
		mmBeforeFirst.mock.t.Fatalf("Some expectations are already set for the Scan.BeforeFirst method")
	}

	mmBeforeFirst.mock.funcBeforeFirst = f
	return mmBeforeFirst.mock
}

// Times sets number of times Scan.BeforeFirst should be invoked
func (mmBeforeFirst *mScanMockBeforeFirst) Times(n uint64) *mScanMockBeforeFirst {
	if n == 0 {
		mmBeforeFirst.mock.t.Fatalf("Times of ScanMock.BeforeFirst mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBeforeFirst.expectedInvocations, n)
	return mmBeforeFirst
}

func (mmBeforeFirst *mScanMockBeforeFirst) invocationsDone() bool {
	if len(mmBeforeFirst.expectations) == 0 && mmBeforeFirst.defaultExpectation == nil && mmBeforeFirst.mock.funcBeforeFirst == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBeforeFirst.mock.afterBeforeFirstCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBeforeFirst.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// BeforeFirst implements Scan
func (mmBeforeFirst *ScanMock) BeforeFirst() (err error) {
	mm_atomic.AddUint64(&mmBeforeFirst.beforeBeforeFirstCounter, 1)
	defer mm_atomic.AddUint64(&mmBeforeFirst.afterBeforeFirstCounter, 1)

	if mmBeforeFirst.inspectFuncBeforeFirst != nil {
		mmBeforeFirst.inspectFuncBeforeFirst()
	}

	if mmBeforeFirst.BeforeFirstMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBeforeFirst.BeforeFirstMock.defaultExpectation.Counter, 1)

		mm_results := mmBeforeFirst.BeforeFirstMock.defaultExpectation.results
		if mm_results == nil {
			mmBeforeFirst.t.Fatal("No results are set for the ScanMock.BeforeFirst")
		}
		return (*mm_results).err
	}
	if mmBeforeFirst.funcBeforeFirst != nil {
		return mmBeforeFirst.funcBeforeFirst()
	}
	mmBeforeFirst.t.Fatalf("Unexpected call to ScanMock.BeforeFirst.")
	return
}

// BeforeFirstAfterCounter returns a count of finished ScanMock.BeforeFirst invocations
func (mmBeforeFirst *ScanMock) BeforeFirstAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeforeFirst.afterBeforeFirstCounter)
}

// BeforeFirstBeforeCounter returns a count of ScanMock.BeforeFirst invocations
func (mmBeforeFirst *ScanMock) BeforeFirstBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeforeFirst.beforeBeforeFirstCounter)
}

// MinimockBeforeFirstDone returns true if the count of the BeforeFirst invocations corresponds
// the number of defined expectations
func (m *ScanMock) MinimockBeforeFirstDone() bool {
	if m.BeforeFirstMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BeforeFirstMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BeforeFirstMock.invocationsDone()
}

// MinimockBeforeFirstInspect logs each unmet expectation
func (m *ScanMock) MinimockBeforeFirstInspect() {
	for _, e := range m.BeforeFirstMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScanMock.BeforeFirst")
		}
	}

	afterBeforeFirstCounter := mm_atomic.LoadUint64(&m.afterBeforeFirstCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BeforeFirstMock.defaultExpectation != nil && afterBeforeFirstCounter < 1 {
		m.t.Error("Expected call to ScanMock.BeforeFirst")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeforeFirst != nil && afterBeforeFirstCounter < 1 {
		m.t.Error("Expected call to ScanMock.BeforeFirst")
	}

	if !m.BeforeFirstMock.invocationsDone() && afterBeforeFirstCounter > 0 {
		m.t.Errorf("Expected %d calls to ScanMock.BeforeFirst but found %d calls",
			mm_atomic.LoadUint64(&m.BeforeFirstMock.expectedInvocations), afterBeforeFirstCounter)
	}
}

type mScanMockClose struct {
	optional           bool
	mock               *ScanMock
	defaultExpectation *ScanMockCloseExpectation
	expectations       []*ScanMockCloseExpectation

	expectedInvocations uint64
}

// ScanMockCloseExpectation specifies expectation struct of the Scan.Close
type ScanMockCloseExpectation struct {
	mock *ScanMock

	Counter uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mScanMockClose) Optional() *mScanMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for Scan.Close
func (mmClose *mScanMockClose) Expect() *mScanMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ScanMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ScanMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Scan.Close
func (mmClose *mScanMockClose) Inspect(f func()) *mScanMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for ScanMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Scan.Close
func (mmClose *mScanMockClose) Return() *ScanMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ScanMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ScanMockCloseExpectation{mock: mmClose.mock}
	}

	return mmClose.mock
}

// Set uses given function f to mock the Scan.Close method
func (mmClose *mScanMockClose) Set(f func()) *ScanMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Scan.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Scan.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Times sets number of times Scan.Close should be invoked
func (mmClose *mScanMockClose) Times(n uint64) *mScanMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of ScanMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	return mmClose
}

func (mmClose *mScanMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements Scan
func (mmClose *ScanMock) Close() {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		return

	}
	if mmClose.funcClose != nil {
		mmClose.funcClose()
		return
	}
	mmClose.t.Fatalf("Unexpected call to ScanMock.Close.")

}

// CloseAfterCounter returns a count of finished ScanMock.Close invocations
func (mmClose *ScanMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of ScanMock.Close invocations
func (mmClose *ScanMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *ScanMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *ScanMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScanMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Error("Expected call to ScanMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Error("Expected call to ScanMock.Close")
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to ScanMock.Close but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), afterCloseCounter)
	}
}

type mScanMockGetInt64 struct {
	optional           bool
	mock               *ScanMock
	defaultExpectation *ScanMockGetInt64Expectation
	expectations       []*ScanMockGetInt64Expectation

	callArgs []*ScanMockGetInt64Params
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ScanMockGetInt64Expectation specifies expectation struct of the Scan.GetInt64
type ScanMockGetInt64Expectation struct {
	mock      *ScanMock
	params    *ScanMockGetInt64Params
	paramPtrs *ScanMockGetInt64ParamPtrs
	results   *ScanMockGetInt64Results
	Counter   uint64
}

// ScanMockGetInt64Params contains parameters of the Scan.GetInt64
type ScanMockGetInt64Params struct {
	fieldName string
}

// ScanMockGetInt64ParamPtrs contains pointers to parameters of the Scan.GetInt64
type ScanMockGetInt64ParamPtrs struct {
	fieldName *string
}

// ScanMockGetInt64Results contains results of the Scan.GetInt64
type ScanMockGetInt64Results struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetInt64 *mScanMockGetInt64) Optional() *mScanMockGetInt64 {
	mmGetInt64.optional = true
	return mmGetInt64
}

// Expect sets up expected params for Scan.GetInt64
func (mmGetInt64 *mScanMockGetInt64) Expect(fieldName string) *mScanMockGetInt64 {
	if mmGetInt64.mock.funcGetInt64 != nil {
		mmGetInt64.mock.t.Fatalf("ScanMock.GetInt64 mock is already set by Set")
	}

	if mmGetInt64.defaultExpectation == nil {
		mmGetInt64.defaultExpectation = &ScanMockGetInt64Expectation{}
	}

	if mmGetInt64.defaultExpectation.paramPtrs != nil {
		mmGetInt64.mock.t.Fatalf("ScanMock.GetInt64 mock is already set by ExpectParams functions")
	}

	mmGetInt64.defaultExpectation.params = &ScanMockGetInt64Params{fieldName}
	for _, e := range mmGetInt64.expectations {
		if minimock.Equal(e.params, mmGetInt64.defaultExpectation.params) {
			mmGetInt64.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetInt64.defaultExpectation.params)
		}
	}

	return mmGetInt64
}

// ExpectFieldNameParam1 sets up expected param fieldName for Scan.GetInt64
func (mmGetInt64 *mScanMockGetInt64) ExpectFieldNameParam1(fieldName string) *mScanMockGetInt64 {
	if mmGetInt64.mock.funcGetInt64 != nil {
		mmGetInt64.mock.t.Fatalf("ScanMock.GetInt64 mock is already set by Set")
	}

	if mmGetInt64.defaultExpectation == nil {
		mmGetInt64.defaultExpectation = &ScanMockGetInt64Expectation{}
	}

	if mmGetInt64.defaultExpectation.params != nil {
		mmGetInt64.mock.t.Fatalf("ScanMock.GetInt64 mock is already set by Expect")
	}

	if mmGetInt64.defaultExpectation.paramPtrs == nil {
		mmGetInt64.defaultExpectation.paramPtrs = &ScanMockGetInt64ParamPtrs{}
	}
	mmGetInt64.defaultExpectation.paramPtrs.fieldName = &fieldName

	return mmGetInt64
}

// Inspect accepts an inspector function that has same arguments as the Scan.GetInt64
func (mmGetInt64 *mScanMockGetInt64) Inspect(f func(fieldName string)) *mScanMockGetInt64 {
	if mmGetInt64.mock.inspectFuncGetInt64 != nil {
		mmGetInt64.mock.t.Fatalf("Inspect function is already set for ScanMock.GetInt64")
	}

	mmGetInt64.mock.inspectFuncGetInt64 = f

	return mmGetInt64
}

// Return sets up results that will be returned by Scan.GetInt64
func (mmGetInt64 *mScanMockGetInt64) Return(i1 int64, err error) *ScanMock {
	if mmGetInt64.mock.funcGetInt64 != nil {
		mmGetInt64.mock.t.Fatalf("ScanMock.GetInt64 mock is already set by Set")
	}

	if mmGetInt64.defaultExpectation == nil {
		mmGetInt64.defaultExpectation = &ScanMockGetInt64Expectation{mock: mmGetInt64.mock}
	}
	mmGetInt64.defaultExpectation.results = &ScanMockGetInt64Results{i1, err}
	return mmGetInt64.mock
}

// Set uses given function f to mock the Scan.GetInt64 method
func (mmGetInt64 *mScanMockGetInt64) Set(f func(fieldName string) (i1 int64, err error)) *ScanMock {
	if mmGetInt64.defaultExpectation != nil {
		mmGetInt64.mock.t.Fatalf("Default expectation is already set for the Scan.GetInt64 method")
	}

	if len(mmGetInt64.expectations) > 0 {
		mmGetInt64.mock.t.Fatalf("Some expectations are already set for the Scan.GetInt64 method")
	}

	mmGetInt64.mock.funcGetInt64 = f
	return mmGetInt64.mock
}

// When sets expectation for the Scan.GetInt64 which will trigger the result defined by the following
// Then helper
func (mmGetInt64 *mScanMockGetInt64) When(fieldName string) *ScanMockGetInt64Expectation {
	if mmGetInt64.mock.funcGetInt64 != nil {
		mmGetInt64.mock.t.Fatalf("ScanMock.GetInt64 mock is already set by Set")
	}

	expectation := &ScanMockGetInt64Expectation{
		mock:   mmGetInt64.mock,
		params: &ScanMockGetInt64Params{fieldName},
	}
	mmGetInt64.expectations = append(mmGetInt64.expectations, expectation)
	return expectation
}

// Then sets up Scan.GetInt64 return parameters for the expectation previously defined by the When method
func (e *ScanMockGetInt64Expectation) Then(i1 int64, err error) *ScanMock {
	e.results = &ScanMockGetInt64Results{i1, err}
	return e.mock
}

// Times sets number of times Scan.GetInt64 should be invoked
func (mmGetInt64 *mScanMockGetInt64) Times(n uint64) *mScanMockGetInt64 {
	if n == 0 {
		mmGetInt64.mock.t.Fatalf("Times of ScanMock.GetInt64 mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetInt64.expectedInvocations, n)
	return mmGetInt64
}

func (mmGetInt64 *mScanMockGetInt64) invocationsDone() bool {
	if len(mmGetInt64.expectations) == 0 && mmGetInt64.defaultExpectation == nil && mmGetInt64.mock.funcGetInt64 == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetInt64.mock.afterGetInt64Counter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetInt64.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetInt64 implements Scan
func (mmGetInt64 *ScanMock) GetInt64(fieldName string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetInt64.beforeGetInt64Counter, 1)
	defer mm_atomic.AddUint64(&mmGetInt64.afterGetInt64Counter, 1)

	if mmGetInt64.inspectFuncGetInt64 != nil {
		mmGetInt64.inspectFuncGetInt64(fieldName)
	}

	mm_params := ScanMockGetInt64Params{fieldName}

	// Record call args
	mmGetInt64.GetInt64Mock.mutex.Lock()
	mmGetInt64.GetInt64Mock.callArgs = append(mmGetInt64.GetInt64Mock.callArgs, &mm_params)
	mmGetInt64.GetInt64Mock.mutex.Unlock()

	for _, e := range mmGetInt64.GetInt64Mock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetInt64.GetInt64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetInt64.GetInt64Mock.defaultExpectation.Counter, 1)
		mm_want := mmGetInt64.GetInt64Mock.defaultExpectation.params
		mm_want_ptrs := mmGetInt64.GetInt64Mock.defaultExpectation.paramPtrs

		mm_got := ScanMockGetInt64Params{fieldName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.fieldName != nil && !minimock.Equal(*mm_want_ptrs.fieldName, mm_got.fieldName) {
				mmGetInt64.t.Errorf("ScanMock.GetInt64 got unexpected parameter fieldName, want: %#v, got: %#v%s\n", *mm_want_ptrs.fieldName, mm_got.fieldName, minimock.Diff(*mm_want_ptrs.fieldName, mm_got.fieldName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetInt64.t.Errorf("ScanMock.GetInt64 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetInt64.GetInt64Mock.defaultExpectation.results
		if mm_results == nil {
			mmGetInt64.t.Fatal("No results are set for the ScanMock.GetInt64")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetInt64.funcGetInt64 != nil {
		return mmGetInt64.funcGetInt64(fieldName)
	}
	mmGetInt64.t.Fatalf("Unexpected call to ScanMock.GetInt64. %v", fieldName)
	return
}

// GetInt64AfterCounter returns a count of finished ScanMock.GetInt64 invocations
func (mmGetInt64 *ScanMock) GetInt64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInt64.afterGetInt64Counter)
}

// GetInt64BeforeCounter returns a count of ScanMock.GetInt64 invocations
func (mmGetInt64 *ScanMock) GetInt64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInt64.beforeGetInt64Counter)
}

// Calls returns a list of arguments used in each call to ScanMock.GetInt64.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetInt64 *mScanMockGetInt64) Calls() []*ScanMockGetInt64Params {
	mmGetInt64.mutex.RLock()

	argCopy := make([]*ScanMockGetInt64Params, len(mmGetInt64.callArgs))
	copy(argCopy, mmGetInt64.callArgs)

	mmGetInt64.mutex.RUnlock()

	return argCopy
}

// MinimockGetInt64Done returns true if the count of the GetInt64 invocations corresponds
// the number of defined expectations
func (m *ScanMock) MinimockGetInt64Done() bool {
	if m.GetInt64Mock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetInt64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetInt64Mock.invocationsDone()
}

// MinimockGetInt64Inspect logs each unmet expectation
func (m *ScanMock) MinimockGetInt64Inspect() {
	for _, e := range m.GetInt64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScanMock.GetInt64 with params: %#v", *e.params)
		}
	}

	afterGetInt64Counter := mm_atomic.LoadUint64(&m.afterGetInt64Counter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetInt64Mock.defaultExpectation != nil && afterGetInt64Counter < 1 {
		if m.GetInt64Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScanMock.GetInt64")
		} else {
			m.t.Errorf("Expected call to ScanMock.GetInt64 with params: %#v", *m.GetInt64Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetInt64 != nil && afterGetInt64Counter < 1 {
		m.t.Error("Expected call to ScanMock.GetInt64")
	}

	if !m.GetInt64Mock.invocationsDone() && afterGetInt64Counter > 0 {
		m.t.Errorf("Expected %d calls to ScanMock.GetInt64 but found %d calls",
			mm_atomic.LoadUint64(&m.GetInt64Mock.expectedInvocations), afterGetInt64Counter)
	}
}

type mScanMockGetInt8 struct {
	optional           bool
	mock               *ScanMock
	defaultExpectation *ScanMockGetInt8Expectation
	expectations       []*ScanMockGetInt8Expectation

	callArgs []*ScanMockGetInt8Params
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ScanMockGetInt8Expectation specifies expectation struct of the Scan.GetInt8
type ScanMockGetInt8Expectation struct {
	mock      *ScanMock
	params    *ScanMockGetInt8Params
	paramPtrs *ScanMockGetInt8ParamPtrs
	results   *ScanMockGetInt8Results
	Counter   uint64
}

// ScanMockGetInt8Params contains parameters of the Scan.GetInt8
type ScanMockGetInt8Params struct {
	fieldName string
}

// ScanMockGetInt8ParamPtrs contains pointers to parameters of the Scan.GetInt8
type ScanMockGetInt8ParamPtrs struct {
	fieldName *string
}

// ScanMockGetInt8Results contains results of the Scan.GetInt8
type ScanMockGetInt8Results struct {
	i1  int8
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetInt8 *mScanMockGetInt8) Optional() *mScanMockGetInt8 {
	mmGetInt8.optional = true
	return mmGetInt8
}

// Expect sets up expected params for Scan.GetInt8
func (mmGetInt8 *mScanMockGetInt8) Expect(fieldName string) *mScanMockGetInt8 {
	if mmGetInt8.mock.funcGetInt8 != nil {
		mmGetInt8.mock.t.Fatalf("ScanMock.GetInt8 mock is already set by Set")
	}

	if mmGetInt8.defaultExpectation == nil {
		mmGetInt8.defaultExpectation = &ScanMockGetInt8Expectation{}
	}

	if mmGetInt8.defaultExpectation.paramPtrs != nil {
		mmGetInt8.mock.t.Fatalf("ScanMock.GetInt8 mock is already set by ExpectParams functions")
	}

	mmGetInt8.defaultExpectation.params = &ScanMockGetInt8Params{fieldName}
	for _, e := range mmGetInt8.expectations {
		if minimock.Equal(e.params, mmGetInt8.defaultExpectation.params) {
			mmGetInt8.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetInt8.defaultExpectation.params)
		}
	}

	return mmGetInt8
}

// ExpectFieldNameParam1 sets up expected param fieldName for Scan.GetInt8
func (mmGetInt8 *mScanMockGetInt8) ExpectFieldNameParam1(fieldName string) *mScanMockGetInt8 {
	if mmGetInt8.mock.funcGetInt8 != nil {
		mmGetInt8.mock.t.Fatalf("ScanMock.GetInt8 mock is already set by Set")
	}

	if mmGetInt8.defaultExpectation == nil {
		mmGetInt8.defaultExpectation = &ScanMockGetInt8Expectation{}
	}

	if mmGetInt8.defaultExpectation.params != nil {
		mmGetInt8.mock.t.Fatalf("ScanMock.GetInt8 mock is already set by Expect")
	}

	if mmGetInt8.defaultExpectation.paramPtrs == nil {
		mmGetInt8.defaultExpectation.paramPtrs = &ScanMockGetInt8ParamPtrs{}
	}
	mmGetInt8.defaultExpectation.paramPtrs.fieldName = &fieldName

	return mmGetInt8
}

// Inspect accepts an inspector function that has same arguments as the Scan.GetInt8
func (mmGetInt8 *mScanMockGetInt8) Inspect(f func(fieldName string)) *mScanMockGetInt8 {
	if mmGetInt8.mock.inspectFuncGetInt8 != nil {
		mmGetInt8.mock.t.Fatalf("Inspect function is already set for ScanMock.GetInt8")
	}

	mmGetInt8.mock.inspectFuncGetInt8 = f

	return mmGetInt8
}

// Return sets up results that will be returned by Scan.GetInt8
func (mmGetInt8 *mScanMockGetInt8) Return(i1 int8, err error) *ScanMock {
	if mmGetInt8.mock.funcGetInt8 != nil {
		mmGetInt8.mock.t.Fatalf("ScanMock.GetInt8 mock is already set by Set")
	}

	if mmGetInt8.defaultExpectation == nil {
		mmGetInt8.defaultExpectation = &ScanMockGetInt8Expectation{mock: mmGetInt8.mock}
	}
	mmGetInt8.defaultExpectation.results = &ScanMockGetInt8Results{i1, err}
	return mmGetInt8.mock
}

// Set uses given function f to mock the Scan.GetInt8 method
func (mmGetInt8 *mScanMockGetInt8) Set(f func(fieldName string) (i1 int8, err error)) *ScanMock {
	if mmGetInt8.defaultExpectation != nil {
		mmGetInt8.mock.t.Fatalf("Default expectation is already set for the Scan.GetInt8 method")
	}

	if len(mmGetInt8.expectations) > 0 {
		mmGetInt8.mock.t.Fatalf("Some expectations are already set for the Scan.GetInt8 method")
	}

	mmGetInt8.mock.funcGetInt8 = f
	return mmGetInt8.mock
}

// When sets expectation for the Scan.GetInt8 which will trigger the result defined by the following
// Then helper
func (mmGetInt8 *mScanMockGetInt8) When(fieldName string) *ScanMockGetInt8Expectation {
	if mmGetInt8.mock.funcGetInt8 != nil {
		mmGetInt8.mock.t.Fatalf("ScanMock.GetInt8 mock is already set by Set")
	}

	expectation := &ScanMockGetInt8Expectation{
		mock:   mmGetInt8.mock,
		params: &ScanMockGetInt8Params{fieldName},
	}
	mmGetInt8.expectations = append(mmGetInt8.expectations, expectation)
	return expectation
}

// Then sets up Scan.GetInt8 return parameters for the expectation previously defined by the When method
func (e *ScanMockGetInt8Expectation) Then(i1 int8, err error) *ScanMock {
	e.results = &ScanMockGetInt8Results{i1, err}
	return e.mock
}

// Times sets number of times Scan.GetInt8 should be invoked
func (mmGetInt8 *mScanMockGetInt8) Times(n uint64) *mScanMockGetInt8 {
	if n == 0 {
		mmGetInt8.mock.t.Fatalf("Times of ScanMock.GetInt8 mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetInt8.expectedInvocations, n)
	return mmGetInt8
}

func (mmGetInt8 *mScanMockGetInt8) invocationsDone() bool {
	if len(mmGetInt8.expectations) == 0 && mmGetInt8.defaultExpectation == nil && mmGetInt8.mock.funcGetInt8 == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetInt8.mock.afterGetInt8Counter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetInt8.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetInt8 implements Scan
func (mmGetInt8 *ScanMock) GetInt8(fieldName string) (i1 int8, err error) {
	mm_atomic.AddUint64(&mmGetInt8.beforeGetInt8Counter, 1)
	defer mm_atomic.AddUint64(&mmGetInt8.afterGetInt8Counter, 1)

	if mmGetInt8.inspectFuncGetInt8 != nil {
		mmGetInt8.inspectFuncGetInt8(fieldName)
	}

	mm_params := ScanMockGetInt8Params{fieldName}

	// Record call args
	mmGetInt8.GetInt8Mock.mutex.Lock()
	mmGetInt8.GetInt8Mock.callArgs = append(mmGetInt8.GetInt8Mock.callArgs, &mm_params)
	mmGetInt8.GetInt8Mock.mutex.Unlock()

	for _, e := range mmGetInt8.GetInt8Mock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetInt8.GetInt8Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetInt8.GetInt8Mock.defaultExpectation.Counter, 1)
		mm_want := mmGetInt8.GetInt8Mock.defaultExpectation.params
		mm_want_ptrs := mmGetInt8.GetInt8Mock.defaultExpectation.paramPtrs

		mm_got := ScanMockGetInt8Params{fieldName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.fieldName != nil && !minimock.Equal(*mm_want_ptrs.fieldName, mm_got.fieldName) {
				mmGetInt8.t.Errorf("ScanMock.GetInt8 got unexpected parameter fieldName, want: %#v, got: %#v%s\n", *mm_want_ptrs.fieldName, mm_got.fieldName, minimock.Diff(*mm_want_ptrs.fieldName, mm_got.fieldName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetInt8.t.Errorf("ScanMock.GetInt8 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetInt8.GetInt8Mock.defaultExpectation.results
		if mm_results == nil {
			mmGetInt8.t.Fatal("No results are set for the ScanMock.GetInt8")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetInt8.funcGetInt8 != nil {
		return mmGetInt8.funcGetInt8(fieldName)
	}
	mmGetInt8.t.Fatalf("Unexpected call to ScanMock.GetInt8. %v", fieldName)
	return
}

// GetInt8AfterCounter returns a count of finished ScanMock.GetInt8 invocations
func (mmGetInt8 *ScanMock) GetInt8AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInt8.afterGetInt8Counter)
}

// GetInt8BeforeCounter returns a count of ScanMock.GetInt8 invocations
func (mmGetInt8 *ScanMock) GetInt8BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInt8.beforeGetInt8Counter)
}

// Calls returns a list of arguments used in each call to ScanMock.GetInt8.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetInt8 *mScanMockGetInt8) Calls() []*ScanMockGetInt8Params {
	mmGetInt8.mutex.RLock()

	argCopy := make([]*ScanMockGetInt8Params, len(mmGetInt8.callArgs))
	copy(argCopy, mmGetInt8.callArgs)

	mmGetInt8.mutex.RUnlock()

	return argCopy
}

// MinimockGetInt8Done returns true if the count of the GetInt8 invocations corresponds
// the number of defined expectations
func (m *ScanMock) MinimockGetInt8Done() bool {
	if m.GetInt8Mock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetInt8Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetInt8Mock.invocationsDone()
}

// MinimockGetInt8Inspect logs each unmet expectation
func (m *ScanMock) MinimockGetInt8Inspect() {
	for _, e := range m.GetInt8Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScanMock.GetInt8 with params: %#v", *e.params)
		}
	}

	afterGetInt8Counter := mm_atomic.LoadUint64(&m.afterGetInt8Counter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetInt8Mock.defaultExpectation != nil && afterGetInt8Counter < 1 {
		if m.GetInt8Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScanMock.GetInt8")
		} else {
			m.t.Errorf("Expected call to ScanMock.GetInt8 with params: %#v", *m.GetInt8Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetInt8 != nil && afterGetInt8Counter < 1 {
		m.t.Error("Expected call to ScanMock.GetInt8")
	}

	if !m.GetInt8Mock.invocationsDone() && afterGetInt8Counter > 0 {
		m.t.Errorf("Expected %d calls to ScanMock.GetInt8 but found %d calls",
			mm_atomic.LoadUint64(&m.GetInt8Mock.expectedInvocations), afterGetInt8Counter)
	}
}

type mScanMockGetString struct {
	optional           bool
	mock               *ScanMock
	defaultExpectation *ScanMockGetStringExpectation
	expectations       []*ScanMockGetStringExpectation

	callArgs []*ScanMockGetStringParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ScanMockGetStringExpectation specifies expectation struct of the Scan.GetString
type ScanMockGetStringExpectation struct {
	mock      *ScanMock
	params    *ScanMockGetStringParams
	paramPtrs *ScanMockGetStringParamPtrs
	results   *ScanMockGetStringResults
	Counter   uint64
}

// ScanMockGetStringParams contains parameters of the Scan.GetString
type ScanMockGetStringParams struct {
	fieldName string
}

// ScanMockGetStringParamPtrs contains pointers to parameters of the Scan.GetString
type ScanMockGetStringParamPtrs struct {
	fieldName *string
}

// ScanMockGetStringResults contains results of the Scan.GetString
type ScanMockGetStringResults struct {
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetString *mScanMockGetString) Optional() *mScanMockGetString {
	mmGetString.optional = true
	return mmGetString
}

// Expect sets up expected params for Scan.GetString
func (mmGetString *mScanMockGetString) Expect(fieldName string) *mScanMockGetString {
	if mmGetString.mock.funcGetString != nil {
		mmGetString.mock.t.Fatalf("ScanMock.GetString mock is already set by Set")
	}

	if mmGetString.defaultExpectation == nil {
		mmGetString.defaultExpectation = &ScanMockGetStringExpectation{}
	}

	if mmGetString.defaultExpectation.paramPtrs != nil {
		mmGetString.mock.t.Fatalf("ScanMock.GetString mock is already set by ExpectParams functions")
	}

	mmGetString.defaultExpectation.params = &ScanMockGetStringParams{fieldName}
	for _, e := range mmGetString.expectations {
		if minimock.Equal(e.params, mmGetString.defaultExpectation.params) {
			mmGetString.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetString.defaultExpectation.params)
		}
	}

	return mmGetString
}

// ExpectFieldNameParam1 sets up expected param fieldName for Scan.GetString
func (mmGetString *mScanMockGetString) ExpectFieldNameParam1(fieldName string) *mScanMockGetString {
	if mmGetString.mock.funcGetString != nil {
		mmGetString.mock.t.Fatalf("ScanMock.GetString mock is already set by Set")
	}

	if mmGetString.defaultExpectation == nil {
		mmGetString.defaultExpectation = &ScanMockGetStringExpectation{}
	}

	if mmGetString.defaultExpectation.params != nil {
		mmGetString.mock.t.Fatalf("ScanMock.GetString mock is already set by Expect")
	}

	if mmGetString.defaultExpectation.paramPtrs == nil {
		mmGetString.defaultExpectation.paramPtrs = &ScanMockGetStringParamPtrs{}
	}
	mmGetString.defaultExpectation.paramPtrs.fieldName = &fieldName

	return mmGetString
}

// Inspect accepts an inspector function that has same arguments as the Scan.GetString
func (mmGetString *mScanMockGetString) Inspect(f func(fieldName string)) *mScanMockGetString {
	if mmGetString.mock.inspectFuncGetString != nil {
		mmGetString.mock.t.Fatalf("Inspect function is already set for ScanMock.GetString")
	}

	mmGetString.mock.inspectFuncGetString = f

	return mmGetString
}

// Return sets up results that will be returned by Scan.GetString
func (mmGetString *mScanMockGetString) Return(s1 string, err error) *ScanMock {
	if mmGetString.mock.funcGetString != nil {
		mmGetString.mock.t.Fatalf("ScanMock.GetString mock is already set by Set")
	}

	if mmGetString.defaultExpectation == nil {
		mmGetString.defaultExpectation = &ScanMockGetStringExpectation{mock: mmGetString.mock}
	}
	mmGetString.defaultExpectation.results = &ScanMockGetStringResults{s1, err}
	return mmGetString.mock
}

// Set uses given function f to mock the Scan.GetString method
func (mmGetString *mScanMockGetString) Set(f func(fieldName string) (s1 string, err error)) *ScanMock {
	if mmGetString.defaultExpectation != nil {
		mmGetString.mock.t.Fatalf("Default expectation is already set for the Scan.GetString method")
	}

	if len(mmGetString.expectations) > 0 {
		mmGetString.mock.t.Fatalf("Some expectations are already set for the Scan.GetString method")
	}

	mmGetString.mock.funcGetString = f
	return mmGetString.mock
}

// When sets expectation for the Scan.GetString which will trigger the result defined by the following
// Then helper
func (mmGetString *mScanMockGetString) When(fieldName string) *ScanMockGetStringExpectation {
	if mmGetString.mock.funcGetString != nil {
		mmGetString.mock.t.Fatalf("ScanMock.GetString mock is already set by Set")
	}

	expectation := &ScanMockGetStringExpectation{
		mock:   mmGetString.mock,
		params: &ScanMockGetStringParams{fieldName},
	}
	mmGetString.expectations = append(mmGetString.expectations, expectation)
	return expectation
}

// Then sets up Scan.GetString return parameters for the expectation previously defined by the When method
func (e *ScanMockGetStringExpectation) Then(s1 string, err error) *ScanMock {
	e.results = &ScanMockGetStringResults{s1, err}
	return e.mock
}

// Times sets number of times Scan.GetString should be invoked
func (mmGetString *mScanMockGetString) Times(n uint64) *mScanMockGetString {
	if n == 0 {
		mmGetString.mock.t.Fatalf("Times of ScanMock.GetString mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetString.expectedInvocations, n)
	return mmGetString
}

func (mmGetString *mScanMockGetString) invocationsDone() bool {
	if len(mmGetString.expectations) == 0 && mmGetString.defaultExpectation == nil && mmGetString.mock.funcGetString == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetString.mock.afterGetStringCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetString.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetString implements Scan
func (mmGetString *ScanMock) GetString(fieldName string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetString.beforeGetStringCounter, 1)
	defer mm_atomic.AddUint64(&mmGetString.afterGetStringCounter, 1)

	if mmGetString.inspectFuncGetString != nil {
		mmGetString.inspectFuncGetString(fieldName)
	}

	mm_params := ScanMockGetStringParams{fieldName}

	// Record call args
	mmGetString.GetStringMock.mutex.Lock()
	mmGetString.GetStringMock.callArgs = append(mmGetString.GetStringMock.callArgs, &mm_params)
	mmGetString.GetStringMock.mutex.Unlock()

	for _, e := range mmGetString.GetStringMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetString.GetStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetString.GetStringMock.defaultExpectation.Counter, 1)
		mm_want := mmGetString.GetStringMock.defaultExpectation.params
		mm_want_ptrs := mmGetString.GetStringMock.defaultExpectation.paramPtrs

		mm_got := ScanMockGetStringParams{fieldName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.fieldName != nil && !minimock.Equal(*mm_want_ptrs.fieldName, mm_got.fieldName) {
				mmGetString.t.Errorf("ScanMock.GetString got unexpected parameter fieldName, want: %#v, got: %#v%s\n", *mm_want_ptrs.fieldName, mm_got.fieldName, minimock.Diff(*mm_want_ptrs.fieldName, mm_got.fieldName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetString.t.Errorf("ScanMock.GetString got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetString.GetStringMock.defaultExpectation.results
		if mm_results == nil {
			mmGetString.t.Fatal("No results are set for the ScanMock.GetString")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetString.funcGetString != nil {
		return mmGetString.funcGetString(fieldName)
	}
	mmGetString.t.Fatalf("Unexpected call to ScanMock.GetString. %v", fieldName)
	return
}

// GetStringAfterCounter returns a count of finished ScanMock.GetString invocations
func (mmGetString *ScanMock) GetStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetString.afterGetStringCounter)
}

// GetStringBeforeCounter returns a count of ScanMock.GetString invocations
func (mmGetString *ScanMock) GetStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetString.beforeGetStringCounter)
}

// Calls returns a list of arguments used in each call to ScanMock.GetString.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetString *mScanMockGetString) Calls() []*ScanMockGetStringParams {
	mmGetString.mutex.RLock()

	argCopy := make([]*ScanMockGetStringParams, len(mmGetString.callArgs))
	copy(argCopy, mmGetString.callArgs)

	mmGetString.mutex.RUnlock()

	return argCopy
}

// MinimockGetStringDone returns true if the count of the GetString invocations corresponds
// the number of defined expectations
func (m *ScanMock) MinimockGetStringDone() bool {
	if m.GetStringMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetStringMock.invocationsDone()
}

// MinimockGetStringInspect logs each unmet expectation
func (m *ScanMock) MinimockGetStringInspect() {
	for _, e := range m.GetStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScanMock.GetString with params: %#v", *e.params)
		}
	}

	afterGetStringCounter := mm_atomic.LoadUint64(&m.afterGetStringCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetStringMock.defaultExpectation != nil && afterGetStringCounter < 1 {
		if m.GetStringMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScanMock.GetString")
		} else {
			m.t.Errorf("Expected call to ScanMock.GetString with params: %#v", *m.GetStringMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetString != nil && afterGetStringCounter < 1 {
		m.t.Error("Expected call to ScanMock.GetString")
	}

	if !m.GetStringMock.invocationsDone() && afterGetStringCounter > 0 {
		m.t.Errorf("Expected %d calls to ScanMock.GetString but found %d calls",
			mm_atomic.LoadUint64(&m.GetStringMock.expectedInvocations), afterGetStringCounter)
	}
}

type mScanMockGetVal struct {
	optional           bool
	mock               *ScanMock
	defaultExpectation *ScanMockGetValExpectation
	expectations       []*ScanMockGetValExpectation

	callArgs []*ScanMockGetValParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ScanMockGetValExpectation specifies expectation struct of the Scan.GetVal
type ScanMockGetValExpectation struct {
	mock      *ScanMock
	params    *ScanMockGetValParams
	paramPtrs *ScanMockGetValParamPtrs
	results   *ScanMockGetValResults
	Counter   uint64
}

// ScanMockGetValParams contains parameters of the Scan.GetVal
type ScanMockGetValParams struct {
	fieldName string
}

// ScanMockGetValParamPtrs contains pointers to parameters of the Scan.GetVal
type ScanMockGetValParamPtrs struct {
	fieldName *string
}

// ScanMockGetValResults contains results of the Scan.GetVal
type ScanMockGetValResults struct {
	c1  Constant
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetVal *mScanMockGetVal) Optional() *mScanMockGetVal {
	mmGetVal.optional = true
	return mmGetVal
}

// Expect sets up expected params for Scan.GetVal
func (mmGetVal *mScanMockGetVal) Expect(fieldName string) *mScanMockGetVal {
	if mmGetVal.mock.funcGetVal != nil {
		mmGetVal.mock.t.Fatalf("ScanMock.GetVal mock is already set by Set")
	}

	if mmGetVal.defaultExpectation == nil {
		mmGetVal.defaultExpectation = &ScanMockGetValExpectation{}
	}

	if mmGetVal.defaultExpectation.paramPtrs != nil {
		mmGetVal.mock.t.Fatalf("ScanMock.GetVal mock is already set by ExpectParams functions")
	}

	mmGetVal.defaultExpectation.params = &ScanMockGetValParams{fieldName}
	for _, e := range mmGetVal.expectations {
		if minimock.Equal(e.params, mmGetVal.defaultExpectation.params) {
			mmGetVal.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetVal.defaultExpectation.params)
		}
	}

	return mmGetVal
}

// ExpectFieldNameParam1 sets up expected param fieldName for Scan.GetVal
func (mmGetVal *mScanMockGetVal) ExpectFieldNameParam1(fieldName string) *mScanMockGetVal {
	if mmGetVal.mock.funcGetVal != nil {
		mmGetVal.mock.t.Fatalf("ScanMock.GetVal mock is already set by Set")
	}

	if mmGetVal.defaultExpectation == nil {
		mmGetVal.defaultExpectation = &ScanMockGetValExpectation{}
	}

	if mmGetVal.defaultExpectation.params != nil {
		mmGetVal.mock.t.Fatalf("ScanMock.GetVal mock is already set by Expect")
	}

	if mmGetVal.defaultExpectation.paramPtrs == nil {
		mmGetVal.defaultExpectation.paramPtrs = &ScanMockGetValParamPtrs{}
	}
	mmGetVal.defaultExpectation.paramPtrs.fieldName = &fieldName

	return mmGetVal
}

// Inspect accepts an inspector function that has same arguments as the Scan.GetVal
func (mmGetVal *mScanMockGetVal) Inspect(f func(fieldName string)) *mScanMockGetVal {
	if mmGetVal.mock.inspectFuncGetVal != nil {
		mmGetVal.mock.t.Fatalf("Inspect function is already set for ScanMock.GetVal")
	}

	mmGetVal.mock.inspectFuncGetVal = f

	return mmGetVal
}

// Return sets up results that will be returned by Scan.GetVal
func (mmGetVal *mScanMockGetVal) Return(c1 Constant, err error) *ScanMock {
	if mmGetVal.mock.funcGetVal != nil {
		mmGetVal.mock.t.Fatalf("ScanMock.GetVal mock is already set by Set")
	}

	if mmGetVal.defaultExpectation == nil {
		mmGetVal.defaultExpectation = &ScanMockGetValExpectation{mock: mmGetVal.mock}
	}
	mmGetVal.defaultExpectation.results = &ScanMockGetValResults{c1, err}
	return mmGetVal.mock
}

// Set uses given function f to mock the Scan.GetVal method
func (mmGetVal *mScanMockGetVal) Set(f func(fieldName string) (c1 Constant, err error)) *ScanMock {
	if mmGetVal.defaultExpectation != nil {
		mmGetVal.mock.t.Fatalf("Default expectation is already set for the Scan.GetVal method")
	}

	if len(mmGetVal.expectations) > 0 {
		mmGetVal.mock.t.Fatalf("Some expectations are already set for the Scan.GetVal method")
	}

	mmGetVal.mock.funcGetVal = f
	return mmGetVal.mock
}

// When sets expectation for the Scan.GetVal which will trigger the result defined by the following
// Then helper
func (mmGetVal *mScanMockGetVal) When(fieldName string) *ScanMockGetValExpectation {
	if mmGetVal.mock.funcGetVal != nil {
		mmGetVal.mock.t.Fatalf("ScanMock.GetVal mock is already set by Set")
	}

	expectation := &ScanMockGetValExpectation{
		mock:   mmGetVal.mock,
		params: &ScanMockGetValParams{fieldName},
	}
	mmGetVal.expectations = append(mmGetVal.expectations, expectation)
	return expectation
}

// Then sets up Scan.GetVal return parameters for the expectation previously defined by the When method
func (e *ScanMockGetValExpectation) Then(c1 Constant, err error) *ScanMock {
	e.results = &ScanMockGetValResults{c1, err}
	return e.mock
}

// Times sets number of times Scan.GetVal should be invoked
func (mmGetVal *mScanMockGetVal) Times(n uint64) *mScanMockGetVal {
	if n == 0 {
		mmGetVal.mock.t.Fatalf("Times of ScanMock.GetVal mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetVal.expectedInvocations, n)
	return mmGetVal
}

func (mmGetVal *mScanMockGetVal) invocationsDone() bool {
	if len(mmGetVal.expectations) == 0 && mmGetVal.defaultExpectation == nil && mmGetVal.mock.funcGetVal == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetVal.mock.afterGetValCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetVal.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetVal implements Scan
func (mmGetVal *ScanMock) GetVal(fieldName string) (c1 Constant, err error) {
	mm_atomic.AddUint64(&mmGetVal.beforeGetValCounter, 1)
	defer mm_atomic.AddUint64(&mmGetVal.afterGetValCounter, 1)

	if mmGetVal.inspectFuncGetVal != nil {
		mmGetVal.inspectFuncGetVal(fieldName)
	}

	mm_params := ScanMockGetValParams{fieldName}

	// Record call args
	mmGetVal.GetValMock.mutex.Lock()
	mmGetVal.GetValMock.callArgs = append(mmGetVal.GetValMock.callArgs, &mm_params)
	mmGetVal.GetValMock.mutex.Unlock()

	for _, e := range mmGetVal.GetValMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c1, e.results.err
		}
	}

	if mmGetVal.GetValMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetVal.GetValMock.defaultExpectation.Counter, 1)
		mm_want := mmGetVal.GetValMock.defaultExpectation.params
		mm_want_ptrs := mmGetVal.GetValMock.defaultExpectation.paramPtrs

		mm_got := ScanMockGetValParams{fieldName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.fieldName != nil && !minimock.Equal(*mm_want_ptrs.fieldName, mm_got.fieldName) {
				mmGetVal.t.Errorf("ScanMock.GetVal got unexpected parameter fieldName, want: %#v, got: %#v%s\n", *mm_want_ptrs.fieldName, mm_got.fieldName, minimock.Diff(*mm_want_ptrs.fieldName, mm_got.fieldName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetVal.t.Errorf("ScanMock.GetVal got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetVal.GetValMock.defaultExpectation.results
		if mm_results == nil {
			mmGetVal.t.Fatal("No results are set for the ScanMock.GetVal")
		}
		return (*mm_results).c1, (*mm_results).err
	}
	if mmGetVal.funcGetVal != nil {
		return mmGetVal.funcGetVal(fieldName)
	}
	mmGetVal.t.Fatalf("Unexpected call to ScanMock.GetVal. %v", fieldName)
	return
}

// GetValAfterCounter returns a count of finished ScanMock.GetVal invocations
func (mmGetVal *ScanMock) GetValAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetVal.afterGetValCounter)
}

// GetValBeforeCounter returns a count of ScanMock.GetVal invocations
func (mmGetVal *ScanMock) GetValBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetVal.beforeGetValCounter)
}

// Calls returns a list of arguments used in each call to ScanMock.GetVal.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetVal *mScanMockGetVal) Calls() []*ScanMockGetValParams {
	mmGetVal.mutex.RLock()

	argCopy := make([]*ScanMockGetValParams, len(mmGetVal.callArgs))
	copy(argCopy, mmGetVal.callArgs)

	mmGetVal.mutex.RUnlock()

	return argCopy
}

// MinimockGetValDone returns true if the count of the GetVal invocations corresponds
// the number of defined expectations
func (m *ScanMock) MinimockGetValDone() bool {
	if m.GetValMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetValMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetValMock.invocationsDone()
}

// MinimockGetValInspect logs each unmet expectation
func (m *ScanMock) MinimockGetValInspect() {
	for _, e := range m.GetValMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScanMock.GetVal with params: %#v", *e.params)
		}
	}

	afterGetValCounter := mm_atomic.LoadUint64(&m.afterGetValCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetValMock.defaultExpectation != nil && afterGetValCounter < 1 {
		if m.GetValMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScanMock.GetVal")
		} else {
			m.t.Errorf("Expected call to ScanMock.GetVal with params: %#v", *m.GetValMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetVal != nil && afterGetValCounter < 1 {
		m.t.Error("Expected call to ScanMock.GetVal")
	}

	if !m.GetValMock.invocationsDone() && afterGetValCounter > 0 {
		m.t.Errorf("Expected %d calls to ScanMock.GetVal but found %d calls",
			mm_atomic.LoadUint64(&m.GetValMock.expectedInvocations), afterGetValCounter)
	}
}

type mScanMockHasField struct {
	optional           bool
	mock               *ScanMock
	defaultExpectation *ScanMockHasFieldExpectation
	expectations       []*ScanMockHasFieldExpectation

	callArgs []*ScanMockHasFieldParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ScanMockHasFieldExpectation specifies expectation struct of the Scan.HasField
type ScanMockHasFieldExpectation struct {
	mock      *ScanMock
	params    *ScanMockHasFieldParams
	paramPtrs *ScanMockHasFieldParamPtrs
	results   *ScanMockHasFieldResults
	Counter   uint64
}

// ScanMockHasFieldParams contains parameters of the Scan.HasField
type ScanMockHasFieldParams struct {
	fieldName string
}

// ScanMockHasFieldParamPtrs contains pointers to parameters of the Scan.HasField
type ScanMockHasFieldParamPtrs struct {
	fieldName *string
}

// ScanMockHasFieldResults contains results of the Scan.HasField
type ScanMockHasFieldResults struct {
	b1 bool
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHasField *mScanMockHasField) Optional() *mScanMockHasField {
	mmHasField.optional = true
	return mmHasField
}

// Expect sets up expected params for Scan.HasField
func (mmHasField *mScanMockHasField) Expect(fieldName string) *mScanMockHasField {
	if mmHasField.mock.funcHasField != nil {
		mmHasField.mock.t.Fatalf("ScanMock.HasField mock is already set by Set")
	}

	if mmHasField.defaultExpectation == nil {
		mmHasField.defaultExpectation = &ScanMockHasFieldExpectation{}
	}

	if mmHasField.defaultExpectation.paramPtrs != nil {
		mmHasField.mock.t.Fatalf("ScanMock.HasField mock is already set by ExpectParams functions")
	}

	mmHasField.defaultExpectation.params = &ScanMockHasFieldParams{fieldName}
	for _, e := range mmHasField.expectations {
		if minimock.Equal(e.params, mmHasField.defaultExpectation.params) {
			mmHasField.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHasField.defaultExpectation.params)
		}
	}

	return mmHasField
}

// ExpectFieldNameParam1 sets up expected param fieldName for Scan.HasField
func (mmHasField *mScanMockHasField) ExpectFieldNameParam1(fieldName string) *mScanMockHasField {
	if mmHasField.mock.funcHasField != nil {
		mmHasField.mock.t.Fatalf("ScanMock.HasField mock is already set by Set")
	}

	if mmHasField.defaultExpectation == nil {
		mmHasField.defaultExpectation = &ScanMockHasFieldExpectation{}
	}

	if mmHasField.defaultExpectation.params != nil {
		mmHasField.mock.t.Fatalf("ScanMock.HasField mock is already set by Expect")
	}

	if mmHasField.defaultExpectation.paramPtrs == nil {
		mmHasField.defaultExpectation.paramPtrs = &ScanMockHasFieldParamPtrs{}
	}
	mmHasField.defaultExpectation.paramPtrs.fieldName = &fieldName

	return mmHasField
}

// Inspect accepts an inspector function that has same arguments as the Scan.HasField
func (mmHasField *mScanMockHasField) Inspect(f func(fieldName string)) *mScanMockHasField {
	if mmHasField.mock.inspectFuncHasField != nil {
		mmHasField.mock.t.Fatalf("Inspect function is already set for ScanMock.HasField")
	}

	mmHasField.mock.inspectFuncHasField = f

	return mmHasField
}

// Return sets up results that will be returned by Scan.HasField
func (mmHasField *mScanMockHasField) Return(b1 bool) *ScanMock {
	if mmHasField.mock.funcHasField != nil {
		mmHasField.mock.t.Fatalf("ScanMock.HasField mock is already set by Set")
	}

	if mmHasField.defaultExpectation == nil {
		mmHasField.defaultExpectation = &ScanMockHasFieldExpectation{mock: mmHasField.mock}
	}
	mmHasField.defaultExpectation.results = &ScanMockHasFieldResults{b1}
	return mmHasField.mock
}

// Set uses given function f to mock the Scan.HasField method
func (mmHasField *mScanMockHasField) Set(f func(fieldName string) (b1 bool)) *ScanMock {
	if mmHasField.defaultExpectation != nil {
		mmHasField.mock.t.Fatalf("Default expectation is already set for the Scan.HasField method")
	}

	if len(mmHasField.expectations) > 0 {
		mmHasField.mock.t.Fatalf("Some expectations are already set for the Scan.HasField method")
	}

	mmHasField.mock.funcHasField = f
	return mmHasField.mock
}

// When sets expectation for the Scan.HasField which will trigger the result defined by the following
// Then helper
func (mmHasField *mScanMockHasField) When(fieldName string) *ScanMockHasFieldExpectation {
	if mmHasField.mock.funcHasField != nil {
		mmHasField.mock.t.Fatalf("ScanMock.HasField mock is already set by Set")
	}

	expectation := &ScanMockHasFieldExpectation{
		mock:   mmHasField.mock,
		params: &ScanMockHasFieldParams{fieldName},
	}
	mmHasField.expectations = append(mmHasField.expectations, expectation)
	return expectation
}

// Then sets up Scan.HasField return parameters for the expectation previously defined by the When method
func (e *ScanMockHasFieldExpectation) Then(b1 bool) *ScanMock {
	e.results = &ScanMockHasFieldResults{b1}
	return e.mock
}

// Times sets number of times Scan.HasField should be invoked
func (mmHasField *mScanMockHasField) Times(n uint64) *mScanMockHasField {
	if n == 0 {
		mmHasField.mock.t.Fatalf("Times of ScanMock.HasField mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHasField.expectedInvocations, n)
	return mmHasField
}

func (mmHasField *mScanMockHasField) invocationsDone() bool {
	if len(mmHasField.expectations) == 0 && mmHasField.defaultExpectation == nil && mmHasField.mock.funcHasField == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHasField.mock.afterHasFieldCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHasField.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HasField implements Scan
func (mmHasField *ScanMock) HasField(fieldName string) (b1 bool) {
	mm_atomic.AddUint64(&mmHasField.beforeHasFieldCounter, 1)
	defer mm_atomic.AddUint64(&mmHasField.afterHasFieldCounter, 1)

	if mmHasField.inspectFuncHasField != nil {
		mmHasField.inspectFuncHasField(fieldName)
	}

	mm_params := ScanMockHasFieldParams{fieldName}

	// Record call args
	mmHasField.HasFieldMock.mutex.Lock()
	mmHasField.HasFieldMock.callArgs = append(mmHasField.HasFieldMock.callArgs, &mm_params)
	mmHasField.HasFieldMock.mutex.Unlock()

	for _, e := range mmHasField.HasFieldMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmHasField.HasFieldMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHasField.HasFieldMock.defaultExpectation.Counter, 1)
		mm_want := mmHasField.HasFieldMock.defaultExpectation.params
		mm_want_ptrs := mmHasField.HasFieldMock.defaultExpectation.paramPtrs

		mm_got := ScanMockHasFieldParams{fieldName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.fieldName != nil && !minimock.Equal(*mm_want_ptrs.fieldName, mm_got.fieldName) {
				mmHasField.t.Errorf("ScanMock.HasField got unexpected parameter fieldName, want: %#v, got: %#v%s\n", *mm_want_ptrs.fieldName, mm_got.fieldName, minimock.Diff(*mm_want_ptrs.fieldName, mm_got.fieldName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHasField.t.Errorf("ScanMock.HasField got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHasField.HasFieldMock.defaultExpectation.results
		if mm_results == nil {
			mmHasField.t.Fatal("No results are set for the ScanMock.HasField")
		}
		return (*mm_results).b1
	}
	if mmHasField.funcHasField != nil {
		return mmHasField.funcHasField(fieldName)
	}
	mmHasField.t.Fatalf("Unexpected call to ScanMock.HasField. %v", fieldName)
	return
}

// HasFieldAfterCounter returns a count of finished ScanMock.HasField invocations
func (mmHasField *ScanMock) HasFieldAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasField.afterHasFieldCounter)
}

// HasFieldBeforeCounter returns a count of ScanMock.HasField invocations
func (mmHasField *ScanMock) HasFieldBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasField.beforeHasFieldCounter)
}

// Calls returns a list of arguments used in each call to ScanMock.HasField.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHasField *mScanMockHasField) Calls() []*ScanMockHasFieldParams {
	mmHasField.mutex.RLock()

	argCopy := make([]*ScanMockHasFieldParams, len(mmHasField.callArgs))
	copy(argCopy, mmHasField.callArgs)

	mmHasField.mutex.RUnlock()

	return argCopy
}

// MinimockHasFieldDone returns true if the count of the HasField invocations corresponds
// the number of defined expectations
func (m *ScanMock) MinimockHasFieldDone() bool {
	if m.HasFieldMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HasFieldMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HasFieldMock.invocationsDone()
}

// MinimockHasFieldInspect logs each unmet expectation
func (m *ScanMock) MinimockHasFieldInspect() {
	for _, e := range m.HasFieldMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScanMock.HasField with params: %#v", *e.params)
		}
	}

	afterHasFieldCounter := mm_atomic.LoadUint64(&m.afterHasFieldCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HasFieldMock.defaultExpectation != nil && afterHasFieldCounter < 1 {
		if m.HasFieldMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScanMock.HasField")
		} else {
			m.t.Errorf("Expected call to ScanMock.HasField with params: %#v", *m.HasFieldMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasField != nil && afterHasFieldCounter < 1 {
		m.t.Error("Expected call to ScanMock.HasField")
	}

	if !m.HasFieldMock.invocationsDone() && afterHasFieldCounter > 0 {
		m.t.Errorf("Expected %d calls to ScanMock.HasField but found %d calls",
			mm_atomic.LoadUint64(&m.HasFieldMock.expectedInvocations), afterHasFieldCounter)
	}
}

type mScanMockNext struct {
	optional           bool
	mock               *ScanMock
	defaultExpectation *ScanMockNextExpectation
	expectations       []*ScanMockNextExpectation

	expectedInvocations uint64
}

// ScanMockNextExpectation specifies expectation struct of the Scan.Next
type ScanMockNextExpectation struct {
	mock *ScanMock

	results *ScanMockNextResults
	Counter uint64
}

// ScanMockNextResults contains results of the Scan.Next
type ScanMockNextResults struct {
	b1  bool
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmNext *mScanMockNext) Optional() *mScanMockNext {
	mmNext.optional = true
	return mmNext
}

// Expect sets up expected params for Scan.Next
func (mmNext *mScanMockNext) Expect() *mScanMockNext {
	if mmNext.mock.funcNext != nil {
		mmNext.mock.t.Fatalf("ScanMock.Next mock is already set by Set")
	}

	if mmNext.defaultExpectation == nil {
		mmNext.defaultExpectation = &ScanMockNextExpectation{}
	}

	return mmNext
}

// Inspect accepts an inspector function that has same arguments as the Scan.Next
func (mmNext *mScanMockNext) Inspect(f func()) *mScanMockNext {
	if mmNext.mock.inspectFuncNext != nil {
		mmNext.mock.t.Fatalf("Inspect function is already set for ScanMock.Next")
	}

	mmNext.mock.inspectFuncNext = f

	return mmNext
}

// Return sets up results that will be returned by Scan.Next
func (mmNext *mScanMockNext) Return(b1 bool, err error) *ScanMock {
	if mmNext.mock.funcNext != nil {
		mmNext.mock.t.Fatalf("ScanMock.Next mock is already set by Set")
	}

	if mmNext.defaultExpectation == nil {
		mmNext.defaultExpectation = &ScanMockNextExpectation{mock: mmNext.mock}
	}
	mmNext.defaultExpectation.results = &ScanMockNextResults{b1, err}
	return mmNext.mock
}

// Set uses given function f to mock the Scan.Next method
func (mmNext *mScanMockNext) Set(f func() (b1 bool, err error)) *ScanMock {
	if mmNext.defaultExpectation != nil {
		mmNext.mock.t.Fatalf("Default expectation is already set for the Scan.Next method")
	}

	if len(mmNext.expectations) > 0 {
		mmNext.mock.t.Fatalf("Some expectations are already set for the Scan.Next method")
	}

	mmNext.mock.funcNext = f
	return mmNext.mock
}

// Times sets number of times Scan.Next should be invoked
func (mmNext *mScanMockNext) Times(n uint64) *mScanMockNext {
	if n == 0 {
		mmNext.mock.t.Fatalf("Times of ScanMock.Next mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmNext.expectedInvocations, n)
	return mmNext
}

func (mmNext *mScanMockNext) invocationsDone() bool {
	if len(mmNext.expectations) == 0 && mmNext.defaultExpectation == nil && mmNext.mock.funcNext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmNext.mock.afterNextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmNext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Next implements Scan
func (mmNext *ScanMock) Next() (b1 bool, err error) {
	mm_atomic.AddUint64(&mmNext.beforeNextCounter, 1)
	defer mm_atomic.AddUint64(&mmNext.afterNextCounter, 1)

	if mmNext.inspectFuncNext != nil {
		mmNext.inspectFuncNext()
	}

	if mmNext.NextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNext.NextMock.defaultExpectation.Counter, 1)

		mm_results := mmNext.NextMock.defaultExpectation.results
		if mm_results == nil {
			mmNext.t.Fatal("No results are set for the ScanMock.Next")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmNext.funcNext != nil {
		return mmNext.funcNext()
	}
	mmNext.t.Fatalf("Unexpected call to ScanMock.Next.")
	return
}

// NextAfterCounter returns a count of finished ScanMock.Next invocations
func (mmNext *ScanMock) NextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNext.afterNextCounter)
}

// NextBeforeCounter returns a count of ScanMock.Next invocations
func (mmNext *ScanMock) NextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNext.beforeNextCounter)
}

// MinimockNextDone returns true if the count of the Next invocations corresponds
// the number of defined expectations
func (m *ScanMock) MinimockNextDone() bool {
	if m.NextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NextMock.invocationsDone()
}

// MinimockNextInspect logs each unmet expectation
func (m *ScanMock) MinimockNextInspect() {
	for _, e := range m.NextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScanMock.Next")
		}
	}

	afterNextCounter := mm_atomic.LoadUint64(&m.afterNextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NextMock.defaultExpectation != nil && afterNextCounter < 1 {
		m.t.Error("Expected call to ScanMock.Next")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNext != nil && afterNextCounter < 1 {
		m.t.Error("Expected call to ScanMock.Next")
	}

	if !m.NextMock.invocationsDone() && afterNextCounter > 0 {
		m.t.Errorf("Expected %d calls to ScanMock.Next but found %d calls",
			mm_atomic.LoadUint64(&m.NextMock.expectedInvocations), afterNextCounter)
	}
}

type mScanMockSchema struct {
	optional           bool
	mock               *ScanMock
	defaultExpectation *ScanMockSchemaExpectation
	expectations       []*ScanMockSchemaExpectation

	expectedInvocations uint64
}

// ScanMockSchemaExpectation specifies expectation struct of the Scan.Schema
type ScanMockSchemaExpectation struct {
	mock *ScanMock

	results *ScanMockSchemaResults
	Counter uint64
}

// ScanMockSchemaResults contains results of the Scan.Schema
type ScanMockSchemaResults struct {
	s1 records.Schema
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSchema *mScanMockSchema) Optional() *mScanMockSchema {
	mmSchema.optional = true
	return mmSchema
}

// Expect sets up expected params for Scan.Schema
func (mmSchema *mScanMockSchema) Expect() *mScanMockSchema {
	if mmSchema.mock.funcSchema != nil {
		mmSchema.mock.t.Fatalf("ScanMock.Schema mock is already set by Set")
	}

	if mmSchema.defaultExpectation == nil {
		mmSchema.defaultExpectation = &ScanMockSchemaExpectation{}
	}

	return mmSchema
}

// Inspect accepts an inspector function that has same arguments as the Scan.Schema
func (mmSchema *mScanMockSchema) Inspect(f func()) *mScanMockSchema {
	if mmSchema.mock.inspectFuncSchema != nil {
		mmSchema.mock.t.Fatalf("Inspect function is already set for ScanMock.Schema")
	}

	mmSchema.mock.inspectFuncSchema = f

	return mmSchema
}

// Return sets up results that will be returned by Scan.Schema
func (mmSchema *mScanMockSchema) Return(s1 records.Schema) *ScanMock {
	if mmSchema.mock.funcSchema != nil {
		mmSchema.mock.t.Fatalf("ScanMock.Schema mock is already set by Set")
	}

	if mmSchema.defaultExpectation == nil {
		mmSchema.defaultExpectation = &ScanMockSchemaExpectation{mock: mmSchema.mock}
	}
	mmSchema.defaultExpectation.results = &ScanMockSchemaResults{s1}
	return mmSchema.mock
}

// Set uses given function f to mock the Scan.Schema method
func (mmSchema *mScanMockSchema) Set(f func() (s1 records.Schema)) *ScanMock {
	if mmSchema.defaultExpectation != nil {
		mmSchema.mock.t.Fatalf("Default expectation is already set for the Scan.Schema method")
	}

	if len(mmSchema.expectations) > 0 {
		mmSchema.mock.t.Fatalf("Some expectations are already set for the Scan.Schema method")
	}

	mmSchema.mock.funcSchema = f
	return mmSchema.mock
}

// Times sets number of times Scan.Schema should be invoked
func (mmSchema *mScanMockSchema) Times(n uint64) *mScanMockSchema {
	if n == 0 {
		mmSchema.mock.t.Fatalf("Times of ScanMock.Schema mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSchema.expectedInvocations, n)
	return mmSchema
}

func (mmSchema *mScanMockSchema) invocationsDone() bool {
	if len(mmSchema.expectations) == 0 && mmSchema.defaultExpectation == nil && mmSchema.mock.funcSchema == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSchema.mock.afterSchemaCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSchema.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Schema implements Scan
func (mmSchema *ScanMock) Schema() (s1 records.Schema) {
	mm_atomic.AddUint64(&mmSchema.beforeSchemaCounter, 1)
	defer mm_atomic.AddUint64(&mmSchema.afterSchemaCounter, 1)

	if mmSchema.inspectFuncSchema != nil {
		mmSchema.inspectFuncSchema()
	}

	if mmSchema.SchemaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSchema.SchemaMock.defaultExpectation.Counter, 1)

		mm_results := mmSchema.SchemaMock.defaultExpectation.results
		if mm_results == nil {
			mmSchema.t.Fatal("No results are set for the ScanMock.Schema")
		}
		return (*mm_results).s1
	}
	if mmSchema.funcSchema != nil {
		return mmSchema.funcSchema()
	}
	mmSchema.t.Fatalf("Unexpected call to ScanMock.Schema.")
	return
}

// SchemaAfterCounter returns a count of finished ScanMock.Schema invocations
func (mmSchema *ScanMock) SchemaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSchema.afterSchemaCounter)
}

// SchemaBeforeCounter returns a count of ScanMock.Schema invocations
func (mmSchema *ScanMock) SchemaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSchema.beforeSchemaCounter)
}

// MinimockSchemaDone returns true if the count of the Schema invocations corresponds
// the number of defined expectations
func (m *ScanMock) MinimockSchemaDone() bool {
	if m.SchemaMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SchemaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SchemaMock.invocationsDone()
}

// MinimockSchemaInspect logs each unmet expectation
func (m *ScanMock) MinimockSchemaInspect() {
	for _, e := range m.SchemaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScanMock.Schema")
		}
	}

	afterSchemaCounter := mm_atomic.LoadUint64(&m.afterSchemaCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SchemaMock.defaultExpectation != nil && afterSchemaCounter < 1 {
		m.t.Error("Expected call to ScanMock.Schema")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSchema != nil && afterSchemaCounter < 1 {
		m.t.Error("Expected call to ScanMock.Schema")
	}

	if !m.SchemaMock.invocationsDone() && afterSchemaCounter > 0 {
		m.t.Errorf("Expected %d calls to ScanMock.Schema but found %d calls",
			mm_atomic.LoadUint64(&m.SchemaMock.expectedInvocations), afterSchemaCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ScanMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBeforeFirstInspect()

			m.MinimockCloseInspect()

			m.MinimockGetInt64Inspect()

			m.MinimockGetInt8Inspect()

			m.MinimockGetStringInspect()

			m.MinimockGetValInspect()

			m.MinimockHasFieldInspect()

			m.MinimockNextInspect()

			m.MinimockSchemaInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ScanMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ScanMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeforeFirstDone() &&
		m.MinimockCloseDone() &&
		m.MinimockGetInt64Done() &&
		m.MinimockGetInt8Done() &&
		m.MinimockGetStringDone() &&
		m.MinimockGetValDone() &&
		m.MinimockHasFieldDone() &&
		m.MinimockNextDone() &&
		m.MinimockSchemaDone()
}
