package indexplanner

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/unhandled-exception/sophiadb/internal/pkg/indexplanner.plan -o ./plan_mock_test.go -n PlanMock

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/unhandled-exception/sophiadb/internal/pkg/records"
	"github.com/unhandled-exception/sophiadb/internal/pkg/scan"
)

// PlanMock implements plan
type PlanMock struct {
	t minimock.Tester

	funcOpen          func() (s1 scan.Scan, err error)
	inspectFuncOpen   func()
	afterOpenCounter  uint64
	beforeOpenCounter uint64
	OpenMock          mPlanMockOpen

	funcSchema          func() (s1 records.Schema)
	inspectFuncSchema   func()
	afterSchemaCounter  uint64
	beforeSchemaCounter uint64
	SchemaMock          mPlanMockSchema

	funcString          func() (s1 string)
	inspectFuncString   func()
	afterStringCounter  uint64
	beforeStringCounter uint64
	StringMock          mPlanMockString
}

// NewPlanMock returns a mock for plan
func NewPlanMock(t minimock.Tester) *PlanMock {
	m := &PlanMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.OpenMock = mPlanMockOpen{mock: m}

	m.SchemaMock = mPlanMockSchema{mock: m}

	m.StringMock = mPlanMockString{mock: m}

	return m
}

type mPlanMockOpen struct {
	mock               *PlanMock
	defaultExpectation *PlanMockOpenExpectation
	expectations       []*PlanMockOpenExpectation
}

// PlanMockOpenExpectation specifies expectation struct of the plan.Open
type PlanMockOpenExpectation struct {
	mock *PlanMock

	results *PlanMockOpenResults
	Counter uint64
}

// PlanMockOpenResults contains results of the plan.Open
type PlanMockOpenResults struct {
	s1  scan.Scan
	err error
}

// Expect sets up expected params for plan.Open
func (mmOpen *mPlanMockOpen) Expect() *mPlanMockOpen {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("PlanMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &PlanMockOpenExpectation{}
	}

	return mmOpen
}

// Inspect accepts an inspector function that has same arguments as the plan.Open
func (mmOpen *mPlanMockOpen) Inspect(f func()) *mPlanMockOpen {
	if mmOpen.mock.inspectFuncOpen != nil {
		mmOpen.mock.t.Fatalf("Inspect function is already set for PlanMock.Open")
	}

	mmOpen.mock.inspectFuncOpen = f

	return mmOpen
}

// Return sets up results that will be returned by plan.Open
func (mmOpen *mPlanMockOpen) Return(s1 scan.Scan, err error) *PlanMock {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("PlanMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &PlanMockOpenExpectation{mock: mmOpen.mock}
	}
	mmOpen.defaultExpectation.results = &PlanMockOpenResults{s1, err}
	return mmOpen.mock
}

//Set uses given function f to mock the plan.Open method
func (mmOpen *mPlanMockOpen) Set(f func() (s1 scan.Scan, err error)) *PlanMock {
	if mmOpen.defaultExpectation != nil {
		mmOpen.mock.t.Fatalf("Default expectation is already set for the plan.Open method")
	}

	if len(mmOpen.expectations) > 0 {
		mmOpen.mock.t.Fatalf("Some expectations are already set for the plan.Open method")
	}

	mmOpen.mock.funcOpen = f
	return mmOpen.mock
}

// Open implements plan
func (mmOpen *PlanMock) Open() (s1 scan.Scan, err error) {
	mm_atomic.AddUint64(&mmOpen.beforeOpenCounter, 1)
	defer mm_atomic.AddUint64(&mmOpen.afterOpenCounter, 1)

	if mmOpen.inspectFuncOpen != nil {
		mmOpen.inspectFuncOpen()
	}

	if mmOpen.OpenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOpen.OpenMock.defaultExpectation.Counter, 1)

		mm_results := mmOpen.OpenMock.defaultExpectation.results
		if mm_results == nil {
			mmOpen.t.Fatal("No results are set for the PlanMock.Open")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmOpen.funcOpen != nil {
		return mmOpen.funcOpen()
	}
	mmOpen.t.Fatalf("Unexpected call to PlanMock.Open.")
	return
}

// OpenAfterCounter returns a count of finished PlanMock.Open invocations
func (mmOpen *PlanMock) OpenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.afterOpenCounter)
}

// OpenBeforeCounter returns a count of PlanMock.Open invocations
func (mmOpen *PlanMock) OpenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.beforeOpenCounter)
}

// MinimockOpenDone returns true if the count of the Open invocations corresponds
// the number of defined expectations
func (m *PlanMock) MinimockOpenDone() bool {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	return true
}

// MinimockOpenInspect logs each unmet expectation
func (m *PlanMock) MinimockOpenInspect() {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to PlanMock.Open")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		m.t.Error("Expected call to PlanMock.Open")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		m.t.Error("Expected call to PlanMock.Open")
	}
}

type mPlanMockSchema struct {
	mock               *PlanMock
	defaultExpectation *PlanMockSchemaExpectation
	expectations       []*PlanMockSchemaExpectation
}

// PlanMockSchemaExpectation specifies expectation struct of the plan.Schema
type PlanMockSchemaExpectation struct {
	mock *PlanMock

	results *PlanMockSchemaResults
	Counter uint64
}

// PlanMockSchemaResults contains results of the plan.Schema
type PlanMockSchemaResults struct {
	s1 records.Schema
}

// Expect sets up expected params for plan.Schema
func (mmSchema *mPlanMockSchema) Expect() *mPlanMockSchema {
	if mmSchema.mock.funcSchema != nil {
		mmSchema.mock.t.Fatalf("PlanMock.Schema mock is already set by Set")
	}

	if mmSchema.defaultExpectation == nil {
		mmSchema.defaultExpectation = &PlanMockSchemaExpectation{}
	}

	return mmSchema
}

// Inspect accepts an inspector function that has same arguments as the plan.Schema
func (mmSchema *mPlanMockSchema) Inspect(f func()) *mPlanMockSchema {
	if mmSchema.mock.inspectFuncSchema != nil {
		mmSchema.mock.t.Fatalf("Inspect function is already set for PlanMock.Schema")
	}

	mmSchema.mock.inspectFuncSchema = f

	return mmSchema
}

// Return sets up results that will be returned by plan.Schema
func (mmSchema *mPlanMockSchema) Return(s1 records.Schema) *PlanMock {
	if mmSchema.mock.funcSchema != nil {
		mmSchema.mock.t.Fatalf("PlanMock.Schema mock is already set by Set")
	}

	if mmSchema.defaultExpectation == nil {
		mmSchema.defaultExpectation = &PlanMockSchemaExpectation{mock: mmSchema.mock}
	}
	mmSchema.defaultExpectation.results = &PlanMockSchemaResults{s1}
	return mmSchema.mock
}

//Set uses given function f to mock the plan.Schema method
func (mmSchema *mPlanMockSchema) Set(f func() (s1 records.Schema)) *PlanMock {
	if mmSchema.defaultExpectation != nil {
		mmSchema.mock.t.Fatalf("Default expectation is already set for the plan.Schema method")
	}

	if len(mmSchema.expectations) > 0 {
		mmSchema.mock.t.Fatalf("Some expectations are already set for the plan.Schema method")
	}

	mmSchema.mock.funcSchema = f
	return mmSchema.mock
}

// Schema implements plan
func (mmSchema *PlanMock) Schema() (s1 records.Schema) {
	mm_atomic.AddUint64(&mmSchema.beforeSchemaCounter, 1)
	defer mm_atomic.AddUint64(&mmSchema.afterSchemaCounter, 1)

	if mmSchema.inspectFuncSchema != nil {
		mmSchema.inspectFuncSchema()
	}

	if mmSchema.SchemaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSchema.SchemaMock.defaultExpectation.Counter, 1)

		mm_results := mmSchema.SchemaMock.defaultExpectation.results
		if mm_results == nil {
			mmSchema.t.Fatal("No results are set for the PlanMock.Schema")
		}
		return (*mm_results).s1
	}
	if mmSchema.funcSchema != nil {
		return mmSchema.funcSchema()
	}
	mmSchema.t.Fatalf("Unexpected call to PlanMock.Schema.")
	return
}

// SchemaAfterCounter returns a count of finished PlanMock.Schema invocations
func (mmSchema *PlanMock) SchemaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSchema.afterSchemaCounter)
}

// SchemaBeforeCounter returns a count of PlanMock.Schema invocations
func (mmSchema *PlanMock) SchemaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSchema.beforeSchemaCounter)
}

// MinimockSchemaDone returns true if the count of the Schema invocations corresponds
// the number of defined expectations
func (m *PlanMock) MinimockSchemaDone() bool {
	for _, e := range m.SchemaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SchemaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSchemaCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSchema != nil && mm_atomic.LoadUint64(&m.afterSchemaCounter) < 1 {
		return false
	}
	return true
}

// MinimockSchemaInspect logs each unmet expectation
func (m *PlanMock) MinimockSchemaInspect() {
	for _, e := range m.SchemaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to PlanMock.Schema")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SchemaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSchemaCounter) < 1 {
		m.t.Error("Expected call to PlanMock.Schema")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSchema != nil && mm_atomic.LoadUint64(&m.afterSchemaCounter) < 1 {
		m.t.Error("Expected call to PlanMock.Schema")
	}
}

type mPlanMockString struct {
	mock               *PlanMock
	defaultExpectation *PlanMockStringExpectation
	expectations       []*PlanMockStringExpectation
}

// PlanMockStringExpectation specifies expectation struct of the plan.String
type PlanMockStringExpectation struct {
	mock *PlanMock

	results *PlanMockStringResults
	Counter uint64
}

// PlanMockStringResults contains results of the plan.String
type PlanMockStringResults struct {
	s1 string
}

// Expect sets up expected params for plan.String
func (mmString *mPlanMockString) Expect() *mPlanMockString {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("PlanMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &PlanMockStringExpectation{}
	}

	return mmString
}

// Inspect accepts an inspector function that has same arguments as the plan.String
func (mmString *mPlanMockString) Inspect(f func()) *mPlanMockString {
	if mmString.mock.inspectFuncString != nil {
		mmString.mock.t.Fatalf("Inspect function is already set for PlanMock.String")
	}

	mmString.mock.inspectFuncString = f

	return mmString
}

// Return sets up results that will be returned by plan.String
func (mmString *mPlanMockString) Return(s1 string) *PlanMock {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("PlanMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &PlanMockStringExpectation{mock: mmString.mock}
	}
	mmString.defaultExpectation.results = &PlanMockStringResults{s1}
	return mmString.mock
}

//Set uses given function f to mock the plan.String method
func (mmString *mPlanMockString) Set(f func() (s1 string)) *PlanMock {
	if mmString.defaultExpectation != nil {
		mmString.mock.t.Fatalf("Default expectation is already set for the plan.String method")
	}

	if len(mmString.expectations) > 0 {
		mmString.mock.t.Fatalf("Some expectations are already set for the plan.String method")
	}

	mmString.mock.funcString = f
	return mmString.mock
}

// String implements plan
func (mmString *PlanMock) String() (s1 string) {
	mm_atomic.AddUint64(&mmString.beforeStringCounter, 1)
	defer mm_atomic.AddUint64(&mmString.afterStringCounter, 1)

	if mmString.inspectFuncString != nil {
		mmString.inspectFuncString()
	}

	if mmString.StringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmString.StringMock.defaultExpectation.Counter, 1)

		mm_results := mmString.StringMock.defaultExpectation.results
		if mm_results == nil {
			mmString.t.Fatal("No results are set for the PlanMock.String")
		}
		return (*mm_results).s1
	}
	if mmString.funcString != nil {
		return mmString.funcString()
	}
	mmString.t.Fatalf("Unexpected call to PlanMock.String.")
	return
}

// StringAfterCounter returns a count of finished PlanMock.String invocations
func (mmString *PlanMock) StringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.afterStringCounter)
}

// StringBeforeCounter returns a count of PlanMock.String invocations
func (mmString *PlanMock) StringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.beforeStringCounter)
}

// MinimockStringDone returns true if the count of the String invocations corresponds
// the number of defined expectations
func (m *PlanMock) MinimockStringDone() bool {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockStringInspect logs each unmet expectation
func (m *PlanMock) MinimockStringInspect() {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to PlanMock.String")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		m.t.Error("Expected call to PlanMock.String")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		m.t.Error("Expected call to PlanMock.String")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PlanMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockOpenInspect()

		m.MinimockSchemaInspect()

		m.MinimockStringInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PlanMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PlanMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockOpenDone() &&
		m.MinimockSchemaDone() &&
		m.MinimockStringDone()
}
