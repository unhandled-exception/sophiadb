package indexplanner

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/unhandled-exception/sophiadb/internal/pkg/indexplanner.indexInfo -o ./index_info_mock_test.go -n IndexInfoMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/unhandled-exception/sophiadb/internal/pkg/indexes"
)

// IndexInfoMock implements indexInfo
type IndexInfoMock struct {
	t minimock.Tester

	funcBlocksAccessed          func() (i1 int64)
	inspectFuncBlocksAccessed   func()
	afterBlocksAccessedCounter  uint64
	beforeBlocksAccessedCounter uint64
	BlocksAccessedMock          mIndexInfoMockBlocksAccessed

	funcDistinctValues          func(fieldName string) (i1 int64)
	inspectFuncDistinctValues   func(fieldName string)
	afterDistinctValuesCounter  uint64
	beforeDistinctValuesCounter uint64
	DistinctValuesMock          mIndexInfoMockDistinctValues

	funcOpen          func() (i1 indexes.Index, err error)
	inspectFuncOpen   func()
	afterOpenCounter  uint64
	beforeOpenCounter uint64
	OpenMock          mIndexInfoMockOpen

	funcRecords          func() (i1 int64)
	inspectFuncRecords   func()
	afterRecordsCounter  uint64
	beforeRecordsCounter uint64
	RecordsMock          mIndexInfoMockRecords

	funcString          func() (s1 string)
	inspectFuncString   func()
	afterStringCounter  uint64
	beforeStringCounter uint64
	StringMock          mIndexInfoMockString
}

// NewIndexInfoMock returns a mock for indexInfo
func NewIndexInfoMock(t minimock.Tester) *IndexInfoMock {
	m := &IndexInfoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BlocksAccessedMock = mIndexInfoMockBlocksAccessed{mock: m}

	m.DistinctValuesMock = mIndexInfoMockDistinctValues{mock: m}
	m.DistinctValuesMock.callArgs = []*IndexInfoMockDistinctValuesParams{}

	m.OpenMock = mIndexInfoMockOpen{mock: m}

	m.RecordsMock = mIndexInfoMockRecords{mock: m}

	m.StringMock = mIndexInfoMockString{mock: m}

	return m
}

type mIndexInfoMockBlocksAccessed struct {
	mock               *IndexInfoMock
	defaultExpectation *IndexInfoMockBlocksAccessedExpectation
	expectations       []*IndexInfoMockBlocksAccessedExpectation
}

// IndexInfoMockBlocksAccessedExpectation specifies expectation struct of the indexInfo.BlocksAccessed
type IndexInfoMockBlocksAccessedExpectation struct {
	mock *IndexInfoMock

	results *IndexInfoMockBlocksAccessedResults
	Counter uint64
}

// IndexInfoMockBlocksAccessedResults contains results of the indexInfo.BlocksAccessed
type IndexInfoMockBlocksAccessedResults struct {
	i1 int64
}

// Expect sets up expected params for indexInfo.BlocksAccessed
func (mmBlocksAccessed *mIndexInfoMockBlocksAccessed) Expect() *mIndexInfoMockBlocksAccessed {
	if mmBlocksAccessed.mock.funcBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("IndexInfoMock.BlocksAccessed mock is already set by Set")
	}

	if mmBlocksAccessed.defaultExpectation == nil {
		mmBlocksAccessed.defaultExpectation = &IndexInfoMockBlocksAccessedExpectation{}
	}

	return mmBlocksAccessed
}

// Inspect accepts an inspector function that has same arguments as the indexInfo.BlocksAccessed
func (mmBlocksAccessed *mIndexInfoMockBlocksAccessed) Inspect(f func()) *mIndexInfoMockBlocksAccessed {
	if mmBlocksAccessed.mock.inspectFuncBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("Inspect function is already set for IndexInfoMock.BlocksAccessed")
	}

	mmBlocksAccessed.mock.inspectFuncBlocksAccessed = f

	return mmBlocksAccessed
}

// Return sets up results that will be returned by indexInfo.BlocksAccessed
func (mmBlocksAccessed *mIndexInfoMockBlocksAccessed) Return(i1 int64) *IndexInfoMock {
	if mmBlocksAccessed.mock.funcBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("IndexInfoMock.BlocksAccessed mock is already set by Set")
	}

	if mmBlocksAccessed.defaultExpectation == nil {
		mmBlocksAccessed.defaultExpectation = &IndexInfoMockBlocksAccessedExpectation{mock: mmBlocksAccessed.mock}
	}
	mmBlocksAccessed.defaultExpectation.results = &IndexInfoMockBlocksAccessedResults{i1}
	return mmBlocksAccessed.mock
}

//Set uses given function f to mock the indexInfo.BlocksAccessed method
func (mmBlocksAccessed *mIndexInfoMockBlocksAccessed) Set(f func() (i1 int64)) *IndexInfoMock {
	if mmBlocksAccessed.defaultExpectation != nil {
		mmBlocksAccessed.mock.t.Fatalf("Default expectation is already set for the indexInfo.BlocksAccessed method")
	}

	if len(mmBlocksAccessed.expectations) > 0 {
		mmBlocksAccessed.mock.t.Fatalf("Some expectations are already set for the indexInfo.BlocksAccessed method")
	}

	mmBlocksAccessed.mock.funcBlocksAccessed = f
	return mmBlocksAccessed.mock
}

// BlocksAccessed implements indexInfo
func (mmBlocksAccessed *IndexInfoMock) BlocksAccessed() (i1 int64) {
	mm_atomic.AddUint64(&mmBlocksAccessed.beforeBlocksAccessedCounter, 1)
	defer mm_atomic.AddUint64(&mmBlocksAccessed.afterBlocksAccessedCounter, 1)

	if mmBlocksAccessed.inspectFuncBlocksAccessed != nil {
		mmBlocksAccessed.inspectFuncBlocksAccessed()
	}

	if mmBlocksAccessed.BlocksAccessedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBlocksAccessed.BlocksAccessedMock.defaultExpectation.Counter, 1)

		mm_results := mmBlocksAccessed.BlocksAccessedMock.defaultExpectation.results
		if mm_results == nil {
			mmBlocksAccessed.t.Fatal("No results are set for the IndexInfoMock.BlocksAccessed")
		}
		return (*mm_results).i1
	}
	if mmBlocksAccessed.funcBlocksAccessed != nil {
		return mmBlocksAccessed.funcBlocksAccessed()
	}
	mmBlocksAccessed.t.Fatalf("Unexpected call to IndexInfoMock.BlocksAccessed.")
	return
}

// BlocksAccessedAfterCounter returns a count of finished IndexInfoMock.BlocksAccessed invocations
func (mmBlocksAccessed *IndexInfoMock) BlocksAccessedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBlocksAccessed.afterBlocksAccessedCounter)
}

// BlocksAccessedBeforeCounter returns a count of IndexInfoMock.BlocksAccessed invocations
func (mmBlocksAccessed *IndexInfoMock) BlocksAccessedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBlocksAccessed.beforeBlocksAccessedCounter)
}

// MinimockBlocksAccessedDone returns true if the count of the BlocksAccessed invocations corresponds
// the number of defined expectations
func (m *IndexInfoMock) MinimockBlocksAccessedDone() bool {
	for _, e := range m.BlocksAccessedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BlocksAccessedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBlocksAccessedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBlocksAccessed != nil && mm_atomic.LoadUint64(&m.afterBlocksAccessedCounter) < 1 {
		return false
	}
	return true
}

// MinimockBlocksAccessedInspect logs each unmet expectation
func (m *IndexInfoMock) MinimockBlocksAccessedInspect() {
	for _, e := range m.BlocksAccessedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to IndexInfoMock.BlocksAccessed")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BlocksAccessedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBlocksAccessedCounter) < 1 {
		m.t.Error("Expected call to IndexInfoMock.BlocksAccessed")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBlocksAccessed != nil && mm_atomic.LoadUint64(&m.afterBlocksAccessedCounter) < 1 {
		m.t.Error("Expected call to IndexInfoMock.BlocksAccessed")
	}
}

type mIndexInfoMockDistinctValues struct {
	mock               *IndexInfoMock
	defaultExpectation *IndexInfoMockDistinctValuesExpectation
	expectations       []*IndexInfoMockDistinctValuesExpectation

	callArgs []*IndexInfoMockDistinctValuesParams
	mutex    sync.RWMutex
}

// IndexInfoMockDistinctValuesExpectation specifies expectation struct of the indexInfo.DistinctValues
type IndexInfoMockDistinctValuesExpectation struct {
	mock    *IndexInfoMock
	params  *IndexInfoMockDistinctValuesParams
	results *IndexInfoMockDistinctValuesResults
	Counter uint64
}

// IndexInfoMockDistinctValuesParams contains parameters of the indexInfo.DistinctValues
type IndexInfoMockDistinctValuesParams struct {
	fieldName string
}

// IndexInfoMockDistinctValuesResults contains results of the indexInfo.DistinctValues
type IndexInfoMockDistinctValuesResults struct {
	i1 int64
}

// Expect sets up expected params for indexInfo.DistinctValues
func (mmDistinctValues *mIndexInfoMockDistinctValues) Expect(fieldName string) *mIndexInfoMockDistinctValues {
	if mmDistinctValues.mock.funcDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("IndexInfoMock.DistinctValues mock is already set by Set")
	}

	if mmDistinctValues.defaultExpectation == nil {
		mmDistinctValues.defaultExpectation = &IndexInfoMockDistinctValuesExpectation{}
	}

	mmDistinctValues.defaultExpectation.params = &IndexInfoMockDistinctValuesParams{fieldName}
	for _, e := range mmDistinctValues.expectations {
		if minimock.Equal(e.params, mmDistinctValues.defaultExpectation.params) {
			mmDistinctValues.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDistinctValues.defaultExpectation.params)
		}
	}

	return mmDistinctValues
}

// Inspect accepts an inspector function that has same arguments as the indexInfo.DistinctValues
func (mmDistinctValues *mIndexInfoMockDistinctValues) Inspect(f func(fieldName string)) *mIndexInfoMockDistinctValues {
	if mmDistinctValues.mock.inspectFuncDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("Inspect function is already set for IndexInfoMock.DistinctValues")
	}

	mmDistinctValues.mock.inspectFuncDistinctValues = f

	return mmDistinctValues
}

// Return sets up results that will be returned by indexInfo.DistinctValues
func (mmDistinctValues *mIndexInfoMockDistinctValues) Return(i1 int64) *IndexInfoMock {
	if mmDistinctValues.mock.funcDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("IndexInfoMock.DistinctValues mock is already set by Set")
	}

	if mmDistinctValues.defaultExpectation == nil {
		mmDistinctValues.defaultExpectation = &IndexInfoMockDistinctValuesExpectation{mock: mmDistinctValues.mock}
	}
	mmDistinctValues.defaultExpectation.results = &IndexInfoMockDistinctValuesResults{i1}
	return mmDistinctValues.mock
}

//Set uses given function f to mock the indexInfo.DistinctValues method
func (mmDistinctValues *mIndexInfoMockDistinctValues) Set(f func(fieldName string) (i1 int64)) *IndexInfoMock {
	if mmDistinctValues.defaultExpectation != nil {
		mmDistinctValues.mock.t.Fatalf("Default expectation is already set for the indexInfo.DistinctValues method")
	}

	if len(mmDistinctValues.expectations) > 0 {
		mmDistinctValues.mock.t.Fatalf("Some expectations are already set for the indexInfo.DistinctValues method")
	}

	mmDistinctValues.mock.funcDistinctValues = f
	return mmDistinctValues.mock
}

// When sets expectation for the indexInfo.DistinctValues which will trigger the result defined by the following
// Then helper
func (mmDistinctValues *mIndexInfoMockDistinctValues) When(fieldName string) *IndexInfoMockDistinctValuesExpectation {
	if mmDistinctValues.mock.funcDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("IndexInfoMock.DistinctValues mock is already set by Set")
	}

	expectation := &IndexInfoMockDistinctValuesExpectation{
		mock:   mmDistinctValues.mock,
		params: &IndexInfoMockDistinctValuesParams{fieldName},
	}
	mmDistinctValues.expectations = append(mmDistinctValues.expectations, expectation)
	return expectation
}

// Then sets up indexInfo.DistinctValues return parameters for the expectation previously defined by the When method
func (e *IndexInfoMockDistinctValuesExpectation) Then(i1 int64) *IndexInfoMock {
	e.results = &IndexInfoMockDistinctValuesResults{i1}
	return e.mock
}

// DistinctValues implements indexInfo
func (mmDistinctValues *IndexInfoMock) DistinctValues(fieldName string) (i1 int64) {
	mm_atomic.AddUint64(&mmDistinctValues.beforeDistinctValuesCounter, 1)
	defer mm_atomic.AddUint64(&mmDistinctValues.afterDistinctValuesCounter, 1)

	if mmDistinctValues.inspectFuncDistinctValues != nil {
		mmDistinctValues.inspectFuncDistinctValues(fieldName)
	}

	mm_params := &IndexInfoMockDistinctValuesParams{fieldName}

	// Record call args
	mmDistinctValues.DistinctValuesMock.mutex.Lock()
	mmDistinctValues.DistinctValuesMock.callArgs = append(mmDistinctValues.DistinctValuesMock.callArgs, mm_params)
	mmDistinctValues.DistinctValuesMock.mutex.Unlock()

	for _, e := range mmDistinctValues.DistinctValuesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1
		}
	}

	if mmDistinctValues.DistinctValuesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDistinctValues.DistinctValuesMock.defaultExpectation.Counter, 1)
		mm_want := mmDistinctValues.DistinctValuesMock.defaultExpectation.params
		mm_got := IndexInfoMockDistinctValuesParams{fieldName}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDistinctValues.t.Errorf("IndexInfoMock.DistinctValues got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDistinctValues.DistinctValuesMock.defaultExpectation.results
		if mm_results == nil {
			mmDistinctValues.t.Fatal("No results are set for the IndexInfoMock.DistinctValues")
		}
		return (*mm_results).i1
	}
	if mmDistinctValues.funcDistinctValues != nil {
		return mmDistinctValues.funcDistinctValues(fieldName)
	}
	mmDistinctValues.t.Fatalf("Unexpected call to IndexInfoMock.DistinctValues. %v", fieldName)
	return
}

// DistinctValuesAfterCounter returns a count of finished IndexInfoMock.DistinctValues invocations
func (mmDistinctValues *IndexInfoMock) DistinctValuesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDistinctValues.afterDistinctValuesCounter)
}

// DistinctValuesBeforeCounter returns a count of IndexInfoMock.DistinctValues invocations
func (mmDistinctValues *IndexInfoMock) DistinctValuesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDistinctValues.beforeDistinctValuesCounter)
}

// Calls returns a list of arguments used in each call to IndexInfoMock.DistinctValues.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDistinctValues *mIndexInfoMockDistinctValues) Calls() []*IndexInfoMockDistinctValuesParams {
	mmDistinctValues.mutex.RLock()

	argCopy := make([]*IndexInfoMockDistinctValuesParams, len(mmDistinctValues.callArgs))
	copy(argCopy, mmDistinctValues.callArgs)

	mmDistinctValues.mutex.RUnlock()

	return argCopy
}

// MinimockDistinctValuesDone returns true if the count of the DistinctValues invocations corresponds
// the number of defined expectations
func (m *IndexInfoMock) MinimockDistinctValuesDone() bool {
	for _, e := range m.DistinctValuesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DistinctValuesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDistinctValuesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDistinctValues != nil && mm_atomic.LoadUint64(&m.afterDistinctValuesCounter) < 1 {
		return false
	}
	return true
}

// MinimockDistinctValuesInspect logs each unmet expectation
func (m *IndexInfoMock) MinimockDistinctValuesInspect() {
	for _, e := range m.DistinctValuesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IndexInfoMock.DistinctValues with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DistinctValuesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDistinctValuesCounter) < 1 {
		if m.DistinctValuesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IndexInfoMock.DistinctValues")
		} else {
			m.t.Errorf("Expected call to IndexInfoMock.DistinctValues with params: %#v", *m.DistinctValuesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDistinctValues != nil && mm_atomic.LoadUint64(&m.afterDistinctValuesCounter) < 1 {
		m.t.Error("Expected call to IndexInfoMock.DistinctValues")
	}
}

type mIndexInfoMockOpen struct {
	mock               *IndexInfoMock
	defaultExpectation *IndexInfoMockOpenExpectation
	expectations       []*IndexInfoMockOpenExpectation
}

// IndexInfoMockOpenExpectation specifies expectation struct of the indexInfo.Open
type IndexInfoMockOpenExpectation struct {
	mock *IndexInfoMock

	results *IndexInfoMockOpenResults
	Counter uint64
}

// IndexInfoMockOpenResults contains results of the indexInfo.Open
type IndexInfoMockOpenResults struct {
	i1  indexes.Index
	err error
}

// Expect sets up expected params for indexInfo.Open
func (mmOpen *mIndexInfoMockOpen) Expect() *mIndexInfoMockOpen {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("IndexInfoMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &IndexInfoMockOpenExpectation{}
	}

	return mmOpen
}

// Inspect accepts an inspector function that has same arguments as the indexInfo.Open
func (mmOpen *mIndexInfoMockOpen) Inspect(f func()) *mIndexInfoMockOpen {
	if mmOpen.mock.inspectFuncOpen != nil {
		mmOpen.mock.t.Fatalf("Inspect function is already set for IndexInfoMock.Open")
	}

	mmOpen.mock.inspectFuncOpen = f

	return mmOpen
}

// Return sets up results that will be returned by indexInfo.Open
func (mmOpen *mIndexInfoMockOpen) Return(i1 indexes.Index, err error) *IndexInfoMock {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("IndexInfoMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &IndexInfoMockOpenExpectation{mock: mmOpen.mock}
	}
	mmOpen.defaultExpectation.results = &IndexInfoMockOpenResults{i1, err}
	return mmOpen.mock
}

//Set uses given function f to mock the indexInfo.Open method
func (mmOpen *mIndexInfoMockOpen) Set(f func() (i1 indexes.Index, err error)) *IndexInfoMock {
	if mmOpen.defaultExpectation != nil {
		mmOpen.mock.t.Fatalf("Default expectation is already set for the indexInfo.Open method")
	}

	if len(mmOpen.expectations) > 0 {
		mmOpen.mock.t.Fatalf("Some expectations are already set for the indexInfo.Open method")
	}

	mmOpen.mock.funcOpen = f
	return mmOpen.mock
}

// Open implements indexInfo
func (mmOpen *IndexInfoMock) Open() (i1 indexes.Index, err error) {
	mm_atomic.AddUint64(&mmOpen.beforeOpenCounter, 1)
	defer mm_atomic.AddUint64(&mmOpen.afterOpenCounter, 1)

	if mmOpen.inspectFuncOpen != nil {
		mmOpen.inspectFuncOpen()
	}

	if mmOpen.OpenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOpen.OpenMock.defaultExpectation.Counter, 1)

		mm_results := mmOpen.OpenMock.defaultExpectation.results
		if mm_results == nil {
			mmOpen.t.Fatal("No results are set for the IndexInfoMock.Open")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmOpen.funcOpen != nil {
		return mmOpen.funcOpen()
	}
	mmOpen.t.Fatalf("Unexpected call to IndexInfoMock.Open.")
	return
}

// OpenAfterCounter returns a count of finished IndexInfoMock.Open invocations
func (mmOpen *IndexInfoMock) OpenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.afterOpenCounter)
}

// OpenBeforeCounter returns a count of IndexInfoMock.Open invocations
func (mmOpen *IndexInfoMock) OpenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.beforeOpenCounter)
}

// MinimockOpenDone returns true if the count of the Open invocations corresponds
// the number of defined expectations
func (m *IndexInfoMock) MinimockOpenDone() bool {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	return true
}

// MinimockOpenInspect logs each unmet expectation
func (m *IndexInfoMock) MinimockOpenInspect() {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to IndexInfoMock.Open")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		m.t.Error("Expected call to IndexInfoMock.Open")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		m.t.Error("Expected call to IndexInfoMock.Open")
	}
}

type mIndexInfoMockRecords struct {
	mock               *IndexInfoMock
	defaultExpectation *IndexInfoMockRecordsExpectation
	expectations       []*IndexInfoMockRecordsExpectation
}

// IndexInfoMockRecordsExpectation specifies expectation struct of the indexInfo.Records
type IndexInfoMockRecordsExpectation struct {
	mock *IndexInfoMock

	results *IndexInfoMockRecordsResults
	Counter uint64
}

// IndexInfoMockRecordsResults contains results of the indexInfo.Records
type IndexInfoMockRecordsResults struct {
	i1 int64
}

// Expect sets up expected params for indexInfo.Records
func (mmRecords *mIndexInfoMockRecords) Expect() *mIndexInfoMockRecords {
	if mmRecords.mock.funcRecords != nil {
		mmRecords.mock.t.Fatalf("IndexInfoMock.Records mock is already set by Set")
	}

	if mmRecords.defaultExpectation == nil {
		mmRecords.defaultExpectation = &IndexInfoMockRecordsExpectation{}
	}

	return mmRecords
}

// Inspect accepts an inspector function that has same arguments as the indexInfo.Records
func (mmRecords *mIndexInfoMockRecords) Inspect(f func()) *mIndexInfoMockRecords {
	if mmRecords.mock.inspectFuncRecords != nil {
		mmRecords.mock.t.Fatalf("Inspect function is already set for IndexInfoMock.Records")
	}

	mmRecords.mock.inspectFuncRecords = f

	return mmRecords
}

// Return sets up results that will be returned by indexInfo.Records
func (mmRecords *mIndexInfoMockRecords) Return(i1 int64) *IndexInfoMock {
	if mmRecords.mock.funcRecords != nil {
		mmRecords.mock.t.Fatalf("IndexInfoMock.Records mock is already set by Set")
	}

	if mmRecords.defaultExpectation == nil {
		mmRecords.defaultExpectation = &IndexInfoMockRecordsExpectation{mock: mmRecords.mock}
	}
	mmRecords.defaultExpectation.results = &IndexInfoMockRecordsResults{i1}
	return mmRecords.mock
}

//Set uses given function f to mock the indexInfo.Records method
func (mmRecords *mIndexInfoMockRecords) Set(f func() (i1 int64)) *IndexInfoMock {
	if mmRecords.defaultExpectation != nil {
		mmRecords.mock.t.Fatalf("Default expectation is already set for the indexInfo.Records method")
	}

	if len(mmRecords.expectations) > 0 {
		mmRecords.mock.t.Fatalf("Some expectations are already set for the indexInfo.Records method")
	}

	mmRecords.mock.funcRecords = f
	return mmRecords.mock
}

// Records implements indexInfo
func (mmRecords *IndexInfoMock) Records() (i1 int64) {
	mm_atomic.AddUint64(&mmRecords.beforeRecordsCounter, 1)
	defer mm_atomic.AddUint64(&mmRecords.afterRecordsCounter, 1)

	if mmRecords.inspectFuncRecords != nil {
		mmRecords.inspectFuncRecords()
	}

	if mmRecords.RecordsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecords.RecordsMock.defaultExpectation.Counter, 1)

		mm_results := mmRecords.RecordsMock.defaultExpectation.results
		if mm_results == nil {
			mmRecords.t.Fatal("No results are set for the IndexInfoMock.Records")
		}
		return (*mm_results).i1
	}
	if mmRecords.funcRecords != nil {
		return mmRecords.funcRecords()
	}
	mmRecords.t.Fatalf("Unexpected call to IndexInfoMock.Records.")
	return
}

// RecordsAfterCounter returns a count of finished IndexInfoMock.Records invocations
func (mmRecords *IndexInfoMock) RecordsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecords.afterRecordsCounter)
}

// RecordsBeforeCounter returns a count of IndexInfoMock.Records invocations
func (mmRecords *IndexInfoMock) RecordsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecords.beforeRecordsCounter)
}

// MinimockRecordsDone returns true if the count of the Records invocations corresponds
// the number of defined expectations
func (m *IndexInfoMock) MinimockRecordsDone() bool {
	for _, e := range m.RecordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecordsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecordsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecords != nil && mm_atomic.LoadUint64(&m.afterRecordsCounter) < 1 {
		return false
	}
	return true
}

// MinimockRecordsInspect logs each unmet expectation
func (m *IndexInfoMock) MinimockRecordsInspect() {
	for _, e := range m.RecordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to IndexInfoMock.Records")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecordsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecordsCounter) < 1 {
		m.t.Error("Expected call to IndexInfoMock.Records")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecords != nil && mm_atomic.LoadUint64(&m.afterRecordsCounter) < 1 {
		m.t.Error("Expected call to IndexInfoMock.Records")
	}
}

type mIndexInfoMockString struct {
	mock               *IndexInfoMock
	defaultExpectation *IndexInfoMockStringExpectation
	expectations       []*IndexInfoMockStringExpectation
}

// IndexInfoMockStringExpectation specifies expectation struct of the indexInfo.String
type IndexInfoMockStringExpectation struct {
	mock *IndexInfoMock

	results *IndexInfoMockStringResults
	Counter uint64
}

// IndexInfoMockStringResults contains results of the indexInfo.String
type IndexInfoMockStringResults struct {
	s1 string
}

// Expect sets up expected params for indexInfo.String
func (mmString *mIndexInfoMockString) Expect() *mIndexInfoMockString {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("IndexInfoMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &IndexInfoMockStringExpectation{}
	}

	return mmString
}

// Inspect accepts an inspector function that has same arguments as the indexInfo.String
func (mmString *mIndexInfoMockString) Inspect(f func()) *mIndexInfoMockString {
	if mmString.mock.inspectFuncString != nil {
		mmString.mock.t.Fatalf("Inspect function is already set for IndexInfoMock.String")
	}

	mmString.mock.inspectFuncString = f

	return mmString
}

// Return sets up results that will be returned by indexInfo.String
func (mmString *mIndexInfoMockString) Return(s1 string) *IndexInfoMock {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("IndexInfoMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &IndexInfoMockStringExpectation{mock: mmString.mock}
	}
	mmString.defaultExpectation.results = &IndexInfoMockStringResults{s1}
	return mmString.mock
}

//Set uses given function f to mock the indexInfo.String method
func (mmString *mIndexInfoMockString) Set(f func() (s1 string)) *IndexInfoMock {
	if mmString.defaultExpectation != nil {
		mmString.mock.t.Fatalf("Default expectation is already set for the indexInfo.String method")
	}

	if len(mmString.expectations) > 0 {
		mmString.mock.t.Fatalf("Some expectations are already set for the indexInfo.String method")
	}

	mmString.mock.funcString = f
	return mmString.mock
}

// String implements indexInfo
func (mmString *IndexInfoMock) String() (s1 string) {
	mm_atomic.AddUint64(&mmString.beforeStringCounter, 1)
	defer mm_atomic.AddUint64(&mmString.afterStringCounter, 1)

	if mmString.inspectFuncString != nil {
		mmString.inspectFuncString()
	}

	if mmString.StringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmString.StringMock.defaultExpectation.Counter, 1)

		mm_results := mmString.StringMock.defaultExpectation.results
		if mm_results == nil {
			mmString.t.Fatal("No results are set for the IndexInfoMock.String")
		}
		return (*mm_results).s1
	}
	if mmString.funcString != nil {
		return mmString.funcString()
	}
	mmString.t.Fatalf("Unexpected call to IndexInfoMock.String.")
	return
}

// StringAfterCounter returns a count of finished IndexInfoMock.String invocations
func (mmString *IndexInfoMock) StringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.afterStringCounter)
}

// StringBeforeCounter returns a count of IndexInfoMock.String invocations
func (mmString *IndexInfoMock) StringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.beforeStringCounter)
}

// MinimockStringDone returns true if the count of the String invocations corresponds
// the number of defined expectations
func (m *IndexInfoMock) MinimockStringDone() bool {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockStringInspect logs each unmet expectation
func (m *IndexInfoMock) MinimockStringInspect() {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to IndexInfoMock.String")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		m.t.Error("Expected call to IndexInfoMock.String")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		m.t.Error("Expected call to IndexInfoMock.String")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IndexInfoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBlocksAccessedInspect()

		m.MinimockDistinctValuesInspect()

		m.MinimockOpenInspect()

		m.MinimockRecordsInspect()

		m.MinimockStringInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IndexInfoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IndexInfoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBlocksAccessedDone() &&
		m.MinimockDistinctValuesDone() &&
		m.MinimockOpenDone() &&
		m.MinimockRecordsDone() &&
		m.MinimockStringDone()
}
