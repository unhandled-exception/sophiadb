// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package indexplanner

//go:generate minimock -i github.com/unhandled-exception/sophiadb/internal/pkg/indexplanner.jIndexInfo -o mock_jindex_info_test.go -n JIndexInfoMock -p indexplanner

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/unhandled-exception/sophiadb/internal/pkg/indexes"
)

// JIndexInfoMock implements jIndexInfo
type JIndexInfoMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBlocksAccessed          func() (i1 int64)
	inspectFuncBlocksAccessed   func()
	afterBlocksAccessedCounter  uint64
	beforeBlocksAccessedCounter uint64
	BlocksAccessedMock          mJIndexInfoMockBlocksAccessed

	funcOpen          func() (i1 indexes.Index, err error)
	inspectFuncOpen   func()
	afterOpenCounter  uint64
	beforeOpenCounter uint64
	OpenMock          mJIndexInfoMockOpen

	funcRecords          func() (i1 int64)
	inspectFuncRecords   func()
	afterRecordsCounter  uint64
	beforeRecordsCounter uint64
	RecordsMock          mJIndexInfoMockRecords

	funcString          func() (s1 string)
	inspectFuncString   func()
	afterStringCounter  uint64
	beforeStringCounter uint64
	StringMock          mJIndexInfoMockString
}

// NewJIndexInfoMock returns a mock for jIndexInfo
func NewJIndexInfoMock(t minimock.Tester) *JIndexInfoMock {
	m := &JIndexInfoMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BlocksAccessedMock = mJIndexInfoMockBlocksAccessed{mock: m}

	m.OpenMock = mJIndexInfoMockOpen{mock: m}

	m.RecordsMock = mJIndexInfoMockRecords{mock: m}

	m.StringMock = mJIndexInfoMockString{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mJIndexInfoMockBlocksAccessed struct {
	optional           bool
	mock               *JIndexInfoMock
	defaultExpectation *JIndexInfoMockBlocksAccessedExpectation
	expectations       []*JIndexInfoMockBlocksAccessedExpectation

	expectedInvocations uint64
}

// JIndexInfoMockBlocksAccessedExpectation specifies expectation struct of the jIndexInfo.BlocksAccessed
type JIndexInfoMockBlocksAccessedExpectation struct {
	mock *JIndexInfoMock

	results *JIndexInfoMockBlocksAccessedResults
	Counter uint64
}

// JIndexInfoMockBlocksAccessedResults contains results of the jIndexInfo.BlocksAccessed
type JIndexInfoMockBlocksAccessedResults struct {
	i1 int64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBlocksAccessed *mJIndexInfoMockBlocksAccessed) Optional() *mJIndexInfoMockBlocksAccessed {
	mmBlocksAccessed.optional = true
	return mmBlocksAccessed
}

// Expect sets up expected params for jIndexInfo.BlocksAccessed
func (mmBlocksAccessed *mJIndexInfoMockBlocksAccessed) Expect() *mJIndexInfoMockBlocksAccessed {
	if mmBlocksAccessed.mock.funcBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("JIndexInfoMock.BlocksAccessed mock is already set by Set")
	}

	if mmBlocksAccessed.defaultExpectation == nil {
		mmBlocksAccessed.defaultExpectation = &JIndexInfoMockBlocksAccessedExpectation{}
	}

	return mmBlocksAccessed
}

// Inspect accepts an inspector function that has same arguments as the jIndexInfo.BlocksAccessed
func (mmBlocksAccessed *mJIndexInfoMockBlocksAccessed) Inspect(f func()) *mJIndexInfoMockBlocksAccessed {
	if mmBlocksAccessed.mock.inspectFuncBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("Inspect function is already set for JIndexInfoMock.BlocksAccessed")
	}

	mmBlocksAccessed.mock.inspectFuncBlocksAccessed = f

	return mmBlocksAccessed
}

// Return sets up results that will be returned by jIndexInfo.BlocksAccessed
func (mmBlocksAccessed *mJIndexInfoMockBlocksAccessed) Return(i1 int64) *JIndexInfoMock {
	if mmBlocksAccessed.mock.funcBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("JIndexInfoMock.BlocksAccessed mock is already set by Set")
	}

	if mmBlocksAccessed.defaultExpectation == nil {
		mmBlocksAccessed.defaultExpectation = &JIndexInfoMockBlocksAccessedExpectation{mock: mmBlocksAccessed.mock}
	}
	mmBlocksAccessed.defaultExpectation.results = &JIndexInfoMockBlocksAccessedResults{i1}
	return mmBlocksAccessed.mock
}

// Set uses given function f to mock the jIndexInfo.BlocksAccessed method
func (mmBlocksAccessed *mJIndexInfoMockBlocksAccessed) Set(f func() (i1 int64)) *JIndexInfoMock {
	if mmBlocksAccessed.defaultExpectation != nil {
		mmBlocksAccessed.mock.t.Fatalf("Default expectation is already set for the jIndexInfo.BlocksAccessed method")
	}

	if len(mmBlocksAccessed.expectations) > 0 {
		mmBlocksAccessed.mock.t.Fatalf("Some expectations are already set for the jIndexInfo.BlocksAccessed method")
	}

	mmBlocksAccessed.mock.funcBlocksAccessed = f
	return mmBlocksAccessed.mock
}

// Times sets number of times jIndexInfo.BlocksAccessed should be invoked
func (mmBlocksAccessed *mJIndexInfoMockBlocksAccessed) Times(n uint64) *mJIndexInfoMockBlocksAccessed {
	if n == 0 {
		mmBlocksAccessed.mock.t.Fatalf("Times of JIndexInfoMock.BlocksAccessed mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBlocksAccessed.expectedInvocations, n)
	return mmBlocksAccessed
}

func (mmBlocksAccessed *mJIndexInfoMockBlocksAccessed) invocationsDone() bool {
	if len(mmBlocksAccessed.expectations) == 0 && mmBlocksAccessed.defaultExpectation == nil && mmBlocksAccessed.mock.funcBlocksAccessed == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBlocksAccessed.mock.afterBlocksAccessedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBlocksAccessed.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// BlocksAccessed implements jIndexInfo
func (mmBlocksAccessed *JIndexInfoMock) BlocksAccessed() (i1 int64) {
	mm_atomic.AddUint64(&mmBlocksAccessed.beforeBlocksAccessedCounter, 1)
	defer mm_atomic.AddUint64(&mmBlocksAccessed.afterBlocksAccessedCounter, 1)

	if mmBlocksAccessed.inspectFuncBlocksAccessed != nil {
		mmBlocksAccessed.inspectFuncBlocksAccessed()
	}

	if mmBlocksAccessed.BlocksAccessedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBlocksAccessed.BlocksAccessedMock.defaultExpectation.Counter, 1)

		mm_results := mmBlocksAccessed.BlocksAccessedMock.defaultExpectation.results
		if mm_results == nil {
			mmBlocksAccessed.t.Fatal("No results are set for the JIndexInfoMock.BlocksAccessed")
		}
		return (*mm_results).i1
	}
	if mmBlocksAccessed.funcBlocksAccessed != nil {
		return mmBlocksAccessed.funcBlocksAccessed()
	}
	mmBlocksAccessed.t.Fatalf("Unexpected call to JIndexInfoMock.BlocksAccessed.")
	return
}

// BlocksAccessedAfterCounter returns a count of finished JIndexInfoMock.BlocksAccessed invocations
func (mmBlocksAccessed *JIndexInfoMock) BlocksAccessedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBlocksAccessed.afterBlocksAccessedCounter)
}

// BlocksAccessedBeforeCounter returns a count of JIndexInfoMock.BlocksAccessed invocations
func (mmBlocksAccessed *JIndexInfoMock) BlocksAccessedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBlocksAccessed.beforeBlocksAccessedCounter)
}

// MinimockBlocksAccessedDone returns true if the count of the BlocksAccessed invocations corresponds
// the number of defined expectations
func (m *JIndexInfoMock) MinimockBlocksAccessedDone() bool {
	if m.BlocksAccessedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BlocksAccessedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BlocksAccessedMock.invocationsDone()
}

// MinimockBlocksAccessedInspect logs each unmet expectation
func (m *JIndexInfoMock) MinimockBlocksAccessedInspect() {
	for _, e := range m.BlocksAccessedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JIndexInfoMock.BlocksAccessed")
		}
	}

	afterBlocksAccessedCounter := mm_atomic.LoadUint64(&m.afterBlocksAccessedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BlocksAccessedMock.defaultExpectation != nil && afterBlocksAccessedCounter < 1 {
		m.t.Error("Expected call to JIndexInfoMock.BlocksAccessed")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBlocksAccessed != nil && afterBlocksAccessedCounter < 1 {
		m.t.Error("Expected call to JIndexInfoMock.BlocksAccessed")
	}

	if !m.BlocksAccessedMock.invocationsDone() && afterBlocksAccessedCounter > 0 {
		m.t.Errorf("Expected %d calls to JIndexInfoMock.BlocksAccessed but found %d calls",
			mm_atomic.LoadUint64(&m.BlocksAccessedMock.expectedInvocations), afterBlocksAccessedCounter)
	}
}

type mJIndexInfoMockOpen struct {
	optional           bool
	mock               *JIndexInfoMock
	defaultExpectation *JIndexInfoMockOpenExpectation
	expectations       []*JIndexInfoMockOpenExpectation

	expectedInvocations uint64
}

// JIndexInfoMockOpenExpectation specifies expectation struct of the jIndexInfo.Open
type JIndexInfoMockOpenExpectation struct {
	mock *JIndexInfoMock

	results *JIndexInfoMockOpenResults
	Counter uint64
}

// JIndexInfoMockOpenResults contains results of the jIndexInfo.Open
type JIndexInfoMockOpenResults struct {
	i1  indexes.Index
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOpen *mJIndexInfoMockOpen) Optional() *mJIndexInfoMockOpen {
	mmOpen.optional = true
	return mmOpen
}

// Expect sets up expected params for jIndexInfo.Open
func (mmOpen *mJIndexInfoMockOpen) Expect() *mJIndexInfoMockOpen {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("JIndexInfoMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &JIndexInfoMockOpenExpectation{}
	}

	return mmOpen
}

// Inspect accepts an inspector function that has same arguments as the jIndexInfo.Open
func (mmOpen *mJIndexInfoMockOpen) Inspect(f func()) *mJIndexInfoMockOpen {
	if mmOpen.mock.inspectFuncOpen != nil {
		mmOpen.mock.t.Fatalf("Inspect function is already set for JIndexInfoMock.Open")
	}

	mmOpen.mock.inspectFuncOpen = f

	return mmOpen
}

// Return sets up results that will be returned by jIndexInfo.Open
func (mmOpen *mJIndexInfoMockOpen) Return(i1 indexes.Index, err error) *JIndexInfoMock {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("JIndexInfoMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &JIndexInfoMockOpenExpectation{mock: mmOpen.mock}
	}
	mmOpen.defaultExpectation.results = &JIndexInfoMockOpenResults{i1, err}
	return mmOpen.mock
}

// Set uses given function f to mock the jIndexInfo.Open method
func (mmOpen *mJIndexInfoMockOpen) Set(f func() (i1 indexes.Index, err error)) *JIndexInfoMock {
	if mmOpen.defaultExpectation != nil {
		mmOpen.mock.t.Fatalf("Default expectation is already set for the jIndexInfo.Open method")
	}

	if len(mmOpen.expectations) > 0 {
		mmOpen.mock.t.Fatalf("Some expectations are already set for the jIndexInfo.Open method")
	}

	mmOpen.mock.funcOpen = f
	return mmOpen.mock
}

// Times sets number of times jIndexInfo.Open should be invoked
func (mmOpen *mJIndexInfoMockOpen) Times(n uint64) *mJIndexInfoMockOpen {
	if n == 0 {
		mmOpen.mock.t.Fatalf("Times of JIndexInfoMock.Open mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOpen.expectedInvocations, n)
	return mmOpen
}

func (mmOpen *mJIndexInfoMockOpen) invocationsDone() bool {
	if len(mmOpen.expectations) == 0 && mmOpen.defaultExpectation == nil && mmOpen.mock.funcOpen == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOpen.mock.afterOpenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOpen.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Open implements jIndexInfo
func (mmOpen *JIndexInfoMock) Open() (i1 indexes.Index, err error) {
	mm_atomic.AddUint64(&mmOpen.beforeOpenCounter, 1)
	defer mm_atomic.AddUint64(&mmOpen.afterOpenCounter, 1)

	if mmOpen.inspectFuncOpen != nil {
		mmOpen.inspectFuncOpen()
	}

	if mmOpen.OpenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOpen.OpenMock.defaultExpectation.Counter, 1)

		mm_results := mmOpen.OpenMock.defaultExpectation.results
		if mm_results == nil {
			mmOpen.t.Fatal("No results are set for the JIndexInfoMock.Open")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmOpen.funcOpen != nil {
		return mmOpen.funcOpen()
	}
	mmOpen.t.Fatalf("Unexpected call to JIndexInfoMock.Open.")
	return
}

// OpenAfterCounter returns a count of finished JIndexInfoMock.Open invocations
func (mmOpen *JIndexInfoMock) OpenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.afterOpenCounter)
}

// OpenBeforeCounter returns a count of JIndexInfoMock.Open invocations
func (mmOpen *JIndexInfoMock) OpenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.beforeOpenCounter)
}

// MinimockOpenDone returns true if the count of the Open invocations corresponds
// the number of defined expectations
func (m *JIndexInfoMock) MinimockOpenDone() bool {
	if m.OpenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OpenMock.invocationsDone()
}

// MinimockOpenInspect logs each unmet expectation
func (m *JIndexInfoMock) MinimockOpenInspect() {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JIndexInfoMock.Open")
		}
	}

	afterOpenCounter := mm_atomic.LoadUint64(&m.afterOpenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && afterOpenCounter < 1 {
		m.t.Error("Expected call to JIndexInfoMock.Open")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && afterOpenCounter < 1 {
		m.t.Error("Expected call to JIndexInfoMock.Open")
	}

	if !m.OpenMock.invocationsDone() && afterOpenCounter > 0 {
		m.t.Errorf("Expected %d calls to JIndexInfoMock.Open but found %d calls",
			mm_atomic.LoadUint64(&m.OpenMock.expectedInvocations), afterOpenCounter)
	}
}

type mJIndexInfoMockRecords struct {
	optional           bool
	mock               *JIndexInfoMock
	defaultExpectation *JIndexInfoMockRecordsExpectation
	expectations       []*JIndexInfoMockRecordsExpectation

	expectedInvocations uint64
}

// JIndexInfoMockRecordsExpectation specifies expectation struct of the jIndexInfo.Records
type JIndexInfoMockRecordsExpectation struct {
	mock *JIndexInfoMock

	results *JIndexInfoMockRecordsResults
	Counter uint64
}

// JIndexInfoMockRecordsResults contains results of the jIndexInfo.Records
type JIndexInfoMockRecordsResults struct {
	i1 int64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRecords *mJIndexInfoMockRecords) Optional() *mJIndexInfoMockRecords {
	mmRecords.optional = true
	return mmRecords
}

// Expect sets up expected params for jIndexInfo.Records
func (mmRecords *mJIndexInfoMockRecords) Expect() *mJIndexInfoMockRecords {
	if mmRecords.mock.funcRecords != nil {
		mmRecords.mock.t.Fatalf("JIndexInfoMock.Records mock is already set by Set")
	}

	if mmRecords.defaultExpectation == nil {
		mmRecords.defaultExpectation = &JIndexInfoMockRecordsExpectation{}
	}

	return mmRecords
}

// Inspect accepts an inspector function that has same arguments as the jIndexInfo.Records
func (mmRecords *mJIndexInfoMockRecords) Inspect(f func()) *mJIndexInfoMockRecords {
	if mmRecords.mock.inspectFuncRecords != nil {
		mmRecords.mock.t.Fatalf("Inspect function is already set for JIndexInfoMock.Records")
	}

	mmRecords.mock.inspectFuncRecords = f

	return mmRecords
}

// Return sets up results that will be returned by jIndexInfo.Records
func (mmRecords *mJIndexInfoMockRecords) Return(i1 int64) *JIndexInfoMock {
	if mmRecords.mock.funcRecords != nil {
		mmRecords.mock.t.Fatalf("JIndexInfoMock.Records mock is already set by Set")
	}

	if mmRecords.defaultExpectation == nil {
		mmRecords.defaultExpectation = &JIndexInfoMockRecordsExpectation{mock: mmRecords.mock}
	}
	mmRecords.defaultExpectation.results = &JIndexInfoMockRecordsResults{i1}
	return mmRecords.mock
}

// Set uses given function f to mock the jIndexInfo.Records method
func (mmRecords *mJIndexInfoMockRecords) Set(f func() (i1 int64)) *JIndexInfoMock {
	if mmRecords.defaultExpectation != nil {
		mmRecords.mock.t.Fatalf("Default expectation is already set for the jIndexInfo.Records method")
	}

	if len(mmRecords.expectations) > 0 {
		mmRecords.mock.t.Fatalf("Some expectations are already set for the jIndexInfo.Records method")
	}

	mmRecords.mock.funcRecords = f
	return mmRecords.mock
}

// Times sets number of times jIndexInfo.Records should be invoked
func (mmRecords *mJIndexInfoMockRecords) Times(n uint64) *mJIndexInfoMockRecords {
	if n == 0 {
		mmRecords.mock.t.Fatalf("Times of JIndexInfoMock.Records mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRecords.expectedInvocations, n)
	return mmRecords
}

func (mmRecords *mJIndexInfoMockRecords) invocationsDone() bool {
	if len(mmRecords.expectations) == 0 && mmRecords.defaultExpectation == nil && mmRecords.mock.funcRecords == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRecords.mock.afterRecordsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRecords.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Records implements jIndexInfo
func (mmRecords *JIndexInfoMock) Records() (i1 int64) {
	mm_atomic.AddUint64(&mmRecords.beforeRecordsCounter, 1)
	defer mm_atomic.AddUint64(&mmRecords.afterRecordsCounter, 1)

	if mmRecords.inspectFuncRecords != nil {
		mmRecords.inspectFuncRecords()
	}

	if mmRecords.RecordsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecords.RecordsMock.defaultExpectation.Counter, 1)

		mm_results := mmRecords.RecordsMock.defaultExpectation.results
		if mm_results == nil {
			mmRecords.t.Fatal("No results are set for the JIndexInfoMock.Records")
		}
		return (*mm_results).i1
	}
	if mmRecords.funcRecords != nil {
		return mmRecords.funcRecords()
	}
	mmRecords.t.Fatalf("Unexpected call to JIndexInfoMock.Records.")
	return
}

// RecordsAfterCounter returns a count of finished JIndexInfoMock.Records invocations
func (mmRecords *JIndexInfoMock) RecordsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecords.afterRecordsCounter)
}

// RecordsBeforeCounter returns a count of JIndexInfoMock.Records invocations
func (mmRecords *JIndexInfoMock) RecordsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecords.beforeRecordsCounter)
}

// MinimockRecordsDone returns true if the count of the Records invocations corresponds
// the number of defined expectations
func (m *JIndexInfoMock) MinimockRecordsDone() bool {
	if m.RecordsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RecordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RecordsMock.invocationsDone()
}

// MinimockRecordsInspect logs each unmet expectation
func (m *JIndexInfoMock) MinimockRecordsInspect() {
	for _, e := range m.RecordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JIndexInfoMock.Records")
		}
	}

	afterRecordsCounter := mm_atomic.LoadUint64(&m.afterRecordsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RecordsMock.defaultExpectation != nil && afterRecordsCounter < 1 {
		m.t.Error("Expected call to JIndexInfoMock.Records")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecords != nil && afterRecordsCounter < 1 {
		m.t.Error("Expected call to JIndexInfoMock.Records")
	}

	if !m.RecordsMock.invocationsDone() && afterRecordsCounter > 0 {
		m.t.Errorf("Expected %d calls to JIndexInfoMock.Records but found %d calls",
			mm_atomic.LoadUint64(&m.RecordsMock.expectedInvocations), afterRecordsCounter)
	}
}

type mJIndexInfoMockString struct {
	optional           bool
	mock               *JIndexInfoMock
	defaultExpectation *JIndexInfoMockStringExpectation
	expectations       []*JIndexInfoMockStringExpectation

	expectedInvocations uint64
}

// JIndexInfoMockStringExpectation specifies expectation struct of the jIndexInfo.String
type JIndexInfoMockStringExpectation struct {
	mock *JIndexInfoMock

	results *JIndexInfoMockStringResults
	Counter uint64
}

// JIndexInfoMockStringResults contains results of the jIndexInfo.String
type JIndexInfoMockStringResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmString *mJIndexInfoMockString) Optional() *mJIndexInfoMockString {
	mmString.optional = true
	return mmString
}

// Expect sets up expected params for jIndexInfo.String
func (mmString *mJIndexInfoMockString) Expect() *mJIndexInfoMockString {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("JIndexInfoMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &JIndexInfoMockStringExpectation{}
	}

	return mmString
}

// Inspect accepts an inspector function that has same arguments as the jIndexInfo.String
func (mmString *mJIndexInfoMockString) Inspect(f func()) *mJIndexInfoMockString {
	if mmString.mock.inspectFuncString != nil {
		mmString.mock.t.Fatalf("Inspect function is already set for JIndexInfoMock.String")
	}

	mmString.mock.inspectFuncString = f

	return mmString
}

// Return sets up results that will be returned by jIndexInfo.String
func (mmString *mJIndexInfoMockString) Return(s1 string) *JIndexInfoMock {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("JIndexInfoMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &JIndexInfoMockStringExpectation{mock: mmString.mock}
	}
	mmString.defaultExpectation.results = &JIndexInfoMockStringResults{s1}
	return mmString.mock
}

// Set uses given function f to mock the jIndexInfo.String method
func (mmString *mJIndexInfoMockString) Set(f func() (s1 string)) *JIndexInfoMock {
	if mmString.defaultExpectation != nil {
		mmString.mock.t.Fatalf("Default expectation is already set for the jIndexInfo.String method")
	}

	if len(mmString.expectations) > 0 {
		mmString.mock.t.Fatalf("Some expectations are already set for the jIndexInfo.String method")
	}

	mmString.mock.funcString = f
	return mmString.mock
}

// Times sets number of times jIndexInfo.String should be invoked
func (mmString *mJIndexInfoMockString) Times(n uint64) *mJIndexInfoMockString {
	if n == 0 {
		mmString.mock.t.Fatalf("Times of JIndexInfoMock.String mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmString.expectedInvocations, n)
	return mmString
}

func (mmString *mJIndexInfoMockString) invocationsDone() bool {
	if len(mmString.expectations) == 0 && mmString.defaultExpectation == nil && mmString.mock.funcString == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmString.mock.afterStringCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmString.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// String implements jIndexInfo
func (mmString *JIndexInfoMock) String() (s1 string) {
	mm_atomic.AddUint64(&mmString.beforeStringCounter, 1)
	defer mm_atomic.AddUint64(&mmString.afterStringCounter, 1)

	if mmString.inspectFuncString != nil {
		mmString.inspectFuncString()
	}

	if mmString.StringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmString.StringMock.defaultExpectation.Counter, 1)

		mm_results := mmString.StringMock.defaultExpectation.results
		if mm_results == nil {
			mmString.t.Fatal("No results are set for the JIndexInfoMock.String")
		}
		return (*mm_results).s1
	}
	if mmString.funcString != nil {
		return mmString.funcString()
	}
	mmString.t.Fatalf("Unexpected call to JIndexInfoMock.String.")
	return
}

// StringAfterCounter returns a count of finished JIndexInfoMock.String invocations
func (mmString *JIndexInfoMock) StringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.afterStringCounter)
}

// StringBeforeCounter returns a count of JIndexInfoMock.String invocations
func (mmString *JIndexInfoMock) StringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.beforeStringCounter)
}

// MinimockStringDone returns true if the count of the String invocations corresponds
// the number of defined expectations
func (m *JIndexInfoMock) MinimockStringDone() bool {
	if m.StringMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StringMock.invocationsDone()
}

// MinimockStringInspect logs each unmet expectation
func (m *JIndexInfoMock) MinimockStringInspect() {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JIndexInfoMock.String")
		}
	}

	afterStringCounter := mm_atomic.LoadUint64(&m.afterStringCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && afterStringCounter < 1 {
		m.t.Error("Expected call to JIndexInfoMock.String")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && afterStringCounter < 1 {
		m.t.Error("Expected call to JIndexInfoMock.String")
	}

	if !m.StringMock.invocationsDone() && afterStringCounter > 0 {
		m.t.Errorf("Expected %d calls to JIndexInfoMock.String but found %d calls",
			mm_atomic.LoadUint64(&m.StringMock.expectedInvocations), afterStringCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *JIndexInfoMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBlocksAccessedInspect()

			m.MinimockOpenInspect()

			m.MinimockRecordsInspect()

			m.MinimockStringInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *JIndexInfoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *JIndexInfoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBlocksAccessedDone() &&
		m.MinimockOpenDone() &&
		m.MinimockRecordsDone() &&
		m.MinimockStringDone()
}
