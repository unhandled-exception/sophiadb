package indexplanner

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/unhandled-exception/sophiadb/internal/pkg/indexplanner.jIndexInfo -o ./mock_jindex_info_test.go -n JIndexInfoMock

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/unhandled-exception/sophiadb/internal/pkg/indexes"
)

// JIndexInfoMock implements jIndexInfo
type JIndexInfoMock struct {
	t minimock.Tester

	funcBlocksAccessed          func() (i1 int64)
	inspectFuncBlocksAccessed   func()
	afterBlocksAccessedCounter  uint64
	beforeBlocksAccessedCounter uint64
	BlocksAccessedMock          mJIndexInfoMockBlocksAccessed

	funcOpen          func() (i1 indexes.Index, err error)
	inspectFuncOpen   func()
	afterOpenCounter  uint64
	beforeOpenCounter uint64
	OpenMock          mJIndexInfoMockOpen

	funcRecords          func() (i1 int64)
	inspectFuncRecords   func()
	afterRecordsCounter  uint64
	beforeRecordsCounter uint64
	RecordsMock          mJIndexInfoMockRecords

	funcString          func() (s1 string)
	inspectFuncString   func()
	afterStringCounter  uint64
	beforeStringCounter uint64
	StringMock          mJIndexInfoMockString
}

// NewJIndexInfoMock returns a mock for jIndexInfo
func NewJIndexInfoMock(t minimock.Tester) *JIndexInfoMock {
	m := &JIndexInfoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BlocksAccessedMock = mJIndexInfoMockBlocksAccessed{mock: m}

	m.OpenMock = mJIndexInfoMockOpen{mock: m}

	m.RecordsMock = mJIndexInfoMockRecords{mock: m}

	m.StringMock = mJIndexInfoMockString{mock: m}

	return m
}

type mJIndexInfoMockBlocksAccessed struct {
	mock               *JIndexInfoMock
	defaultExpectation *JIndexInfoMockBlocksAccessedExpectation
	expectations       []*JIndexInfoMockBlocksAccessedExpectation
}

// JIndexInfoMockBlocksAccessedExpectation specifies expectation struct of the jIndexInfo.BlocksAccessed
type JIndexInfoMockBlocksAccessedExpectation struct {
	mock *JIndexInfoMock

	results *JIndexInfoMockBlocksAccessedResults
	Counter uint64
}

// JIndexInfoMockBlocksAccessedResults contains results of the jIndexInfo.BlocksAccessed
type JIndexInfoMockBlocksAccessedResults struct {
	i1 int64
}

// Expect sets up expected params for jIndexInfo.BlocksAccessed
func (mmBlocksAccessed *mJIndexInfoMockBlocksAccessed) Expect() *mJIndexInfoMockBlocksAccessed {
	if mmBlocksAccessed.mock.funcBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("JIndexInfoMock.BlocksAccessed mock is already set by Set")
	}

	if mmBlocksAccessed.defaultExpectation == nil {
		mmBlocksAccessed.defaultExpectation = &JIndexInfoMockBlocksAccessedExpectation{}
	}

	return mmBlocksAccessed
}

// Inspect accepts an inspector function that has same arguments as the jIndexInfo.BlocksAccessed
func (mmBlocksAccessed *mJIndexInfoMockBlocksAccessed) Inspect(f func()) *mJIndexInfoMockBlocksAccessed {
	if mmBlocksAccessed.mock.inspectFuncBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("Inspect function is already set for JIndexInfoMock.BlocksAccessed")
	}

	mmBlocksAccessed.mock.inspectFuncBlocksAccessed = f

	return mmBlocksAccessed
}

// Return sets up results that will be returned by jIndexInfo.BlocksAccessed
func (mmBlocksAccessed *mJIndexInfoMockBlocksAccessed) Return(i1 int64) *JIndexInfoMock {
	if mmBlocksAccessed.mock.funcBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("JIndexInfoMock.BlocksAccessed mock is already set by Set")
	}

	if mmBlocksAccessed.defaultExpectation == nil {
		mmBlocksAccessed.defaultExpectation = &JIndexInfoMockBlocksAccessedExpectation{mock: mmBlocksAccessed.mock}
	}
	mmBlocksAccessed.defaultExpectation.results = &JIndexInfoMockBlocksAccessedResults{i1}
	return mmBlocksAccessed.mock
}

//Set uses given function f to mock the jIndexInfo.BlocksAccessed method
func (mmBlocksAccessed *mJIndexInfoMockBlocksAccessed) Set(f func() (i1 int64)) *JIndexInfoMock {
	if mmBlocksAccessed.defaultExpectation != nil {
		mmBlocksAccessed.mock.t.Fatalf("Default expectation is already set for the jIndexInfo.BlocksAccessed method")
	}

	if len(mmBlocksAccessed.expectations) > 0 {
		mmBlocksAccessed.mock.t.Fatalf("Some expectations are already set for the jIndexInfo.BlocksAccessed method")
	}

	mmBlocksAccessed.mock.funcBlocksAccessed = f
	return mmBlocksAccessed.mock
}

// BlocksAccessed implements jIndexInfo
func (mmBlocksAccessed *JIndexInfoMock) BlocksAccessed() (i1 int64) {
	mm_atomic.AddUint64(&mmBlocksAccessed.beforeBlocksAccessedCounter, 1)
	defer mm_atomic.AddUint64(&mmBlocksAccessed.afterBlocksAccessedCounter, 1)

	if mmBlocksAccessed.inspectFuncBlocksAccessed != nil {
		mmBlocksAccessed.inspectFuncBlocksAccessed()
	}

	if mmBlocksAccessed.BlocksAccessedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBlocksAccessed.BlocksAccessedMock.defaultExpectation.Counter, 1)

		mm_results := mmBlocksAccessed.BlocksAccessedMock.defaultExpectation.results
		if mm_results == nil {
			mmBlocksAccessed.t.Fatal("No results are set for the JIndexInfoMock.BlocksAccessed")
		}
		return (*mm_results).i1
	}
	if mmBlocksAccessed.funcBlocksAccessed != nil {
		return mmBlocksAccessed.funcBlocksAccessed()
	}
	mmBlocksAccessed.t.Fatalf("Unexpected call to JIndexInfoMock.BlocksAccessed.")
	return
}

// BlocksAccessedAfterCounter returns a count of finished JIndexInfoMock.BlocksAccessed invocations
func (mmBlocksAccessed *JIndexInfoMock) BlocksAccessedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBlocksAccessed.afterBlocksAccessedCounter)
}

// BlocksAccessedBeforeCounter returns a count of JIndexInfoMock.BlocksAccessed invocations
func (mmBlocksAccessed *JIndexInfoMock) BlocksAccessedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBlocksAccessed.beforeBlocksAccessedCounter)
}

// MinimockBlocksAccessedDone returns true if the count of the BlocksAccessed invocations corresponds
// the number of defined expectations
func (m *JIndexInfoMock) MinimockBlocksAccessedDone() bool {
	for _, e := range m.BlocksAccessedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BlocksAccessedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBlocksAccessedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBlocksAccessed != nil && mm_atomic.LoadUint64(&m.afterBlocksAccessedCounter) < 1 {
		return false
	}
	return true
}

// MinimockBlocksAccessedInspect logs each unmet expectation
func (m *JIndexInfoMock) MinimockBlocksAccessedInspect() {
	for _, e := range m.BlocksAccessedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JIndexInfoMock.BlocksAccessed")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BlocksAccessedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBlocksAccessedCounter) < 1 {
		m.t.Error("Expected call to JIndexInfoMock.BlocksAccessed")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBlocksAccessed != nil && mm_atomic.LoadUint64(&m.afterBlocksAccessedCounter) < 1 {
		m.t.Error("Expected call to JIndexInfoMock.BlocksAccessed")
	}
}

type mJIndexInfoMockOpen struct {
	mock               *JIndexInfoMock
	defaultExpectation *JIndexInfoMockOpenExpectation
	expectations       []*JIndexInfoMockOpenExpectation
}

// JIndexInfoMockOpenExpectation specifies expectation struct of the jIndexInfo.Open
type JIndexInfoMockOpenExpectation struct {
	mock *JIndexInfoMock

	results *JIndexInfoMockOpenResults
	Counter uint64
}

// JIndexInfoMockOpenResults contains results of the jIndexInfo.Open
type JIndexInfoMockOpenResults struct {
	i1  indexes.Index
	err error
}

// Expect sets up expected params for jIndexInfo.Open
func (mmOpen *mJIndexInfoMockOpen) Expect() *mJIndexInfoMockOpen {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("JIndexInfoMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &JIndexInfoMockOpenExpectation{}
	}

	return mmOpen
}

// Inspect accepts an inspector function that has same arguments as the jIndexInfo.Open
func (mmOpen *mJIndexInfoMockOpen) Inspect(f func()) *mJIndexInfoMockOpen {
	if mmOpen.mock.inspectFuncOpen != nil {
		mmOpen.mock.t.Fatalf("Inspect function is already set for JIndexInfoMock.Open")
	}

	mmOpen.mock.inspectFuncOpen = f

	return mmOpen
}

// Return sets up results that will be returned by jIndexInfo.Open
func (mmOpen *mJIndexInfoMockOpen) Return(i1 indexes.Index, err error) *JIndexInfoMock {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("JIndexInfoMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &JIndexInfoMockOpenExpectation{mock: mmOpen.mock}
	}
	mmOpen.defaultExpectation.results = &JIndexInfoMockOpenResults{i1, err}
	return mmOpen.mock
}

//Set uses given function f to mock the jIndexInfo.Open method
func (mmOpen *mJIndexInfoMockOpen) Set(f func() (i1 indexes.Index, err error)) *JIndexInfoMock {
	if mmOpen.defaultExpectation != nil {
		mmOpen.mock.t.Fatalf("Default expectation is already set for the jIndexInfo.Open method")
	}

	if len(mmOpen.expectations) > 0 {
		mmOpen.mock.t.Fatalf("Some expectations are already set for the jIndexInfo.Open method")
	}

	mmOpen.mock.funcOpen = f
	return mmOpen.mock
}

// Open implements jIndexInfo
func (mmOpen *JIndexInfoMock) Open() (i1 indexes.Index, err error) {
	mm_atomic.AddUint64(&mmOpen.beforeOpenCounter, 1)
	defer mm_atomic.AddUint64(&mmOpen.afterOpenCounter, 1)

	if mmOpen.inspectFuncOpen != nil {
		mmOpen.inspectFuncOpen()
	}

	if mmOpen.OpenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOpen.OpenMock.defaultExpectation.Counter, 1)

		mm_results := mmOpen.OpenMock.defaultExpectation.results
		if mm_results == nil {
			mmOpen.t.Fatal("No results are set for the JIndexInfoMock.Open")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmOpen.funcOpen != nil {
		return mmOpen.funcOpen()
	}
	mmOpen.t.Fatalf("Unexpected call to JIndexInfoMock.Open.")
	return
}

// OpenAfterCounter returns a count of finished JIndexInfoMock.Open invocations
func (mmOpen *JIndexInfoMock) OpenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.afterOpenCounter)
}

// OpenBeforeCounter returns a count of JIndexInfoMock.Open invocations
func (mmOpen *JIndexInfoMock) OpenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.beforeOpenCounter)
}

// MinimockOpenDone returns true if the count of the Open invocations corresponds
// the number of defined expectations
func (m *JIndexInfoMock) MinimockOpenDone() bool {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	return true
}

// MinimockOpenInspect logs each unmet expectation
func (m *JIndexInfoMock) MinimockOpenInspect() {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JIndexInfoMock.Open")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		m.t.Error("Expected call to JIndexInfoMock.Open")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		m.t.Error("Expected call to JIndexInfoMock.Open")
	}
}

type mJIndexInfoMockRecords struct {
	mock               *JIndexInfoMock
	defaultExpectation *JIndexInfoMockRecordsExpectation
	expectations       []*JIndexInfoMockRecordsExpectation
}

// JIndexInfoMockRecordsExpectation specifies expectation struct of the jIndexInfo.Records
type JIndexInfoMockRecordsExpectation struct {
	mock *JIndexInfoMock

	results *JIndexInfoMockRecordsResults
	Counter uint64
}

// JIndexInfoMockRecordsResults contains results of the jIndexInfo.Records
type JIndexInfoMockRecordsResults struct {
	i1 int64
}

// Expect sets up expected params for jIndexInfo.Records
func (mmRecords *mJIndexInfoMockRecords) Expect() *mJIndexInfoMockRecords {
	if mmRecords.mock.funcRecords != nil {
		mmRecords.mock.t.Fatalf("JIndexInfoMock.Records mock is already set by Set")
	}

	if mmRecords.defaultExpectation == nil {
		mmRecords.defaultExpectation = &JIndexInfoMockRecordsExpectation{}
	}

	return mmRecords
}

// Inspect accepts an inspector function that has same arguments as the jIndexInfo.Records
func (mmRecords *mJIndexInfoMockRecords) Inspect(f func()) *mJIndexInfoMockRecords {
	if mmRecords.mock.inspectFuncRecords != nil {
		mmRecords.mock.t.Fatalf("Inspect function is already set for JIndexInfoMock.Records")
	}

	mmRecords.mock.inspectFuncRecords = f

	return mmRecords
}

// Return sets up results that will be returned by jIndexInfo.Records
func (mmRecords *mJIndexInfoMockRecords) Return(i1 int64) *JIndexInfoMock {
	if mmRecords.mock.funcRecords != nil {
		mmRecords.mock.t.Fatalf("JIndexInfoMock.Records mock is already set by Set")
	}

	if mmRecords.defaultExpectation == nil {
		mmRecords.defaultExpectation = &JIndexInfoMockRecordsExpectation{mock: mmRecords.mock}
	}
	mmRecords.defaultExpectation.results = &JIndexInfoMockRecordsResults{i1}
	return mmRecords.mock
}

//Set uses given function f to mock the jIndexInfo.Records method
func (mmRecords *mJIndexInfoMockRecords) Set(f func() (i1 int64)) *JIndexInfoMock {
	if mmRecords.defaultExpectation != nil {
		mmRecords.mock.t.Fatalf("Default expectation is already set for the jIndexInfo.Records method")
	}

	if len(mmRecords.expectations) > 0 {
		mmRecords.mock.t.Fatalf("Some expectations are already set for the jIndexInfo.Records method")
	}

	mmRecords.mock.funcRecords = f
	return mmRecords.mock
}

// Records implements jIndexInfo
func (mmRecords *JIndexInfoMock) Records() (i1 int64) {
	mm_atomic.AddUint64(&mmRecords.beforeRecordsCounter, 1)
	defer mm_atomic.AddUint64(&mmRecords.afterRecordsCounter, 1)

	if mmRecords.inspectFuncRecords != nil {
		mmRecords.inspectFuncRecords()
	}

	if mmRecords.RecordsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecords.RecordsMock.defaultExpectation.Counter, 1)

		mm_results := mmRecords.RecordsMock.defaultExpectation.results
		if mm_results == nil {
			mmRecords.t.Fatal("No results are set for the JIndexInfoMock.Records")
		}
		return (*mm_results).i1
	}
	if mmRecords.funcRecords != nil {
		return mmRecords.funcRecords()
	}
	mmRecords.t.Fatalf("Unexpected call to JIndexInfoMock.Records.")
	return
}

// RecordsAfterCounter returns a count of finished JIndexInfoMock.Records invocations
func (mmRecords *JIndexInfoMock) RecordsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecords.afterRecordsCounter)
}

// RecordsBeforeCounter returns a count of JIndexInfoMock.Records invocations
func (mmRecords *JIndexInfoMock) RecordsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecords.beforeRecordsCounter)
}

// MinimockRecordsDone returns true if the count of the Records invocations corresponds
// the number of defined expectations
func (m *JIndexInfoMock) MinimockRecordsDone() bool {
	for _, e := range m.RecordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecordsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecordsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecords != nil && mm_atomic.LoadUint64(&m.afterRecordsCounter) < 1 {
		return false
	}
	return true
}

// MinimockRecordsInspect logs each unmet expectation
func (m *JIndexInfoMock) MinimockRecordsInspect() {
	for _, e := range m.RecordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JIndexInfoMock.Records")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecordsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecordsCounter) < 1 {
		m.t.Error("Expected call to JIndexInfoMock.Records")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecords != nil && mm_atomic.LoadUint64(&m.afterRecordsCounter) < 1 {
		m.t.Error("Expected call to JIndexInfoMock.Records")
	}
}

type mJIndexInfoMockString struct {
	mock               *JIndexInfoMock
	defaultExpectation *JIndexInfoMockStringExpectation
	expectations       []*JIndexInfoMockStringExpectation
}

// JIndexInfoMockStringExpectation specifies expectation struct of the jIndexInfo.String
type JIndexInfoMockStringExpectation struct {
	mock *JIndexInfoMock

	results *JIndexInfoMockStringResults
	Counter uint64
}

// JIndexInfoMockStringResults contains results of the jIndexInfo.String
type JIndexInfoMockStringResults struct {
	s1 string
}

// Expect sets up expected params for jIndexInfo.String
func (mmString *mJIndexInfoMockString) Expect() *mJIndexInfoMockString {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("JIndexInfoMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &JIndexInfoMockStringExpectation{}
	}

	return mmString
}

// Inspect accepts an inspector function that has same arguments as the jIndexInfo.String
func (mmString *mJIndexInfoMockString) Inspect(f func()) *mJIndexInfoMockString {
	if mmString.mock.inspectFuncString != nil {
		mmString.mock.t.Fatalf("Inspect function is already set for JIndexInfoMock.String")
	}

	mmString.mock.inspectFuncString = f

	return mmString
}

// Return sets up results that will be returned by jIndexInfo.String
func (mmString *mJIndexInfoMockString) Return(s1 string) *JIndexInfoMock {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("JIndexInfoMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &JIndexInfoMockStringExpectation{mock: mmString.mock}
	}
	mmString.defaultExpectation.results = &JIndexInfoMockStringResults{s1}
	return mmString.mock
}

//Set uses given function f to mock the jIndexInfo.String method
func (mmString *mJIndexInfoMockString) Set(f func() (s1 string)) *JIndexInfoMock {
	if mmString.defaultExpectation != nil {
		mmString.mock.t.Fatalf("Default expectation is already set for the jIndexInfo.String method")
	}

	if len(mmString.expectations) > 0 {
		mmString.mock.t.Fatalf("Some expectations are already set for the jIndexInfo.String method")
	}

	mmString.mock.funcString = f
	return mmString.mock
}

// String implements jIndexInfo
func (mmString *JIndexInfoMock) String() (s1 string) {
	mm_atomic.AddUint64(&mmString.beforeStringCounter, 1)
	defer mm_atomic.AddUint64(&mmString.afterStringCounter, 1)

	if mmString.inspectFuncString != nil {
		mmString.inspectFuncString()
	}

	if mmString.StringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmString.StringMock.defaultExpectation.Counter, 1)

		mm_results := mmString.StringMock.defaultExpectation.results
		if mm_results == nil {
			mmString.t.Fatal("No results are set for the JIndexInfoMock.String")
		}
		return (*mm_results).s1
	}
	if mmString.funcString != nil {
		return mmString.funcString()
	}
	mmString.t.Fatalf("Unexpected call to JIndexInfoMock.String.")
	return
}

// StringAfterCounter returns a count of finished JIndexInfoMock.String invocations
func (mmString *JIndexInfoMock) StringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.afterStringCounter)
}

// StringBeforeCounter returns a count of JIndexInfoMock.String invocations
func (mmString *JIndexInfoMock) StringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.beforeStringCounter)
}

// MinimockStringDone returns true if the count of the String invocations corresponds
// the number of defined expectations
func (m *JIndexInfoMock) MinimockStringDone() bool {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockStringInspect logs each unmet expectation
func (m *JIndexInfoMock) MinimockStringInspect() {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JIndexInfoMock.String")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		m.t.Error("Expected call to JIndexInfoMock.String")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		m.t.Error("Expected call to JIndexInfoMock.String")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *JIndexInfoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBlocksAccessedInspect()

		m.MinimockOpenInspect()

		m.MinimockRecordsInspect()

		m.MinimockStringInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *JIndexInfoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *JIndexInfoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBlocksAccessedDone() &&
		m.MinimockOpenDone() &&
		m.MinimockRecordsDone() &&
		m.MinimockStringDone()
}
