// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package indexplanner

//go:generate minimock -i github.com/unhandled-exception/sophiadb/internal/pkg/indexplanner.jPlan -o mock_jplan_test.go -n JPlanMock -p indexplanner

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/unhandled-exception/sophiadb/internal/pkg/records"
	"github.com/unhandled-exception/sophiadb/internal/pkg/scan"
)

// JPlanMock implements jPlan
type JPlanMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBlocksAccessed          func() (i1 int64)
	inspectFuncBlocksAccessed   func()
	afterBlocksAccessedCounter  uint64
	beforeBlocksAccessedCounter uint64
	BlocksAccessedMock          mJPlanMockBlocksAccessed

	funcDistinctValues          func(fieldName string) (i1 int64, b1 bool)
	inspectFuncDistinctValues   func(fieldName string)
	afterDistinctValuesCounter  uint64
	beforeDistinctValuesCounter uint64
	DistinctValuesMock          mJPlanMockDistinctValues

	funcOpen          func() (s1 scan.Scan, err error)
	inspectFuncOpen   func()
	afterOpenCounter  uint64
	beforeOpenCounter uint64
	OpenMock          mJPlanMockOpen

	funcRecords          func() (i1 int64)
	inspectFuncRecords   func()
	afterRecordsCounter  uint64
	beforeRecordsCounter uint64
	RecordsMock          mJPlanMockRecords

	funcSchema          func() (s1 records.Schema)
	inspectFuncSchema   func()
	afterSchemaCounter  uint64
	beforeSchemaCounter uint64
	SchemaMock          mJPlanMockSchema

	funcString          func() (s1 string)
	inspectFuncString   func()
	afterStringCounter  uint64
	beforeStringCounter uint64
	StringMock          mJPlanMockString
}

// NewJPlanMock returns a mock for jPlan
func NewJPlanMock(t minimock.Tester) *JPlanMock {
	m := &JPlanMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BlocksAccessedMock = mJPlanMockBlocksAccessed{mock: m}

	m.DistinctValuesMock = mJPlanMockDistinctValues{mock: m}
	m.DistinctValuesMock.callArgs = []*JPlanMockDistinctValuesParams{}

	m.OpenMock = mJPlanMockOpen{mock: m}

	m.RecordsMock = mJPlanMockRecords{mock: m}

	m.SchemaMock = mJPlanMockSchema{mock: m}

	m.StringMock = mJPlanMockString{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mJPlanMockBlocksAccessed struct {
	optional           bool
	mock               *JPlanMock
	defaultExpectation *JPlanMockBlocksAccessedExpectation
	expectations       []*JPlanMockBlocksAccessedExpectation

	expectedInvocations uint64
}

// JPlanMockBlocksAccessedExpectation specifies expectation struct of the jPlan.BlocksAccessed
type JPlanMockBlocksAccessedExpectation struct {
	mock *JPlanMock

	results *JPlanMockBlocksAccessedResults
	Counter uint64
}

// JPlanMockBlocksAccessedResults contains results of the jPlan.BlocksAccessed
type JPlanMockBlocksAccessedResults struct {
	i1 int64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBlocksAccessed *mJPlanMockBlocksAccessed) Optional() *mJPlanMockBlocksAccessed {
	mmBlocksAccessed.optional = true
	return mmBlocksAccessed
}

// Expect sets up expected params for jPlan.BlocksAccessed
func (mmBlocksAccessed *mJPlanMockBlocksAccessed) Expect() *mJPlanMockBlocksAccessed {
	if mmBlocksAccessed.mock.funcBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("JPlanMock.BlocksAccessed mock is already set by Set")
	}

	if mmBlocksAccessed.defaultExpectation == nil {
		mmBlocksAccessed.defaultExpectation = &JPlanMockBlocksAccessedExpectation{}
	}

	return mmBlocksAccessed
}

// Inspect accepts an inspector function that has same arguments as the jPlan.BlocksAccessed
func (mmBlocksAccessed *mJPlanMockBlocksAccessed) Inspect(f func()) *mJPlanMockBlocksAccessed {
	if mmBlocksAccessed.mock.inspectFuncBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("Inspect function is already set for JPlanMock.BlocksAccessed")
	}

	mmBlocksAccessed.mock.inspectFuncBlocksAccessed = f

	return mmBlocksAccessed
}

// Return sets up results that will be returned by jPlan.BlocksAccessed
func (mmBlocksAccessed *mJPlanMockBlocksAccessed) Return(i1 int64) *JPlanMock {
	if mmBlocksAccessed.mock.funcBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("JPlanMock.BlocksAccessed mock is already set by Set")
	}

	if mmBlocksAccessed.defaultExpectation == nil {
		mmBlocksAccessed.defaultExpectation = &JPlanMockBlocksAccessedExpectation{mock: mmBlocksAccessed.mock}
	}
	mmBlocksAccessed.defaultExpectation.results = &JPlanMockBlocksAccessedResults{i1}
	return mmBlocksAccessed.mock
}

// Set uses given function f to mock the jPlan.BlocksAccessed method
func (mmBlocksAccessed *mJPlanMockBlocksAccessed) Set(f func() (i1 int64)) *JPlanMock {
	if mmBlocksAccessed.defaultExpectation != nil {
		mmBlocksAccessed.mock.t.Fatalf("Default expectation is already set for the jPlan.BlocksAccessed method")
	}

	if len(mmBlocksAccessed.expectations) > 0 {
		mmBlocksAccessed.mock.t.Fatalf("Some expectations are already set for the jPlan.BlocksAccessed method")
	}

	mmBlocksAccessed.mock.funcBlocksAccessed = f
	return mmBlocksAccessed.mock
}

// Times sets number of times jPlan.BlocksAccessed should be invoked
func (mmBlocksAccessed *mJPlanMockBlocksAccessed) Times(n uint64) *mJPlanMockBlocksAccessed {
	if n == 0 {
		mmBlocksAccessed.mock.t.Fatalf("Times of JPlanMock.BlocksAccessed mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBlocksAccessed.expectedInvocations, n)
	return mmBlocksAccessed
}

func (mmBlocksAccessed *mJPlanMockBlocksAccessed) invocationsDone() bool {
	if len(mmBlocksAccessed.expectations) == 0 && mmBlocksAccessed.defaultExpectation == nil && mmBlocksAccessed.mock.funcBlocksAccessed == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBlocksAccessed.mock.afterBlocksAccessedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBlocksAccessed.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// BlocksAccessed implements jPlan
func (mmBlocksAccessed *JPlanMock) BlocksAccessed() (i1 int64) {
	mm_atomic.AddUint64(&mmBlocksAccessed.beforeBlocksAccessedCounter, 1)
	defer mm_atomic.AddUint64(&mmBlocksAccessed.afterBlocksAccessedCounter, 1)

	if mmBlocksAccessed.inspectFuncBlocksAccessed != nil {
		mmBlocksAccessed.inspectFuncBlocksAccessed()
	}

	if mmBlocksAccessed.BlocksAccessedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBlocksAccessed.BlocksAccessedMock.defaultExpectation.Counter, 1)

		mm_results := mmBlocksAccessed.BlocksAccessedMock.defaultExpectation.results
		if mm_results == nil {
			mmBlocksAccessed.t.Fatal("No results are set for the JPlanMock.BlocksAccessed")
		}
		return (*mm_results).i1
	}
	if mmBlocksAccessed.funcBlocksAccessed != nil {
		return mmBlocksAccessed.funcBlocksAccessed()
	}
	mmBlocksAccessed.t.Fatalf("Unexpected call to JPlanMock.BlocksAccessed.")
	return
}

// BlocksAccessedAfterCounter returns a count of finished JPlanMock.BlocksAccessed invocations
func (mmBlocksAccessed *JPlanMock) BlocksAccessedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBlocksAccessed.afterBlocksAccessedCounter)
}

// BlocksAccessedBeforeCounter returns a count of JPlanMock.BlocksAccessed invocations
func (mmBlocksAccessed *JPlanMock) BlocksAccessedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBlocksAccessed.beforeBlocksAccessedCounter)
}

// MinimockBlocksAccessedDone returns true if the count of the BlocksAccessed invocations corresponds
// the number of defined expectations
func (m *JPlanMock) MinimockBlocksAccessedDone() bool {
	if m.BlocksAccessedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BlocksAccessedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BlocksAccessedMock.invocationsDone()
}

// MinimockBlocksAccessedInspect logs each unmet expectation
func (m *JPlanMock) MinimockBlocksAccessedInspect() {
	for _, e := range m.BlocksAccessedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JPlanMock.BlocksAccessed")
		}
	}

	afterBlocksAccessedCounter := mm_atomic.LoadUint64(&m.afterBlocksAccessedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BlocksAccessedMock.defaultExpectation != nil && afterBlocksAccessedCounter < 1 {
		m.t.Error("Expected call to JPlanMock.BlocksAccessed")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBlocksAccessed != nil && afterBlocksAccessedCounter < 1 {
		m.t.Error("Expected call to JPlanMock.BlocksAccessed")
	}

	if !m.BlocksAccessedMock.invocationsDone() && afterBlocksAccessedCounter > 0 {
		m.t.Errorf("Expected %d calls to JPlanMock.BlocksAccessed but found %d calls",
			mm_atomic.LoadUint64(&m.BlocksAccessedMock.expectedInvocations), afterBlocksAccessedCounter)
	}
}

type mJPlanMockDistinctValues struct {
	optional           bool
	mock               *JPlanMock
	defaultExpectation *JPlanMockDistinctValuesExpectation
	expectations       []*JPlanMockDistinctValuesExpectation

	callArgs []*JPlanMockDistinctValuesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// JPlanMockDistinctValuesExpectation specifies expectation struct of the jPlan.DistinctValues
type JPlanMockDistinctValuesExpectation struct {
	mock      *JPlanMock
	params    *JPlanMockDistinctValuesParams
	paramPtrs *JPlanMockDistinctValuesParamPtrs
	results   *JPlanMockDistinctValuesResults
	Counter   uint64
}

// JPlanMockDistinctValuesParams contains parameters of the jPlan.DistinctValues
type JPlanMockDistinctValuesParams struct {
	fieldName string
}

// JPlanMockDistinctValuesParamPtrs contains pointers to parameters of the jPlan.DistinctValues
type JPlanMockDistinctValuesParamPtrs struct {
	fieldName *string
}

// JPlanMockDistinctValuesResults contains results of the jPlan.DistinctValues
type JPlanMockDistinctValuesResults struct {
	i1 int64
	b1 bool
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDistinctValues *mJPlanMockDistinctValues) Optional() *mJPlanMockDistinctValues {
	mmDistinctValues.optional = true
	return mmDistinctValues
}

// Expect sets up expected params for jPlan.DistinctValues
func (mmDistinctValues *mJPlanMockDistinctValues) Expect(fieldName string) *mJPlanMockDistinctValues {
	if mmDistinctValues.mock.funcDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("JPlanMock.DistinctValues mock is already set by Set")
	}

	if mmDistinctValues.defaultExpectation == nil {
		mmDistinctValues.defaultExpectation = &JPlanMockDistinctValuesExpectation{}
	}

	if mmDistinctValues.defaultExpectation.paramPtrs != nil {
		mmDistinctValues.mock.t.Fatalf("JPlanMock.DistinctValues mock is already set by ExpectParams functions")
	}

	mmDistinctValues.defaultExpectation.params = &JPlanMockDistinctValuesParams{fieldName}
	for _, e := range mmDistinctValues.expectations {
		if minimock.Equal(e.params, mmDistinctValues.defaultExpectation.params) {
			mmDistinctValues.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDistinctValues.defaultExpectation.params)
		}
	}

	return mmDistinctValues
}

// ExpectFieldNameParam1 sets up expected param fieldName for jPlan.DistinctValues
func (mmDistinctValues *mJPlanMockDistinctValues) ExpectFieldNameParam1(fieldName string) *mJPlanMockDistinctValues {
	if mmDistinctValues.mock.funcDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("JPlanMock.DistinctValues mock is already set by Set")
	}

	if mmDistinctValues.defaultExpectation == nil {
		mmDistinctValues.defaultExpectation = &JPlanMockDistinctValuesExpectation{}
	}

	if mmDistinctValues.defaultExpectation.params != nil {
		mmDistinctValues.mock.t.Fatalf("JPlanMock.DistinctValues mock is already set by Expect")
	}

	if mmDistinctValues.defaultExpectation.paramPtrs == nil {
		mmDistinctValues.defaultExpectation.paramPtrs = &JPlanMockDistinctValuesParamPtrs{}
	}
	mmDistinctValues.defaultExpectation.paramPtrs.fieldName = &fieldName

	return mmDistinctValues
}

// Inspect accepts an inspector function that has same arguments as the jPlan.DistinctValues
func (mmDistinctValues *mJPlanMockDistinctValues) Inspect(f func(fieldName string)) *mJPlanMockDistinctValues {
	if mmDistinctValues.mock.inspectFuncDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("Inspect function is already set for JPlanMock.DistinctValues")
	}

	mmDistinctValues.mock.inspectFuncDistinctValues = f

	return mmDistinctValues
}

// Return sets up results that will be returned by jPlan.DistinctValues
func (mmDistinctValues *mJPlanMockDistinctValues) Return(i1 int64, b1 bool) *JPlanMock {
	if mmDistinctValues.mock.funcDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("JPlanMock.DistinctValues mock is already set by Set")
	}

	if mmDistinctValues.defaultExpectation == nil {
		mmDistinctValues.defaultExpectation = &JPlanMockDistinctValuesExpectation{mock: mmDistinctValues.mock}
	}
	mmDistinctValues.defaultExpectation.results = &JPlanMockDistinctValuesResults{i1, b1}
	return mmDistinctValues.mock
}

// Set uses given function f to mock the jPlan.DistinctValues method
func (mmDistinctValues *mJPlanMockDistinctValues) Set(f func(fieldName string) (i1 int64, b1 bool)) *JPlanMock {
	if mmDistinctValues.defaultExpectation != nil {
		mmDistinctValues.mock.t.Fatalf("Default expectation is already set for the jPlan.DistinctValues method")
	}

	if len(mmDistinctValues.expectations) > 0 {
		mmDistinctValues.mock.t.Fatalf("Some expectations are already set for the jPlan.DistinctValues method")
	}

	mmDistinctValues.mock.funcDistinctValues = f
	return mmDistinctValues.mock
}

// When sets expectation for the jPlan.DistinctValues which will trigger the result defined by the following
// Then helper
func (mmDistinctValues *mJPlanMockDistinctValues) When(fieldName string) *JPlanMockDistinctValuesExpectation {
	if mmDistinctValues.mock.funcDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("JPlanMock.DistinctValues mock is already set by Set")
	}

	expectation := &JPlanMockDistinctValuesExpectation{
		mock:   mmDistinctValues.mock,
		params: &JPlanMockDistinctValuesParams{fieldName},
	}
	mmDistinctValues.expectations = append(mmDistinctValues.expectations, expectation)
	return expectation
}

// Then sets up jPlan.DistinctValues return parameters for the expectation previously defined by the When method
func (e *JPlanMockDistinctValuesExpectation) Then(i1 int64, b1 bool) *JPlanMock {
	e.results = &JPlanMockDistinctValuesResults{i1, b1}
	return e.mock
}

// Times sets number of times jPlan.DistinctValues should be invoked
func (mmDistinctValues *mJPlanMockDistinctValues) Times(n uint64) *mJPlanMockDistinctValues {
	if n == 0 {
		mmDistinctValues.mock.t.Fatalf("Times of JPlanMock.DistinctValues mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDistinctValues.expectedInvocations, n)
	return mmDistinctValues
}

func (mmDistinctValues *mJPlanMockDistinctValues) invocationsDone() bool {
	if len(mmDistinctValues.expectations) == 0 && mmDistinctValues.defaultExpectation == nil && mmDistinctValues.mock.funcDistinctValues == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDistinctValues.mock.afterDistinctValuesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDistinctValues.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DistinctValues implements jPlan
func (mmDistinctValues *JPlanMock) DistinctValues(fieldName string) (i1 int64, b1 bool) {
	mm_atomic.AddUint64(&mmDistinctValues.beforeDistinctValuesCounter, 1)
	defer mm_atomic.AddUint64(&mmDistinctValues.afterDistinctValuesCounter, 1)

	if mmDistinctValues.inspectFuncDistinctValues != nil {
		mmDistinctValues.inspectFuncDistinctValues(fieldName)
	}

	mm_params := JPlanMockDistinctValuesParams{fieldName}

	// Record call args
	mmDistinctValues.DistinctValuesMock.mutex.Lock()
	mmDistinctValues.DistinctValuesMock.callArgs = append(mmDistinctValues.DistinctValuesMock.callArgs, &mm_params)
	mmDistinctValues.DistinctValuesMock.mutex.Unlock()

	for _, e := range mmDistinctValues.DistinctValuesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.b1
		}
	}

	if mmDistinctValues.DistinctValuesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDistinctValues.DistinctValuesMock.defaultExpectation.Counter, 1)
		mm_want := mmDistinctValues.DistinctValuesMock.defaultExpectation.params
		mm_want_ptrs := mmDistinctValues.DistinctValuesMock.defaultExpectation.paramPtrs

		mm_got := JPlanMockDistinctValuesParams{fieldName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.fieldName != nil && !minimock.Equal(*mm_want_ptrs.fieldName, mm_got.fieldName) {
				mmDistinctValues.t.Errorf("JPlanMock.DistinctValues got unexpected parameter fieldName, want: %#v, got: %#v%s\n", *mm_want_ptrs.fieldName, mm_got.fieldName, minimock.Diff(*mm_want_ptrs.fieldName, mm_got.fieldName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDistinctValues.t.Errorf("JPlanMock.DistinctValues got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDistinctValues.DistinctValuesMock.defaultExpectation.results
		if mm_results == nil {
			mmDistinctValues.t.Fatal("No results are set for the JPlanMock.DistinctValues")
		}
		return (*mm_results).i1, (*mm_results).b1
	}
	if mmDistinctValues.funcDistinctValues != nil {
		return mmDistinctValues.funcDistinctValues(fieldName)
	}
	mmDistinctValues.t.Fatalf("Unexpected call to JPlanMock.DistinctValues. %v", fieldName)
	return
}

// DistinctValuesAfterCounter returns a count of finished JPlanMock.DistinctValues invocations
func (mmDistinctValues *JPlanMock) DistinctValuesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDistinctValues.afterDistinctValuesCounter)
}

// DistinctValuesBeforeCounter returns a count of JPlanMock.DistinctValues invocations
func (mmDistinctValues *JPlanMock) DistinctValuesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDistinctValues.beforeDistinctValuesCounter)
}

// Calls returns a list of arguments used in each call to JPlanMock.DistinctValues.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDistinctValues *mJPlanMockDistinctValues) Calls() []*JPlanMockDistinctValuesParams {
	mmDistinctValues.mutex.RLock()

	argCopy := make([]*JPlanMockDistinctValuesParams, len(mmDistinctValues.callArgs))
	copy(argCopy, mmDistinctValues.callArgs)

	mmDistinctValues.mutex.RUnlock()

	return argCopy
}

// MinimockDistinctValuesDone returns true if the count of the DistinctValues invocations corresponds
// the number of defined expectations
func (m *JPlanMock) MinimockDistinctValuesDone() bool {
	if m.DistinctValuesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DistinctValuesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DistinctValuesMock.invocationsDone()
}

// MinimockDistinctValuesInspect logs each unmet expectation
func (m *JPlanMock) MinimockDistinctValuesInspect() {
	for _, e := range m.DistinctValuesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JPlanMock.DistinctValues with params: %#v", *e.params)
		}
	}

	afterDistinctValuesCounter := mm_atomic.LoadUint64(&m.afterDistinctValuesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DistinctValuesMock.defaultExpectation != nil && afterDistinctValuesCounter < 1 {
		if m.DistinctValuesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to JPlanMock.DistinctValues")
		} else {
			m.t.Errorf("Expected call to JPlanMock.DistinctValues with params: %#v", *m.DistinctValuesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDistinctValues != nil && afterDistinctValuesCounter < 1 {
		m.t.Error("Expected call to JPlanMock.DistinctValues")
	}

	if !m.DistinctValuesMock.invocationsDone() && afterDistinctValuesCounter > 0 {
		m.t.Errorf("Expected %d calls to JPlanMock.DistinctValues but found %d calls",
			mm_atomic.LoadUint64(&m.DistinctValuesMock.expectedInvocations), afterDistinctValuesCounter)
	}
}

type mJPlanMockOpen struct {
	optional           bool
	mock               *JPlanMock
	defaultExpectation *JPlanMockOpenExpectation
	expectations       []*JPlanMockOpenExpectation

	expectedInvocations uint64
}

// JPlanMockOpenExpectation specifies expectation struct of the jPlan.Open
type JPlanMockOpenExpectation struct {
	mock *JPlanMock

	results *JPlanMockOpenResults
	Counter uint64
}

// JPlanMockOpenResults contains results of the jPlan.Open
type JPlanMockOpenResults struct {
	s1  scan.Scan
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOpen *mJPlanMockOpen) Optional() *mJPlanMockOpen {
	mmOpen.optional = true
	return mmOpen
}

// Expect sets up expected params for jPlan.Open
func (mmOpen *mJPlanMockOpen) Expect() *mJPlanMockOpen {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("JPlanMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &JPlanMockOpenExpectation{}
	}

	return mmOpen
}

// Inspect accepts an inspector function that has same arguments as the jPlan.Open
func (mmOpen *mJPlanMockOpen) Inspect(f func()) *mJPlanMockOpen {
	if mmOpen.mock.inspectFuncOpen != nil {
		mmOpen.mock.t.Fatalf("Inspect function is already set for JPlanMock.Open")
	}

	mmOpen.mock.inspectFuncOpen = f

	return mmOpen
}

// Return sets up results that will be returned by jPlan.Open
func (mmOpen *mJPlanMockOpen) Return(s1 scan.Scan, err error) *JPlanMock {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("JPlanMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &JPlanMockOpenExpectation{mock: mmOpen.mock}
	}
	mmOpen.defaultExpectation.results = &JPlanMockOpenResults{s1, err}
	return mmOpen.mock
}

// Set uses given function f to mock the jPlan.Open method
func (mmOpen *mJPlanMockOpen) Set(f func() (s1 scan.Scan, err error)) *JPlanMock {
	if mmOpen.defaultExpectation != nil {
		mmOpen.mock.t.Fatalf("Default expectation is already set for the jPlan.Open method")
	}

	if len(mmOpen.expectations) > 0 {
		mmOpen.mock.t.Fatalf("Some expectations are already set for the jPlan.Open method")
	}

	mmOpen.mock.funcOpen = f
	return mmOpen.mock
}

// Times sets number of times jPlan.Open should be invoked
func (mmOpen *mJPlanMockOpen) Times(n uint64) *mJPlanMockOpen {
	if n == 0 {
		mmOpen.mock.t.Fatalf("Times of JPlanMock.Open mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOpen.expectedInvocations, n)
	return mmOpen
}

func (mmOpen *mJPlanMockOpen) invocationsDone() bool {
	if len(mmOpen.expectations) == 0 && mmOpen.defaultExpectation == nil && mmOpen.mock.funcOpen == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOpen.mock.afterOpenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOpen.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Open implements jPlan
func (mmOpen *JPlanMock) Open() (s1 scan.Scan, err error) {
	mm_atomic.AddUint64(&mmOpen.beforeOpenCounter, 1)
	defer mm_atomic.AddUint64(&mmOpen.afterOpenCounter, 1)

	if mmOpen.inspectFuncOpen != nil {
		mmOpen.inspectFuncOpen()
	}

	if mmOpen.OpenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOpen.OpenMock.defaultExpectation.Counter, 1)

		mm_results := mmOpen.OpenMock.defaultExpectation.results
		if mm_results == nil {
			mmOpen.t.Fatal("No results are set for the JPlanMock.Open")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmOpen.funcOpen != nil {
		return mmOpen.funcOpen()
	}
	mmOpen.t.Fatalf("Unexpected call to JPlanMock.Open.")
	return
}

// OpenAfterCounter returns a count of finished JPlanMock.Open invocations
func (mmOpen *JPlanMock) OpenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.afterOpenCounter)
}

// OpenBeforeCounter returns a count of JPlanMock.Open invocations
func (mmOpen *JPlanMock) OpenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.beforeOpenCounter)
}

// MinimockOpenDone returns true if the count of the Open invocations corresponds
// the number of defined expectations
func (m *JPlanMock) MinimockOpenDone() bool {
	if m.OpenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OpenMock.invocationsDone()
}

// MinimockOpenInspect logs each unmet expectation
func (m *JPlanMock) MinimockOpenInspect() {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JPlanMock.Open")
		}
	}

	afterOpenCounter := mm_atomic.LoadUint64(&m.afterOpenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && afterOpenCounter < 1 {
		m.t.Error("Expected call to JPlanMock.Open")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && afterOpenCounter < 1 {
		m.t.Error("Expected call to JPlanMock.Open")
	}

	if !m.OpenMock.invocationsDone() && afterOpenCounter > 0 {
		m.t.Errorf("Expected %d calls to JPlanMock.Open but found %d calls",
			mm_atomic.LoadUint64(&m.OpenMock.expectedInvocations), afterOpenCounter)
	}
}

type mJPlanMockRecords struct {
	optional           bool
	mock               *JPlanMock
	defaultExpectation *JPlanMockRecordsExpectation
	expectations       []*JPlanMockRecordsExpectation

	expectedInvocations uint64
}

// JPlanMockRecordsExpectation specifies expectation struct of the jPlan.Records
type JPlanMockRecordsExpectation struct {
	mock *JPlanMock

	results *JPlanMockRecordsResults
	Counter uint64
}

// JPlanMockRecordsResults contains results of the jPlan.Records
type JPlanMockRecordsResults struct {
	i1 int64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRecords *mJPlanMockRecords) Optional() *mJPlanMockRecords {
	mmRecords.optional = true
	return mmRecords
}

// Expect sets up expected params for jPlan.Records
func (mmRecords *mJPlanMockRecords) Expect() *mJPlanMockRecords {
	if mmRecords.mock.funcRecords != nil {
		mmRecords.mock.t.Fatalf("JPlanMock.Records mock is already set by Set")
	}

	if mmRecords.defaultExpectation == nil {
		mmRecords.defaultExpectation = &JPlanMockRecordsExpectation{}
	}

	return mmRecords
}

// Inspect accepts an inspector function that has same arguments as the jPlan.Records
func (mmRecords *mJPlanMockRecords) Inspect(f func()) *mJPlanMockRecords {
	if mmRecords.mock.inspectFuncRecords != nil {
		mmRecords.mock.t.Fatalf("Inspect function is already set for JPlanMock.Records")
	}

	mmRecords.mock.inspectFuncRecords = f

	return mmRecords
}

// Return sets up results that will be returned by jPlan.Records
func (mmRecords *mJPlanMockRecords) Return(i1 int64) *JPlanMock {
	if mmRecords.mock.funcRecords != nil {
		mmRecords.mock.t.Fatalf("JPlanMock.Records mock is already set by Set")
	}

	if mmRecords.defaultExpectation == nil {
		mmRecords.defaultExpectation = &JPlanMockRecordsExpectation{mock: mmRecords.mock}
	}
	mmRecords.defaultExpectation.results = &JPlanMockRecordsResults{i1}
	return mmRecords.mock
}

// Set uses given function f to mock the jPlan.Records method
func (mmRecords *mJPlanMockRecords) Set(f func() (i1 int64)) *JPlanMock {
	if mmRecords.defaultExpectation != nil {
		mmRecords.mock.t.Fatalf("Default expectation is already set for the jPlan.Records method")
	}

	if len(mmRecords.expectations) > 0 {
		mmRecords.mock.t.Fatalf("Some expectations are already set for the jPlan.Records method")
	}

	mmRecords.mock.funcRecords = f
	return mmRecords.mock
}

// Times sets number of times jPlan.Records should be invoked
func (mmRecords *mJPlanMockRecords) Times(n uint64) *mJPlanMockRecords {
	if n == 0 {
		mmRecords.mock.t.Fatalf("Times of JPlanMock.Records mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRecords.expectedInvocations, n)
	return mmRecords
}

func (mmRecords *mJPlanMockRecords) invocationsDone() bool {
	if len(mmRecords.expectations) == 0 && mmRecords.defaultExpectation == nil && mmRecords.mock.funcRecords == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRecords.mock.afterRecordsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRecords.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Records implements jPlan
func (mmRecords *JPlanMock) Records() (i1 int64) {
	mm_atomic.AddUint64(&mmRecords.beforeRecordsCounter, 1)
	defer mm_atomic.AddUint64(&mmRecords.afterRecordsCounter, 1)

	if mmRecords.inspectFuncRecords != nil {
		mmRecords.inspectFuncRecords()
	}

	if mmRecords.RecordsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecords.RecordsMock.defaultExpectation.Counter, 1)

		mm_results := mmRecords.RecordsMock.defaultExpectation.results
		if mm_results == nil {
			mmRecords.t.Fatal("No results are set for the JPlanMock.Records")
		}
		return (*mm_results).i1
	}
	if mmRecords.funcRecords != nil {
		return mmRecords.funcRecords()
	}
	mmRecords.t.Fatalf("Unexpected call to JPlanMock.Records.")
	return
}

// RecordsAfterCounter returns a count of finished JPlanMock.Records invocations
func (mmRecords *JPlanMock) RecordsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecords.afterRecordsCounter)
}

// RecordsBeforeCounter returns a count of JPlanMock.Records invocations
func (mmRecords *JPlanMock) RecordsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecords.beforeRecordsCounter)
}

// MinimockRecordsDone returns true if the count of the Records invocations corresponds
// the number of defined expectations
func (m *JPlanMock) MinimockRecordsDone() bool {
	if m.RecordsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RecordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RecordsMock.invocationsDone()
}

// MinimockRecordsInspect logs each unmet expectation
func (m *JPlanMock) MinimockRecordsInspect() {
	for _, e := range m.RecordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JPlanMock.Records")
		}
	}

	afterRecordsCounter := mm_atomic.LoadUint64(&m.afterRecordsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RecordsMock.defaultExpectation != nil && afterRecordsCounter < 1 {
		m.t.Error("Expected call to JPlanMock.Records")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecords != nil && afterRecordsCounter < 1 {
		m.t.Error("Expected call to JPlanMock.Records")
	}

	if !m.RecordsMock.invocationsDone() && afterRecordsCounter > 0 {
		m.t.Errorf("Expected %d calls to JPlanMock.Records but found %d calls",
			mm_atomic.LoadUint64(&m.RecordsMock.expectedInvocations), afterRecordsCounter)
	}
}

type mJPlanMockSchema struct {
	optional           bool
	mock               *JPlanMock
	defaultExpectation *JPlanMockSchemaExpectation
	expectations       []*JPlanMockSchemaExpectation

	expectedInvocations uint64
}

// JPlanMockSchemaExpectation specifies expectation struct of the jPlan.Schema
type JPlanMockSchemaExpectation struct {
	mock *JPlanMock

	results *JPlanMockSchemaResults
	Counter uint64
}

// JPlanMockSchemaResults contains results of the jPlan.Schema
type JPlanMockSchemaResults struct {
	s1 records.Schema
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSchema *mJPlanMockSchema) Optional() *mJPlanMockSchema {
	mmSchema.optional = true
	return mmSchema
}

// Expect sets up expected params for jPlan.Schema
func (mmSchema *mJPlanMockSchema) Expect() *mJPlanMockSchema {
	if mmSchema.mock.funcSchema != nil {
		mmSchema.mock.t.Fatalf("JPlanMock.Schema mock is already set by Set")
	}

	if mmSchema.defaultExpectation == nil {
		mmSchema.defaultExpectation = &JPlanMockSchemaExpectation{}
	}

	return mmSchema
}

// Inspect accepts an inspector function that has same arguments as the jPlan.Schema
func (mmSchema *mJPlanMockSchema) Inspect(f func()) *mJPlanMockSchema {
	if mmSchema.mock.inspectFuncSchema != nil {
		mmSchema.mock.t.Fatalf("Inspect function is already set for JPlanMock.Schema")
	}

	mmSchema.mock.inspectFuncSchema = f

	return mmSchema
}

// Return sets up results that will be returned by jPlan.Schema
func (mmSchema *mJPlanMockSchema) Return(s1 records.Schema) *JPlanMock {
	if mmSchema.mock.funcSchema != nil {
		mmSchema.mock.t.Fatalf("JPlanMock.Schema mock is already set by Set")
	}

	if mmSchema.defaultExpectation == nil {
		mmSchema.defaultExpectation = &JPlanMockSchemaExpectation{mock: mmSchema.mock}
	}
	mmSchema.defaultExpectation.results = &JPlanMockSchemaResults{s1}
	return mmSchema.mock
}

// Set uses given function f to mock the jPlan.Schema method
func (mmSchema *mJPlanMockSchema) Set(f func() (s1 records.Schema)) *JPlanMock {
	if mmSchema.defaultExpectation != nil {
		mmSchema.mock.t.Fatalf("Default expectation is already set for the jPlan.Schema method")
	}

	if len(mmSchema.expectations) > 0 {
		mmSchema.mock.t.Fatalf("Some expectations are already set for the jPlan.Schema method")
	}

	mmSchema.mock.funcSchema = f
	return mmSchema.mock
}

// Times sets number of times jPlan.Schema should be invoked
func (mmSchema *mJPlanMockSchema) Times(n uint64) *mJPlanMockSchema {
	if n == 0 {
		mmSchema.mock.t.Fatalf("Times of JPlanMock.Schema mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSchema.expectedInvocations, n)
	return mmSchema
}

func (mmSchema *mJPlanMockSchema) invocationsDone() bool {
	if len(mmSchema.expectations) == 0 && mmSchema.defaultExpectation == nil && mmSchema.mock.funcSchema == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSchema.mock.afterSchemaCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSchema.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Schema implements jPlan
func (mmSchema *JPlanMock) Schema() (s1 records.Schema) {
	mm_atomic.AddUint64(&mmSchema.beforeSchemaCounter, 1)
	defer mm_atomic.AddUint64(&mmSchema.afterSchemaCounter, 1)

	if mmSchema.inspectFuncSchema != nil {
		mmSchema.inspectFuncSchema()
	}

	if mmSchema.SchemaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSchema.SchemaMock.defaultExpectation.Counter, 1)

		mm_results := mmSchema.SchemaMock.defaultExpectation.results
		if mm_results == nil {
			mmSchema.t.Fatal("No results are set for the JPlanMock.Schema")
		}
		return (*mm_results).s1
	}
	if mmSchema.funcSchema != nil {
		return mmSchema.funcSchema()
	}
	mmSchema.t.Fatalf("Unexpected call to JPlanMock.Schema.")
	return
}

// SchemaAfterCounter returns a count of finished JPlanMock.Schema invocations
func (mmSchema *JPlanMock) SchemaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSchema.afterSchemaCounter)
}

// SchemaBeforeCounter returns a count of JPlanMock.Schema invocations
func (mmSchema *JPlanMock) SchemaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSchema.beforeSchemaCounter)
}

// MinimockSchemaDone returns true if the count of the Schema invocations corresponds
// the number of defined expectations
func (m *JPlanMock) MinimockSchemaDone() bool {
	if m.SchemaMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SchemaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SchemaMock.invocationsDone()
}

// MinimockSchemaInspect logs each unmet expectation
func (m *JPlanMock) MinimockSchemaInspect() {
	for _, e := range m.SchemaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JPlanMock.Schema")
		}
	}

	afterSchemaCounter := mm_atomic.LoadUint64(&m.afterSchemaCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SchemaMock.defaultExpectation != nil && afterSchemaCounter < 1 {
		m.t.Error("Expected call to JPlanMock.Schema")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSchema != nil && afterSchemaCounter < 1 {
		m.t.Error("Expected call to JPlanMock.Schema")
	}

	if !m.SchemaMock.invocationsDone() && afterSchemaCounter > 0 {
		m.t.Errorf("Expected %d calls to JPlanMock.Schema but found %d calls",
			mm_atomic.LoadUint64(&m.SchemaMock.expectedInvocations), afterSchemaCounter)
	}
}

type mJPlanMockString struct {
	optional           bool
	mock               *JPlanMock
	defaultExpectation *JPlanMockStringExpectation
	expectations       []*JPlanMockStringExpectation

	expectedInvocations uint64
}

// JPlanMockStringExpectation specifies expectation struct of the jPlan.String
type JPlanMockStringExpectation struct {
	mock *JPlanMock

	results *JPlanMockStringResults
	Counter uint64
}

// JPlanMockStringResults contains results of the jPlan.String
type JPlanMockStringResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmString *mJPlanMockString) Optional() *mJPlanMockString {
	mmString.optional = true
	return mmString
}

// Expect sets up expected params for jPlan.String
func (mmString *mJPlanMockString) Expect() *mJPlanMockString {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("JPlanMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &JPlanMockStringExpectation{}
	}

	return mmString
}

// Inspect accepts an inspector function that has same arguments as the jPlan.String
func (mmString *mJPlanMockString) Inspect(f func()) *mJPlanMockString {
	if mmString.mock.inspectFuncString != nil {
		mmString.mock.t.Fatalf("Inspect function is already set for JPlanMock.String")
	}

	mmString.mock.inspectFuncString = f

	return mmString
}

// Return sets up results that will be returned by jPlan.String
func (mmString *mJPlanMockString) Return(s1 string) *JPlanMock {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("JPlanMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &JPlanMockStringExpectation{mock: mmString.mock}
	}
	mmString.defaultExpectation.results = &JPlanMockStringResults{s1}
	return mmString.mock
}

// Set uses given function f to mock the jPlan.String method
func (mmString *mJPlanMockString) Set(f func() (s1 string)) *JPlanMock {
	if mmString.defaultExpectation != nil {
		mmString.mock.t.Fatalf("Default expectation is already set for the jPlan.String method")
	}

	if len(mmString.expectations) > 0 {
		mmString.mock.t.Fatalf("Some expectations are already set for the jPlan.String method")
	}

	mmString.mock.funcString = f
	return mmString.mock
}

// Times sets number of times jPlan.String should be invoked
func (mmString *mJPlanMockString) Times(n uint64) *mJPlanMockString {
	if n == 0 {
		mmString.mock.t.Fatalf("Times of JPlanMock.String mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmString.expectedInvocations, n)
	return mmString
}

func (mmString *mJPlanMockString) invocationsDone() bool {
	if len(mmString.expectations) == 0 && mmString.defaultExpectation == nil && mmString.mock.funcString == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmString.mock.afterStringCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmString.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// String implements jPlan
func (mmString *JPlanMock) String() (s1 string) {
	mm_atomic.AddUint64(&mmString.beforeStringCounter, 1)
	defer mm_atomic.AddUint64(&mmString.afterStringCounter, 1)

	if mmString.inspectFuncString != nil {
		mmString.inspectFuncString()
	}

	if mmString.StringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmString.StringMock.defaultExpectation.Counter, 1)

		mm_results := mmString.StringMock.defaultExpectation.results
		if mm_results == nil {
			mmString.t.Fatal("No results are set for the JPlanMock.String")
		}
		return (*mm_results).s1
	}
	if mmString.funcString != nil {
		return mmString.funcString()
	}
	mmString.t.Fatalf("Unexpected call to JPlanMock.String.")
	return
}

// StringAfterCounter returns a count of finished JPlanMock.String invocations
func (mmString *JPlanMock) StringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.afterStringCounter)
}

// StringBeforeCounter returns a count of JPlanMock.String invocations
func (mmString *JPlanMock) StringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.beforeStringCounter)
}

// MinimockStringDone returns true if the count of the String invocations corresponds
// the number of defined expectations
func (m *JPlanMock) MinimockStringDone() bool {
	if m.StringMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StringMock.invocationsDone()
}

// MinimockStringInspect logs each unmet expectation
func (m *JPlanMock) MinimockStringInspect() {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JPlanMock.String")
		}
	}

	afterStringCounter := mm_atomic.LoadUint64(&m.afterStringCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && afterStringCounter < 1 {
		m.t.Error("Expected call to JPlanMock.String")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && afterStringCounter < 1 {
		m.t.Error("Expected call to JPlanMock.String")
	}

	if !m.StringMock.invocationsDone() && afterStringCounter > 0 {
		m.t.Errorf("Expected %d calls to JPlanMock.String but found %d calls",
			mm_atomic.LoadUint64(&m.StringMock.expectedInvocations), afterStringCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *JPlanMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBlocksAccessedInspect()

			m.MinimockDistinctValuesInspect()

			m.MinimockOpenInspect()

			m.MinimockRecordsInspect()

			m.MinimockSchemaInspect()

			m.MinimockStringInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *JPlanMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *JPlanMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBlocksAccessedDone() &&
		m.MinimockDistinctValuesDone() &&
		m.MinimockOpenDone() &&
		m.MinimockRecordsDone() &&
		m.MinimockSchemaDone() &&
		m.MinimockStringDone()
}
