package indexplanner

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/unhandled-exception/sophiadb/internal/pkg/indexplanner.jPlan -o ./mock_jplan_test.go -n JPlanMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/unhandled-exception/sophiadb/internal/pkg/records"
	"github.com/unhandled-exception/sophiadb/internal/pkg/scan"
)

// JPlanMock implements jPlan
type JPlanMock struct {
	t minimock.Tester

	funcBlocksAccessed          func() (i1 int64)
	inspectFuncBlocksAccessed   func()
	afterBlocksAccessedCounter  uint64
	beforeBlocksAccessedCounter uint64
	BlocksAccessedMock          mJPlanMockBlocksAccessed

	funcDistinctValues          func(fieldName string) (i1 int64, b1 bool)
	inspectFuncDistinctValues   func(fieldName string)
	afterDistinctValuesCounter  uint64
	beforeDistinctValuesCounter uint64
	DistinctValuesMock          mJPlanMockDistinctValues

	funcOpen          func() (s1 scan.Scan, err error)
	inspectFuncOpen   func()
	afterOpenCounter  uint64
	beforeOpenCounter uint64
	OpenMock          mJPlanMockOpen

	funcRecords          func() (i1 int64)
	inspectFuncRecords   func()
	afterRecordsCounter  uint64
	beforeRecordsCounter uint64
	RecordsMock          mJPlanMockRecords

	funcSchema          func() (s1 records.Schema)
	inspectFuncSchema   func()
	afterSchemaCounter  uint64
	beforeSchemaCounter uint64
	SchemaMock          mJPlanMockSchema

	funcString          func() (s1 string)
	inspectFuncString   func()
	afterStringCounter  uint64
	beforeStringCounter uint64
	StringMock          mJPlanMockString
}

// NewJPlanMock returns a mock for jPlan
func NewJPlanMock(t minimock.Tester) *JPlanMock {
	m := &JPlanMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BlocksAccessedMock = mJPlanMockBlocksAccessed{mock: m}

	m.DistinctValuesMock = mJPlanMockDistinctValues{mock: m}
	m.DistinctValuesMock.callArgs = []*JPlanMockDistinctValuesParams{}

	m.OpenMock = mJPlanMockOpen{mock: m}

	m.RecordsMock = mJPlanMockRecords{mock: m}

	m.SchemaMock = mJPlanMockSchema{mock: m}

	m.StringMock = mJPlanMockString{mock: m}

	return m
}

type mJPlanMockBlocksAccessed struct {
	mock               *JPlanMock
	defaultExpectation *JPlanMockBlocksAccessedExpectation
	expectations       []*JPlanMockBlocksAccessedExpectation
}

// JPlanMockBlocksAccessedExpectation specifies expectation struct of the jPlan.BlocksAccessed
type JPlanMockBlocksAccessedExpectation struct {
	mock *JPlanMock

	results *JPlanMockBlocksAccessedResults
	Counter uint64
}

// JPlanMockBlocksAccessedResults contains results of the jPlan.BlocksAccessed
type JPlanMockBlocksAccessedResults struct {
	i1 int64
}

// Expect sets up expected params for jPlan.BlocksAccessed
func (mmBlocksAccessed *mJPlanMockBlocksAccessed) Expect() *mJPlanMockBlocksAccessed {
	if mmBlocksAccessed.mock.funcBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("JPlanMock.BlocksAccessed mock is already set by Set")
	}

	if mmBlocksAccessed.defaultExpectation == nil {
		mmBlocksAccessed.defaultExpectation = &JPlanMockBlocksAccessedExpectation{}
	}

	return mmBlocksAccessed
}

// Inspect accepts an inspector function that has same arguments as the jPlan.BlocksAccessed
func (mmBlocksAccessed *mJPlanMockBlocksAccessed) Inspect(f func()) *mJPlanMockBlocksAccessed {
	if mmBlocksAccessed.mock.inspectFuncBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("Inspect function is already set for JPlanMock.BlocksAccessed")
	}

	mmBlocksAccessed.mock.inspectFuncBlocksAccessed = f

	return mmBlocksAccessed
}

// Return sets up results that will be returned by jPlan.BlocksAccessed
func (mmBlocksAccessed *mJPlanMockBlocksAccessed) Return(i1 int64) *JPlanMock {
	if mmBlocksAccessed.mock.funcBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("JPlanMock.BlocksAccessed mock is already set by Set")
	}

	if mmBlocksAccessed.defaultExpectation == nil {
		mmBlocksAccessed.defaultExpectation = &JPlanMockBlocksAccessedExpectation{mock: mmBlocksAccessed.mock}
	}
	mmBlocksAccessed.defaultExpectation.results = &JPlanMockBlocksAccessedResults{i1}
	return mmBlocksAccessed.mock
}

//Set uses given function f to mock the jPlan.BlocksAccessed method
func (mmBlocksAccessed *mJPlanMockBlocksAccessed) Set(f func() (i1 int64)) *JPlanMock {
	if mmBlocksAccessed.defaultExpectation != nil {
		mmBlocksAccessed.mock.t.Fatalf("Default expectation is already set for the jPlan.BlocksAccessed method")
	}

	if len(mmBlocksAccessed.expectations) > 0 {
		mmBlocksAccessed.mock.t.Fatalf("Some expectations are already set for the jPlan.BlocksAccessed method")
	}

	mmBlocksAccessed.mock.funcBlocksAccessed = f
	return mmBlocksAccessed.mock
}

// BlocksAccessed implements jPlan
func (mmBlocksAccessed *JPlanMock) BlocksAccessed() (i1 int64) {
	mm_atomic.AddUint64(&mmBlocksAccessed.beforeBlocksAccessedCounter, 1)
	defer mm_atomic.AddUint64(&mmBlocksAccessed.afterBlocksAccessedCounter, 1)

	if mmBlocksAccessed.inspectFuncBlocksAccessed != nil {
		mmBlocksAccessed.inspectFuncBlocksAccessed()
	}

	if mmBlocksAccessed.BlocksAccessedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBlocksAccessed.BlocksAccessedMock.defaultExpectation.Counter, 1)

		mm_results := mmBlocksAccessed.BlocksAccessedMock.defaultExpectation.results
		if mm_results == nil {
			mmBlocksAccessed.t.Fatal("No results are set for the JPlanMock.BlocksAccessed")
		}
		return (*mm_results).i1
	}
	if mmBlocksAccessed.funcBlocksAccessed != nil {
		return mmBlocksAccessed.funcBlocksAccessed()
	}
	mmBlocksAccessed.t.Fatalf("Unexpected call to JPlanMock.BlocksAccessed.")
	return
}

// BlocksAccessedAfterCounter returns a count of finished JPlanMock.BlocksAccessed invocations
func (mmBlocksAccessed *JPlanMock) BlocksAccessedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBlocksAccessed.afterBlocksAccessedCounter)
}

// BlocksAccessedBeforeCounter returns a count of JPlanMock.BlocksAccessed invocations
func (mmBlocksAccessed *JPlanMock) BlocksAccessedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBlocksAccessed.beforeBlocksAccessedCounter)
}

// MinimockBlocksAccessedDone returns true if the count of the BlocksAccessed invocations corresponds
// the number of defined expectations
func (m *JPlanMock) MinimockBlocksAccessedDone() bool {
	for _, e := range m.BlocksAccessedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BlocksAccessedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBlocksAccessedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBlocksAccessed != nil && mm_atomic.LoadUint64(&m.afterBlocksAccessedCounter) < 1 {
		return false
	}
	return true
}

// MinimockBlocksAccessedInspect logs each unmet expectation
func (m *JPlanMock) MinimockBlocksAccessedInspect() {
	for _, e := range m.BlocksAccessedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JPlanMock.BlocksAccessed")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BlocksAccessedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBlocksAccessedCounter) < 1 {
		m.t.Error("Expected call to JPlanMock.BlocksAccessed")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBlocksAccessed != nil && mm_atomic.LoadUint64(&m.afterBlocksAccessedCounter) < 1 {
		m.t.Error("Expected call to JPlanMock.BlocksAccessed")
	}
}

type mJPlanMockDistinctValues struct {
	mock               *JPlanMock
	defaultExpectation *JPlanMockDistinctValuesExpectation
	expectations       []*JPlanMockDistinctValuesExpectation

	callArgs []*JPlanMockDistinctValuesParams
	mutex    sync.RWMutex
}

// JPlanMockDistinctValuesExpectation specifies expectation struct of the jPlan.DistinctValues
type JPlanMockDistinctValuesExpectation struct {
	mock    *JPlanMock
	params  *JPlanMockDistinctValuesParams
	results *JPlanMockDistinctValuesResults
	Counter uint64
}

// JPlanMockDistinctValuesParams contains parameters of the jPlan.DistinctValues
type JPlanMockDistinctValuesParams struct {
	fieldName string
}

// JPlanMockDistinctValuesResults contains results of the jPlan.DistinctValues
type JPlanMockDistinctValuesResults struct {
	i1 int64
	b1 bool
}

// Expect sets up expected params for jPlan.DistinctValues
func (mmDistinctValues *mJPlanMockDistinctValues) Expect(fieldName string) *mJPlanMockDistinctValues {
	if mmDistinctValues.mock.funcDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("JPlanMock.DistinctValues mock is already set by Set")
	}

	if mmDistinctValues.defaultExpectation == nil {
		mmDistinctValues.defaultExpectation = &JPlanMockDistinctValuesExpectation{}
	}

	mmDistinctValues.defaultExpectation.params = &JPlanMockDistinctValuesParams{fieldName}
	for _, e := range mmDistinctValues.expectations {
		if minimock.Equal(e.params, mmDistinctValues.defaultExpectation.params) {
			mmDistinctValues.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDistinctValues.defaultExpectation.params)
		}
	}

	return mmDistinctValues
}

// Inspect accepts an inspector function that has same arguments as the jPlan.DistinctValues
func (mmDistinctValues *mJPlanMockDistinctValues) Inspect(f func(fieldName string)) *mJPlanMockDistinctValues {
	if mmDistinctValues.mock.inspectFuncDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("Inspect function is already set for JPlanMock.DistinctValues")
	}

	mmDistinctValues.mock.inspectFuncDistinctValues = f

	return mmDistinctValues
}

// Return sets up results that will be returned by jPlan.DistinctValues
func (mmDistinctValues *mJPlanMockDistinctValues) Return(i1 int64, b1 bool) *JPlanMock {
	if mmDistinctValues.mock.funcDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("JPlanMock.DistinctValues mock is already set by Set")
	}

	if mmDistinctValues.defaultExpectation == nil {
		mmDistinctValues.defaultExpectation = &JPlanMockDistinctValuesExpectation{mock: mmDistinctValues.mock}
	}
	mmDistinctValues.defaultExpectation.results = &JPlanMockDistinctValuesResults{i1, b1}
	return mmDistinctValues.mock
}

//Set uses given function f to mock the jPlan.DistinctValues method
func (mmDistinctValues *mJPlanMockDistinctValues) Set(f func(fieldName string) (i1 int64, b1 bool)) *JPlanMock {
	if mmDistinctValues.defaultExpectation != nil {
		mmDistinctValues.mock.t.Fatalf("Default expectation is already set for the jPlan.DistinctValues method")
	}

	if len(mmDistinctValues.expectations) > 0 {
		mmDistinctValues.mock.t.Fatalf("Some expectations are already set for the jPlan.DistinctValues method")
	}

	mmDistinctValues.mock.funcDistinctValues = f
	return mmDistinctValues.mock
}

// When sets expectation for the jPlan.DistinctValues which will trigger the result defined by the following
// Then helper
func (mmDistinctValues *mJPlanMockDistinctValues) When(fieldName string) *JPlanMockDistinctValuesExpectation {
	if mmDistinctValues.mock.funcDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("JPlanMock.DistinctValues mock is already set by Set")
	}

	expectation := &JPlanMockDistinctValuesExpectation{
		mock:   mmDistinctValues.mock,
		params: &JPlanMockDistinctValuesParams{fieldName},
	}
	mmDistinctValues.expectations = append(mmDistinctValues.expectations, expectation)
	return expectation
}

// Then sets up jPlan.DistinctValues return parameters for the expectation previously defined by the When method
func (e *JPlanMockDistinctValuesExpectation) Then(i1 int64, b1 bool) *JPlanMock {
	e.results = &JPlanMockDistinctValuesResults{i1, b1}
	return e.mock
}

// DistinctValues implements jPlan
func (mmDistinctValues *JPlanMock) DistinctValues(fieldName string) (i1 int64, b1 bool) {
	mm_atomic.AddUint64(&mmDistinctValues.beforeDistinctValuesCounter, 1)
	defer mm_atomic.AddUint64(&mmDistinctValues.afterDistinctValuesCounter, 1)

	if mmDistinctValues.inspectFuncDistinctValues != nil {
		mmDistinctValues.inspectFuncDistinctValues(fieldName)
	}

	mm_params := &JPlanMockDistinctValuesParams{fieldName}

	// Record call args
	mmDistinctValues.DistinctValuesMock.mutex.Lock()
	mmDistinctValues.DistinctValuesMock.callArgs = append(mmDistinctValues.DistinctValuesMock.callArgs, mm_params)
	mmDistinctValues.DistinctValuesMock.mutex.Unlock()

	for _, e := range mmDistinctValues.DistinctValuesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.b1
		}
	}

	if mmDistinctValues.DistinctValuesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDistinctValues.DistinctValuesMock.defaultExpectation.Counter, 1)
		mm_want := mmDistinctValues.DistinctValuesMock.defaultExpectation.params
		mm_got := JPlanMockDistinctValuesParams{fieldName}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDistinctValues.t.Errorf("JPlanMock.DistinctValues got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDistinctValues.DistinctValuesMock.defaultExpectation.results
		if mm_results == nil {
			mmDistinctValues.t.Fatal("No results are set for the JPlanMock.DistinctValues")
		}
		return (*mm_results).i1, (*mm_results).b1
	}
	if mmDistinctValues.funcDistinctValues != nil {
		return mmDistinctValues.funcDistinctValues(fieldName)
	}
	mmDistinctValues.t.Fatalf("Unexpected call to JPlanMock.DistinctValues. %v", fieldName)
	return
}

// DistinctValuesAfterCounter returns a count of finished JPlanMock.DistinctValues invocations
func (mmDistinctValues *JPlanMock) DistinctValuesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDistinctValues.afterDistinctValuesCounter)
}

// DistinctValuesBeforeCounter returns a count of JPlanMock.DistinctValues invocations
func (mmDistinctValues *JPlanMock) DistinctValuesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDistinctValues.beforeDistinctValuesCounter)
}

// Calls returns a list of arguments used in each call to JPlanMock.DistinctValues.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDistinctValues *mJPlanMockDistinctValues) Calls() []*JPlanMockDistinctValuesParams {
	mmDistinctValues.mutex.RLock()

	argCopy := make([]*JPlanMockDistinctValuesParams, len(mmDistinctValues.callArgs))
	copy(argCopy, mmDistinctValues.callArgs)

	mmDistinctValues.mutex.RUnlock()

	return argCopy
}

// MinimockDistinctValuesDone returns true if the count of the DistinctValues invocations corresponds
// the number of defined expectations
func (m *JPlanMock) MinimockDistinctValuesDone() bool {
	for _, e := range m.DistinctValuesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DistinctValuesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDistinctValuesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDistinctValues != nil && mm_atomic.LoadUint64(&m.afterDistinctValuesCounter) < 1 {
		return false
	}
	return true
}

// MinimockDistinctValuesInspect logs each unmet expectation
func (m *JPlanMock) MinimockDistinctValuesInspect() {
	for _, e := range m.DistinctValuesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JPlanMock.DistinctValues with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DistinctValuesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDistinctValuesCounter) < 1 {
		if m.DistinctValuesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to JPlanMock.DistinctValues")
		} else {
			m.t.Errorf("Expected call to JPlanMock.DistinctValues with params: %#v", *m.DistinctValuesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDistinctValues != nil && mm_atomic.LoadUint64(&m.afterDistinctValuesCounter) < 1 {
		m.t.Error("Expected call to JPlanMock.DistinctValues")
	}
}

type mJPlanMockOpen struct {
	mock               *JPlanMock
	defaultExpectation *JPlanMockOpenExpectation
	expectations       []*JPlanMockOpenExpectation
}

// JPlanMockOpenExpectation specifies expectation struct of the jPlan.Open
type JPlanMockOpenExpectation struct {
	mock *JPlanMock

	results *JPlanMockOpenResults
	Counter uint64
}

// JPlanMockOpenResults contains results of the jPlan.Open
type JPlanMockOpenResults struct {
	s1  scan.Scan
	err error
}

// Expect sets up expected params for jPlan.Open
func (mmOpen *mJPlanMockOpen) Expect() *mJPlanMockOpen {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("JPlanMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &JPlanMockOpenExpectation{}
	}

	return mmOpen
}

// Inspect accepts an inspector function that has same arguments as the jPlan.Open
func (mmOpen *mJPlanMockOpen) Inspect(f func()) *mJPlanMockOpen {
	if mmOpen.mock.inspectFuncOpen != nil {
		mmOpen.mock.t.Fatalf("Inspect function is already set for JPlanMock.Open")
	}

	mmOpen.mock.inspectFuncOpen = f

	return mmOpen
}

// Return sets up results that will be returned by jPlan.Open
func (mmOpen *mJPlanMockOpen) Return(s1 scan.Scan, err error) *JPlanMock {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("JPlanMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &JPlanMockOpenExpectation{mock: mmOpen.mock}
	}
	mmOpen.defaultExpectation.results = &JPlanMockOpenResults{s1, err}
	return mmOpen.mock
}

//Set uses given function f to mock the jPlan.Open method
func (mmOpen *mJPlanMockOpen) Set(f func() (s1 scan.Scan, err error)) *JPlanMock {
	if mmOpen.defaultExpectation != nil {
		mmOpen.mock.t.Fatalf("Default expectation is already set for the jPlan.Open method")
	}

	if len(mmOpen.expectations) > 0 {
		mmOpen.mock.t.Fatalf("Some expectations are already set for the jPlan.Open method")
	}

	mmOpen.mock.funcOpen = f
	return mmOpen.mock
}

// Open implements jPlan
func (mmOpen *JPlanMock) Open() (s1 scan.Scan, err error) {
	mm_atomic.AddUint64(&mmOpen.beforeOpenCounter, 1)
	defer mm_atomic.AddUint64(&mmOpen.afterOpenCounter, 1)

	if mmOpen.inspectFuncOpen != nil {
		mmOpen.inspectFuncOpen()
	}

	if mmOpen.OpenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOpen.OpenMock.defaultExpectation.Counter, 1)

		mm_results := mmOpen.OpenMock.defaultExpectation.results
		if mm_results == nil {
			mmOpen.t.Fatal("No results are set for the JPlanMock.Open")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmOpen.funcOpen != nil {
		return mmOpen.funcOpen()
	}
	mmOpen.t.Fatalf("Unexpected call to JPlanMock.Open.")
	return
}

// OpenAfterCounter returns a count of finished JPlanMock.Open invocations
func (mmOpen *JPlanMock) OpenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.afterOpenCounter)
}

// OpenBeforeCounter returns a count of JPlanMock.Open invocations
func (mmOpen *JPlanMock) OpenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.beforeOpenCounter)
}

// MinimockOpenDone returns true if the count of the Open invocations corresponds
// the number of defined expectations
func (m *JPlanMock) MinimockOpenDone() bool {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	return true
}

// MinimockOpenInspect logs each unmet expectation
func (m *JPlanMock) MinimockOpenInspect() {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JPlanMock.Open")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		m.t.Error("Expected call to JPlanMock.Open")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		m.t.Error("Expected call to JPlanMock.Open")
	}
}

type mJPlanMockRecords struct {
	mock               *JPlanMock
	defaultExpectation *JPlanMockRecordsExpectation
	expectations       []*JPlanMockRecordsExpectation
}

// JPlanMockRecordsExpectation specifies expectation struct of the jPlan.Records
type JPlanMockRecordsExpectation struct {
	mock *JPlanMock

	results *JPlanMockRecordsResults
	Counter uint64
}

// JPlanMockRecordsResults contains results of the jPlan.Records
type JPlanMockRecordsResults struct {
	i1 int64
}

// Expect sets up expected params for jPlan.Records
func (mmRecords *mJPlanMockRecords) Expect() *mJPlanMockRecords {
	if mmRecords.mock.funcRecords != nil {
		mmRecords.mock.t.Fatalf("JPlanMock.Records mock is already set by Set")
	}

	if mmRecords.defaultExpectation == nil {
		mmRecords.defaultExpectation = &JPlanMockRecordsExpectation{}
	}

	return mmRecords
}

// Inspect accepts an inspector function that has same arguments as the jPlan.Records
func (mmRecords *mJPlanMockRecords) Inspect(f func()) *mJPlanMockRecords {
	if mmRecords.mock.inspectFuncRecords != nil {
		mmRecords.mock.t.Fatalf("Inspect function is already set for JPlanMock.Records")
	}

	mmRecords.mock.inspectFuncRecords = f

	return mmRecords
}

// Return sets up results that will be returned by jPlan.Records
func (mmRecords *mJPlanMockRecords) Return(i1 int64) *JPlanMock {
	if mmRecords.mock.funcRecords != nil {
		mmRecords.mock.t.Fatalf("JPlanMock.Records mock is already set by Set")
	}

	if mmRecords.defaultExpectation == nil {
		mmRecords.defaultExpectation = &JPlanMockRecordsExpectation{mock: mmRecords.mock}
	}
	mmRecords.defaultExpectation.results = &JPlanMockRecordsResults{i1}
	return mmRecords.mock
}

//Set uses given function f to mock the jPlan.Records method
func (mmRecords *mJPlanMockRecords) Set(f func() (i1 int64)) *JPlanMock {
	if mmRecords.defaultExpectation != nil {
		mmRecords.mock.t.Fatalf("Default expectation is already set for the jPlan.Records method")
	}

	if len(mmRecords.expectations) > 0 {
		mmRecords.mock.t.Fatalf("Some expectations are already set for the jPlan.Records method")
	}

	mmRecords.mock.funcRecords = f
	return mmRecords.mock
}

// Records implements jPlan
func (mmRecords *JPlanMock) Records() (i1 int64) {
	mm_atomic.AddUint64(&mmRecords.beforeRecordsCounter, 1)
	defer mm_atomic.AddUint64(&mmRecords.afterRecordsCounter, 1)

	if mmRecords.inspectFuncRecords != nil {
		mmRecords.inspectFuncRecords()
	}

	if mmRecords.RecordsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecords.RecordsMock.defaultExpectation.Counter, 1)

		mm_results := mmRecords.RecordsMock.defaultExpectation.results
		if mm_results == nil {
			mmRecords.t.Fatal("No results are set for the JPlanMock.Records")
		}
		return (*mm_results).i1
	}
	if mmRecords.funcRecords != nil {
		return mmRecords.funcRecords()
	}
	mmRecords.t.Fatalf("Unexpected call to JPlanMock.Records.")
	return
}

// RecordsAfterCounter returns a count of finished JPlanMock.Records invocations
func (mmRecords *JPlanMock) RecordsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecords.afterRecordsCounter)
}

// RecordsBeforeCounter returns a count of JPlanMock.Records invocations
func (mmRecords *JPlanMock) RecordsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecords.beforeRecordsCounter)
}

// MinimockRecordsDone returns true if the count of the Records invocations corresponds
// the number of defined expectations
func (m *JPlanMock) MinimockRecordsDone() bool {
	for _, e := range m.RecordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecordsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecordsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecords != nil && mm_atomic.LoadUint64(&m.afterRecordsCounter) < 1 {
		return false
	}
	return true
}

// MinimockRecordsInspect logs each unmet expectation
func (m *JPlanMock) MinimockRecordsInspect() {
	for _, e := range m.RecordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JPlanMock.Records")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecordsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecordsCounter) < 1 {
		m.t.Error("Expected call to JPlanMock.Records")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecords != nil && mm_atomic.LoadUint64(&m.afterRecordsCounter) < 1 {
		m.t.Error("Expected call to JPlanMock.Records")
	}
}

type mJPlanMockSchema struct {
	mock               *JPlanMock
	defaultExpectation *JPlanMockSchemaExpectation
	expectations       []*JPlanMockSchemaExpectation
}

// JPlanMockSchemaExpectation specifies expectation struct of the jPlan.Schema
type JPlanMockSchemaExpectation struct {
	mock *JPlanMock

	results *JPlanMockSchemaResults
	Counter uint64
}

// JPlanMockSchemaResults contains results of the jPlan.Schema
type JPlanMockSchemaResults struct {
	s1 records.Schema
}

// Expect sets up expected params for jPlan.Schema
func (mmSchema *mJPlanMockSchema) Expect() *mJPlanMockSchema {
	if mmSchema.mock.funcSchema != nil {
		mmSchema.mock.t.Fatalf("JPlanMock.Schema mock is already set by Set")
	}

	if mmSchema.defaultExpectation == nil {
		mmSchema.defaultExpectation = &JPlanMockSchemaExpectation{}
	}

	return mmSchema
}

// Inspect accepts an inspector function that has same arguments as the jPlan.Schema
func (mmSchema *mJPlanMockSchema) Inspect(f func()) *mJPlanMockSchema {
	if mmSchema.mock.inspectFuncSchema != nil {
		mmSchema.mock.t.Fatalf("Inspect function is already set for JPlanMock.Schema")
	}

	mmSchema.mock.inspectFuncSchema = f

	return mmSchema
}

// Return sets up results that will be returned by jPlan.Schema
func (mmSchema *mJPlanMockSchema) Return(s1 records.Schema) *JPlanMock {
	if mmSchema.mock.funcSchema != nil {
		mmSchema.mock.t.Fatalf("JPlanMock.Schema mock is already set by Set")
	}

	if mmSchema.defaultExpectation == nil {
		mmSchema.defaultExpectation = &JPlanMockSchemaExpectation{mock: mmSchema.mock}
	}
	mmSchema.defaultExpectation.results = &JPlanMockSchemaResults{s1}
	return mmSchema.mock
}

//Set uses given function f to mock the jPlan.Schema method
func (mmSchema *mJPlanMockSchema) Set(f func() (s1 records.Schema)) *JPlanMock {
	if mmSchema.defaultExpectation != nil {
		mmSchema.mock.t.Fatalf("Default expectation is already set for the jPlan.Schema method")
	}

	if len(mmSchema.expectations) > 0 {
		mmSchema.mock.t.Fatalf("Some expectations are already set for the jPlan.Schema method")
	}

	mmSchema.mock.funcSchema = f
	return mmSchema.mock
}

// Schema implements jPlan
func (mmSchema *JPlanMock) Schema() (s1 records.Schema) {
	mm_atomic.AddUint64(&mmSchema.beforeSchemaCounter, 1)
	defer mm_atomic.AddUint64(&mmSchema.afterSchemaCounter, 1)

	if mmSchema.inspectFuncSchema != nil {
		mmSchema.inspectFuncSchema()
	}

	if mmSchema.SchemaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSchema.SchemaMock.defaultExpectation.Counter, 1)

		mm_results := mmSchema.SchemaMock.defaultExpectation.results
		if mm_results == nil {
			mmSchema.t.Fatal("No results are set for the JPlanMock.Schema")
		}
		return (*mm_results).s1
	}
	if mmSchema.funcSchema != nil {
		return mmSchema.funcSchema()
	}
	mmSchema.t.Fatalf("Unexpected call to JPlanMock.Schema.")
	return
}

// SchemaAfterCounter returns a count of finished JPlanMock.Schema invocations
func (mmSchema *JPlanMock) SchemaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSchema.afterSchemaCounter)
}

// SchemaBeforeCounter returns a count of JPlanMock.Schema invocations
func (mmSchema *JPlanMock) SchemaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSchema.beforeSchemaCounter)
}

// MinimockSchemaDone returns true if the count of the Schema invocations corresponds
// the number of defined expectations
func (m *JPlanMock) MinimockSchemaDone() bool {
	for _, e := range m.SchemaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SchemaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSchemaCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSchema != nil && mm_atomic.LoadUint64(&m.afterSchemaCounter) < 1 {
		return false
	}
	return true
}

// MinimockSchemaInspect logs each unmet expectation
func (m *JPlanMock) MinimockSchemaInspect() {
	for _, e := range m.SchemaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JPlanMock.Schema")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SchemaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSchemaCounter) < 1 {
		m.t.Error("Expected call to JPlanMock.Schema")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSchema != nil && mm_atomic.LoadUint64(&m.afterSchemaCounter) < 1 {
		m.t.Error("Expected call to JPlanMock.Schema")
	}
}

type mJPlanMockString struct {
	mock               *JPlanMock
	defaultExpectation *JPlanMockStringExpectation
	expectations       []*JPlanMockStringExpectation
}

// JPlanMockStringExpectation specifies expectation struct of the jPlan.String
type JPlanMockStringExpectation struct {
	mock *JPlanMock

	results *JPlanMockStringResults
	Counter uint64
}

// JPlanMockStringResults contains results of the jPlan.String
type JPlanMockStringResults struct {
	s1 string
}

// Expect sets up expected params for jPlan.String
func (mmString *mJPlanMockString) Expect() *mJPlanMockString {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("JPlanMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &JPlanMockStringExpectation{}
	}

	return mmString
}

// Inspect accepts an inspector function that has same arguments as the jPlan.String
func (mmString *mJPlanMockString) Inspect(f func()) *mJPlanMockString {
	if mmString.mock.inspectFuncString != nil {
		mmString.mock.t.Fatalf("Inspect function is already set for JPlanMock.String")
	}

	mmString.mock.inspectFuncString = f

	return mmString
}

// Return sets up results that will be returned by jPlan.String
func (mmString *mJPlanMockString) Return(s1 string) *JPlanMock {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("JPlanMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &JPlanMockStringExpectation{mock: mmString.mock}
	}
	mmString.defaultExpectation.results = &JPlanMockStringResults{s1}
	return mmString.mock
}

//Set uses given function f to mock the jPlan.String method
func (mmString *mJPlanMockString) Set(f func() (s1 string)) *JPlanMock {
	if mmString.defaultExpectation != nil {
		mmString.mock.t.Fatalf("Default expectation is already set for the jPlan.String method")
	}

	if len(mmString.expectations) > 0 {
		mmString.mock.t.Fatalf("Some expectations are already set for the jPlan.String method")
	}

	mmString.mock.funcString = f
	return mmString.mock
}

// String implements jPlan
func (mmString *JPlanMock) String() (s1 string) {
	mm_atomic.AddUint64(&mmString.beforeStringCounter, 1)
	defer mm_atomic.AddUint64(&mmString.afterStringCounter, 1)

	if mmString.inspectFuncString != nil {
		mmString.inspectFuncString()
	}

	if mmString.StringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmString.StringMock.defaultExpectation.Counter, 1)

		mm_results := mmString.StringMock.defaultExpectation.results
		if mm_results == nil {
			mmString.t.Fatal("No results are set for the JPlanMock.String")
		}
		return (*mm_results).s1
	}
	if mmString.funcString != nil {
		return mmString.funcString()
	}
	mmString.t.Fatalf("Unexpected call to JPlanMock.String.")
	return
}

// StringAfterCounter returns a count of finished JPlanMock.String invocations
func (mmString *JPlanMock) StringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.afterStringCounter)
}

// StringBeforeCounter returns a count of JPlanMock.String invocations
func (mmString *JPlanMock) StringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.beforeStringCounter)
}

// MinimockStringDone returns true if the count of the String invocations corresponds
// the number of defined expectations
func (m *JPlanMock) MinimockStringDone() bool {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockStringInspect logs each unmet expectation
func (m *JPlanMock) MinimockStringInspect() {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JPlanMock.String")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		m.t.Error("Expected call to JPlanMock.String")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		m.t.Error("Expected call to JPlanMock.String")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *JPlanMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBlocksAccessedInspect()

		m.MinimockDistinctValuesInspect()

		m.MinimockOpenInspect()

		m.MinimockRecordsInspect()

		m.MinimockSchemaInspect()

		m.MinimockStringInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *JPlanMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *JPlanMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBlocksAccessedDone() &&
		m.MinimockDistinctValuesDone() &&
		m.MinimockOpenDone() &&
		m.MinimockRecordsDone() &&
		m.MinimockSchemaDone() &&
		m.MinimockStringDone()
}
