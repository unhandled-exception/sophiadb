package indexplanner

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/unhandled-exception/sophiadb/internal/pkg/indexplanner.sPlan -o ./mock_splan_test.go -n SPlanMock

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/unhandled-exception/sophiadb/internal/pkg/records"
	"github.com/unhandled-exception/sophiadb/internal/pkg/scan"
)

// SPlanMock implements sPlan
type SPlanMock struct {
	t minimock.Tester

	funcOpen          func() (s1 scan.Scan, err error)
	inspectFuncOpen   func()
	afterOpenCounter  uint64
	beforeOpenCounter uint64
	OpenMock          mSPlanMockOpen

	funcSchema          func() (s1 records.Schema)
	inspectFuncSchema   func()
	afterSchemaCounter  uint64
	beforeSchemaCounter uint64
	SchemaMock          mSPlanMockSchema

	funcString          func() (s1 string)
	inspectFuncString   func()
	afterStringCounter  uint64
	beforeStringCounter uint64
	StringMock          mSPlanMockString
}

// NewSPlanMock returns a mock for sPlan
func NewSPlanMock(t minimock.Tester) *SPlanMock {
	m := &SPlanMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.OpenMock = mSPlanMockOpen{mock: m}

	m.SchemaMock = mSPlanMockSchema{mock: m}

	m.StringMock = mSPlanMockString{mock: m}

	return m
}

type mSPlanMockOpen struct {
	mock               *SPlanMock
	defaultExpectation *SPlanMockOpenExpectation
	expectations       []*SPlanMockOpenExpectation
}

// SPlanMockOpenExpectation specifies expectation struct of the sPlan.Open
type SPlanMockOpenExpectation struct {
	mock *SPlanMock

	results *SPlanMockOpenResults
	Counter uint64
}

// SPlanMockOpenResults contains results of the sPlan.Open
type SPlanMockOpenResults struct {
	s1  scan.Scan
	err error
}

// Expect sets up expected params for sPlan.Open
func (mmOpen *mSPlanMockOpen) Expect() *mSPlanMockOpen {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("SPlanMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &SPlanMockOpenExpectation{}
	}

	return mmOpen
}

// Inspect accepts an inspector function that has same arguments as the sPlan.Open
func (mmOpen *mSPlanMockOpen) Inspect(f func()) *mSPlanMockOpen {
	if mmOpen.mock.inspectFuncOpen != nil {
		mmOpen.mock.t.Fatalf("Inspect function is already set for SPlanMock.Open")
	}

	mmOpen.mock.inspectFuncOpen = f

	return mmOpen
}

// Return sets up results that will be returned by sPlan.Open
func (mmOpen *mSPlanMockOpen) Return(s1 scan.Scan, err error) *SPlanMock {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("SPlanMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &SPlanMockOpenExpectation{mock: mmOpen.mock}
	}
	mmOpen.defaultExpectation.results = &SPlanMockOpenResults{s1, err}
	return mmOpen.mock
}

//Set uses given function f to mock the sPlan.Open method
func (mmOpen *mSPlanMockOpen) Set(f func() (s1 scan.Scan, err error)) *SPlanMock {
	if mmOpen.defaultExpectation != nil {
		mmOpen.mock.t.Fatalf("Default expectation is already set for the sPlan.Open method")
	}

	if len(mmOpen.expectations) > 0 {
		mmOpen.mock.t.Fatalf("Some expectations are already set for the sPlan.Open method")
	}

	mmOpen.mock.funcOpen = f
	return mmOpen.mock
}

// Open implements sPlan
func (mmOpen *SPlanMock) Open() (s1 scan.Scan, err error) {
	mm_atomic.AddUint64(&mmOpen.beforeOpenCounter, 1)
	defer mm_atomic.AddUint64(&mmOpen.afterOpenCounter, 1)

	if mmOpen.inspectFuncOpen != nil {
		mmOpen.inspectFuncOpen()
	}

	if mmOpen.OpenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOpen.OpenMock.defaultExpectation.Counter, 1)

		mm_results := mmOpen.OpenMock.defaultExpectation.results
		if mm_results == nil {
			mmOpen.t.Fatal("No results are set for the SPlanMock.Open")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmOpen.funcOpen != nil {
		return mmOpen.funcOpen()
	}
	mmOpen.t.Fatalf("Unexpected call to SPlanMock.Open.")
	return
}

// OpenAfterCounter returns a count of finished SPlanMock.Open invocations
func (mmOpen *SPlanMock) OpenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.afterOpenCounter)
}

// OpenBeforeCounter returns a count of SPlanMock.Open invocations
func (mmOpen *SPlanMock) OpenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.beforeOpenCounter)
}

// MinimockOpenDone returns true if the count of the Open invocations corresponds
// the number of defined expectations
func (m *SPlanMock) MinimockOpenDone() bool {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	return true
}

// MinimockOpenInspect logs each unmet expectation
func (m *SPlanMock) MinimockOpenInspect() {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SPlanMock.Open")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		m.t.Error("Expected call to SPlanMock.Open")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		m.t.Error("Expected call to SPlanMock.Open")
	}
}

type mSPlanMockSchema struct {
	mock               *SPlanMock
	defaultExpectation *SPlanMockSchemaExpectation
	expectations       []*SPlanMockSchemaExpectation
}

// SPlanMockSchemaExpectation specifies expectation struct of the sPlan.Schema
type SPlanMockSchemaExpectation struct {
	mock *SPlanMock

	results *SPlanMockSchemaResults
	Counter uint64
}

// SPlanMockSchemaResults contains results of the sPlan.Schema
type SPlanMockSchemaResults struct {
	s1 records.Schema
}

// Expect sets up expected params for sPlan.Schema
func (mmSchema *mSPlanMockSchema) Expect() *mSPlanMockSchema {
	if mmSchema.mock.funcSchema != nil {
		mmSchema.mock.t.Fatalf("SPlanMock.Schema mock is already set by Set")
	}

	if mmSchema.defaultExpectation == nil {
		mmSchema.defaultExpectation = &SPlanMockSchemaExpectation{}
	}

	return mmSchema
}

// Inspect accepts an inspector function that has same arguments as the sPlan.Schema
func (mmSchema *mSPlanMockSchema) Inspect(f func()) *mSPlanMockSchema {
	if mmSchema.mock.inspectFuncSchema != nil {
		mmSchema.mock.t.Fatalf("Inspect function is already set for SPlanMock.Schema")
	}

	mmSchema.mock.inspectFuncSchema = f

	return mmSchema
}

// Return sets up results that will be returned by sPlan.Schema
func (mmSchema *mSPlanMockSchema) Return(s1 records.Schema) *SPlanMock {
	if mmSchema.mock.funcSchema != nil {
		mmSchema.mock.t.Fatalf("SPlanMock.Schema mock is already set by Set")
	}

	if mmSchema.defaultExpectation == nil {
		mmSchema.defaultExpectation = &SPlanMockSchemaExpectation{mock: mmSchema.mock}
	}
	mmSchema.defaultExpectation.results = &SPlanMockSchemaResults{s1}
	return mmSchema.mock
}

//Set uses given function f to mock the sPlan.Schema method
func (mmSchema *mSPlanMockSchema) Set(f func() (s1 records.Schema)) *SPlanMock {
	if mmSchema.defaultExpectation != nil {
		mmSchema.mock.t.Fatalf("Default expectation is already set for the sPlan.Schema method")
	}

	if len(mmSchema.expectations) > 0 {
		mmSchema.mock.t.Fatalf("Some expectations are already set for the sPlan.Schema method")
	}

	mmSchema.mock.funcSchema = f
	return mmSchema.mock
}

// Schema implements sPlan
func (mmSchema *SPlanMock) Schema() (s1 records.Schema) {
	mm_atomic.AddUint64(&mmSchema.beforeSchemaCounter, 1)
	defer mm_atomic.AddUint64(&mmSchema.afterSchemaCounter, 1)

	if mmSchema.inspectFuncSchema != nil {
		mmSchema.inspectFuncSchema()
	}

	if mmSchema.SchemaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSchema.SchemaMock.defaultExpectation.Counter, 1)

		mm_results := mmSchema.SchemaMock.defaultExpectation.results
		if mm_results == nil {
			mmSchema.t.Fatal("No results are set for the SPlanMock.Schema")
		}
		return (*mm_results).s1
	}
	if mmSchema.funcSchema != nil {
		return mmSchema.funcSchema()
	}
	mmSchema.t.Fatalf("Unexpected call to SPlanMock.Schema.")
	return
}

// SchemaAfterCounter returns a count of finished SPlanMock.Schema invocations
func (mmSchema *SPlanMock) SchemaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSchema.afterSchemaCounter)
}

// SchemaBeforeCounter returns a count of SPlanMock.Schema invocations
func (mmSchema *SPlanMock) SchemaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSchema.beforeSchemaCounter)
}

// MinimockSchemaDone returns true if the count of the Schema invocations corresponds
// the number of defined expectations
func (m *SPlanMock) MinimockSchemaDone() bool {
	for _, e := range m.SchemaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SchemaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSchemaCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSchema != nil && mm_atomic.LoadUint64(&m.afterSchemaCounter) < 1 {
		return false
	}
	return true
}

// MinimockSchemaInspect logs each unmet expectation
func (m *SPlanMock) MinimockSchemaInspect() {
	for _, e := range m.SchemaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SPlanMock.Schema")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SchemaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSchemaCounter) < 1 {
		m.t.Error("Expected call to SPlanMock.Schema")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSchema != nil && mm_atomic.LoadUint64(&m.afterSchemaCounter) < 1 {
		m.t.Error("Expected call to SPlanMock.Schema")
	}
}

type mSPlanMockString struct {
	mock               *SPlanMock
	defaultExpectation *SPlanMockStringExpectation
	expectations       []*SPlanMockStringExpectation
}

// SPlanMockStringExpectation specifies expectation struct of the sPlan.String
type SPlanMockStringExpectation struct {
	mock *SPlanMock

	results *SPlanMockStringResults
	Counter uint64
}

// SPlanMockStringResults contains results of the sPlan.String
type SPlanMockStringResults struct {
	s1 string
}

// Expect sets up expected params for sPlan.String
func (mmString *mSPlanMockString) Expect() *mSPlanMockString {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("SPlanMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &SPlanMockStringExpectation{}
	}

	return mmString
}

// Inspect accepts an inspector function that has same arguments as the sPlan.String
func (mmString *mSPlanMockString) Inspect(f func()) *mSPlanMockString {
	if mmString.mock.inspectFuncString != nil {
		mmString.mock.t.Fatalf("Inspect function is already set for SPlanMock.String")
	}

	mmString.mock.inspectFuncString = f

	return mmString
}

// Return sets up results that will be returned by sPlan.String
func (mmString *mSPlanMockString) Return(s1 string) *SPlanMock {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("SPlanMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &SPlanMockStringExpectation{mock: mmString.mock}
	}
	mmString.defaultExpectation.results = &SPlanMockStringResults{s1}
	return mmString.mock
}

//Set uses given function f to mock the sPlan.String method
func (mmString *mSPlanMockString) Set(f func() (s1 string)) *SPlanMock {
	if mmString.defaultExpectation != nil {
		mmString.mock.t.Fatalf("Default expectation is already set for the sPlan.String method")
	}

	if len(mmString.expectations) > 0 {
		mmString.mock.t.Fatalf("Some expectations are already set for the sPlan.String method")
	}

	mmString.mock.funcString = f
	return mmString.mock
}

// String implements sPlan
func (mmString *SPlanMock) String() (s1 string) {
	mm_atomic.AddUint64(&mmString.beforeStringCounter, 1)
	defer mm_atomic.AddUint64(&mmString.afterStringCounter, 1)

	if mmString.inspectFuncString != nil {
		mmString.inspectFuncString()
	}

	if mmString.StringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmString.StringMock.defaultExpectation.Counter, 1)

		mm_results := mmString.StringMock.defaultExpectation.results
		if mm_results == nil {
			mmString.t.Fatal("No results are set for the SPlanMock.String")
		}
		return (*mm_results).s1
	}
	if mmString.funcString != nil {
		return mmString.funcString()
	}
	mmString.t.Fatalf("Unexpected call to SPlanMock.String.")
	return
}

// StringAfterCounter returns a count of finished SPlanMock.String invocations
func (mmString *SPlanMock) StringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.afterStringCounter)
}

// StringBeforeCounter returns a count of SPlanMock.String invocations
func (mmString *SPlanMock) StringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.beforeStringCounter)
}

// MinimockStringDone returns true if the count of the String invocations corresponds
// the number of defined expectations
func (m *SPlanMock) MinimockStringDone() bool {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockStringInspect logs each unmet expectation
func (m *SPlanMock) MinimockStringInspect() {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SPlanMock.String")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		m.t.Error("Expected call to SPlanMock.String")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		m.t.Error("Expected call to SPlanMock.String")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SPlanMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockOpenInspect()

		m.MinimockSchemaInspect()

		m.MinimockStringInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SPlanMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SPlanMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockOpenDone() &&
		m.MinimockSchemaDone() &&
		m.MinimockStringDone()
}
