package indexplanner

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/unhandled-exception/sophiadb/internal/pkg/indexplanner.sIndexInfo -o ./mock_sindex_info_test.go -n SIndexInfoMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/unhandled-exception/sophiadb/internal/pkg/indexes"
)

// SIndexInfoMock implements sIndexInfo
type SIndexInfoMock struct {
	t minimock.Tester

	funcBlocksAccessed          func() (i1 int64)
	inspectFuncBlocksAccessed   func()
	afterBlocksAccessedCounter  uint64
	beforeBlocksAccessedCounter uint64
	BlocksAccessedMock          mSIndexInfoMockBlocksAccessed

	funcDistinctValues          func(fieldName string) (i1 int64)
	inspectFuncDistinctValues   func(fieldName string)
	afterDistinctValuesCounter  uint64
	beforeDistinctValuesCounter uint64
	DistinctValuesMock          mSIndexInfoMockDistinctValues

	funcOpen          func() (i1 indexes.Index, err error)
	inspectFuncOpen   func()
	afterOpenCounter  uint64
	beforeOpenCounter uint64
	OpenMock          mSIndexInfoMockOpen

	funcRecords          func() (i1 int64)
	inspectFuncRecords   func()
	afterRecordsCounter  uint64
	beforeRecordsCounter uint64
	RecordsMock          mSIndexInfoMockRecords

	funcString          func() (s1 string)
	inspectFuncString   func()
	afterStringCounter  uint64
	beforeStringCounter uint64
	StringMock          mSIndexInfoMockString
}

// NewSIndexInfoMock returns a mock for sIndexInfo
func NewSIndexInfoMock(t minimock.Tester) *SIndexInfoMock {
	m := &SIndexInfoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BlocksAccessedMock = mSIndexInfoMockBlocksAccessed{mock: m}

	m.DistinctValuesMock = mSIndexInfoMockDistinctValues{mock: m}
	m.DistinctValuesMock.callArgs = []*SIndexInfoMockDistinctValuesParams{}

	m.OpenMock = mSIndexInfoMockOpen{mock: m}

	m.RecordsMock = mSIndexInfoMockRecords{mock: m}

	m.StringMock = mSIndexInfoMockString{mock: m}

	return m
}

type mSIndexInfoMockBlocksAccessed struct {
	mock               *SIndexInfoMock
	defaultExpectation *SIndexInfoMockBlocksAccessedExpectation
	expectations       []*SIndexInfoMockBlocksAccessedExpectation
}

// SIndexInfoMockBlocksAccessedExpectation specifies expectation struct of the sIndexInfo.BlocksAccessed
type SIndexInfoMockBlocksAccessedExpectation struct {
	mock *SIndexInfoMock

	results *SIndexInfoMockBlocksAccessedResults
	Counter uint64
}

// SIndexInfoMockBlocksAccessedResults contains results of the sIndexInfo.BlocksAccessed
type SIndexInfoMockBlocksAccessedResults struct {
	i1 int64
}

// Expect sets up expected params for sIndexInfo.BlocksAccessed
func (mmBlocksAccessed *mSIndexInfoMockBlocksAccessed) Expect() *mSIndexInfoMockBlocksAccessed {
	if mmBlocksAccessed.mock.funcBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("SIndexInfoMock.BlocksAccessed mock is already set by Set")
	}

	if mmBlocksAccessed.defaultExpectation == nil {
		mmBlocksAccessed.defaultExpectation = &SIndexInfoMockBlocksAccessedExpectation{}
	}

	return mmBlocksAccessed
}

// Inspect accepts an inspector function that has same arguments as the sIndexInfo.BlocksAccessed
func (mmBlocksAccessed *mSIndexInfoMockBlocksAccessed) Inspect(f func()) *mSIndexInfoMockBlocksAccessed {
	if mmBlocksAccessed.mock.inspectFuncBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("Inspect function is already set for SIndexInfoMock.BlocksAccessed")
	}

	mmBlocksAccessed.mock.inspectFuncBlocksAccessed = f

	return mmBlocksAccessed
}

// Return sets up results that will be returned by sIndexInfo.BlocksAccessed
func (mmBlocksAccessed *mSIndexInfoMockBlocksAccessed) Return(i1 int64) *SIndexInfoMock {
	if mmBlocksAccessed.mock.funcBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("SIndexInfoMock.BlocksAccessed mock is already set by Set")
	}

	if mmBlocksAccessed.defaultExpectation == nil {
		mmBlocksAccessed.defaultExpectation = &SIndexInfoMockBlocksAccessedExpectation{mock: mmBlocksAccessed.mock}
	}
	mmBlocksAccessed.defaultExpectation.results = &SIndexInfoMockBlocksAccessedResults{i1}
	return mmBlocksAccessed.mock
}

//Set uses given function f to mock the sIndexInfo.BlocksAccessed method
func (mmBlocksAccessed *mSIndexInfoMockBlocksAccessed) Set(f func() (i1 int64)) *SIndexInfoMock {
	if mmBlocksAccessed.defaultExpectation != nil {
		mmBlocksAccessed.mock.t.Fatalf("Default expectation is already set for the sIndexInfo.BlocksAccessed method")
	}

	if len(mmBlocksAccessed.expectations) > 0 {
		mmBlocksAccessed.mock.t.Fatalf("Some expectations are already set for the sIndexInfo.BlocksAccessed method")
	}

	mmBlocksAccessed.mock.funcBlocksAccessed = f
	return mmBlocksAccessed.mock
}

// BlocksAccessed implements sIndexInfo
func (mmBlocksAccessed *SIndexInfoMock) BlocksAccessed() (i1 int64) {
	mm_atomic.AddUint64(&mmBlocksAccessed.beforeBlocksAccessedCounter, 1)
	defer mm_atomic.AddUint64(&mmBlocksAccessed.afterBlocksAccessedCounter, 1)

	if mmBlocksAccessed.inspectFuncBlocksAccessed != nil {
		mmBlocksAccessed.inspectFuncBlocksAccessed()
	}

	if mmBlocksAccessed.BlocksAccessedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBlocksAccessed.BlocksAccessedMock.defaultExpectation.Counter, 1)

		mm_results := mmBlocksAccessed.BlocksAccessedMock.defaultExpectation.results
		if mm_results == nil {
			mmBlocksAccessed.t.Fatal("No results are set for the SIndexInfoMock.BlocksAccessed")
		}
		return (*mm_results).i1
	}
	if mmBlocksAccessed.funcBlocksAccessed != nil {
		return mmBlocksAccessed.funcBlocksAccessed()
	}
	mmBlocksAccessed.t.Fatalf("Unexpected call to SIndexInfoMock.BlocksAccessed.")
	return
}

// BlocksAccessedAfterCounter returns a count of finished SIndexInfoMock.BlocksAccessed invocations
func (mmBlocksAccessed *SIndexInfoMock) BlocksAccessedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBlocksAccessed.afterBlocksAccessedCounter)
}

// BlocksAccessedBeforeCounter returns a count of SIndexInfoMock.BlocksAccessed invocations
func (mmBlocksAccessed *SIndexInfoMock) BlocksAccessedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBlocksAccessed.beforeBlocksAccessedCounter)
}

// MinimockBlocksAccessedDone returns true if the count of the BlocksAccessed invocations corresponds
// the number of defined expectations
func (m *SIndexInfoMock) MinimockBlocksAccessedDone() bool {
	for _, e := range m.BlocksAccessedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BlocksAccessedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBlocksAccessedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBlocksAccessed != nil && mm_atomic.LoadUint64(&m.afterBlocksAccessedCounter) < 1 {
		return false
	}
	return true
}

// MinimockBlocksAccessedInspect logs each unmet expectation
func (m *SIndexInfoMock) MinimockBlocksAccessedInspect() {
	for _, e := range m.BlocksAccessedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SIndexInfoMock.BlocksAccessed")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BlocksAccessedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBlocksAccessedCounter) < 1 {
		m.t.Error("Expected call to SIndexInfoMock.BlocksAccessed")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBlocksAccessed != nil && mm_atomic.LoadUint64(&m.afterBlocksAccessedCounter) < 1 {
		m.t.Error("Expected call to SIndexInfoMock.BlocksAccessed")
	}
}

type mSIndexInfoMockDistinctValues struct {
	mock               *SIndexInfoMock
	defaultExpectation *SIndexInfoMockDistinctValuesExpectation
	expectations       []*SIndexInfoMockDistinctValuesExpectation

	callArgs []*SIndexInfoMockDistinctValuesParams
	mutex    sync.RWMutex
}

// SIndexInfoMockDistinctValuesExpectation specifies expectation struct of the sIndexInfo.DistinctValues
type SIndexInfoMockDistinctValuesExpectation struct {
	mock    *SIndexInfoMock
	params  *SIndexInfoMockDistinctValuesParams
	results *SIndexInfoMockDistinctValuesResults
	Counter uint64
}

// SIndexInfoMockDistinctValuesParams contains parameters of the sIndexInfo.DistinctValues
type SIndexInfoMockDistinctValuesParams struct {
	fieldName string
}

// SIndexInfoMockDistinctValuesResults contains results of the sIndexInfo.DistinctValues
type SIndexInfoMockDistinctValuesResults struct {
	i1 int64
}

// Expect sets up expected params for sIndexInfo.DistinctValues
func (mmDistinctValues *mSIndexInfoMockDistinctValues) Expect(fieldName string) *mSIndexInfoMockDistinctValues {
	if mmDistinctValues.mock.funcDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("SIndexInfoMock.DistinctValues mock is already set by Set")
	}

	if mmDistinctValues.defaultExpectation == nil {
		mmDistinctValues.defaultExpectation = &SIndexInfoMockDistinctValuesExpectation{}
	}

	mmDistinctValues.defaultExpectation.params = &SIndexInfoMockDistinctValuesParams{fieldName}
	for _, e := range mmDistinctValues.expectations {
		if minimock.Equal(e.params, mmDistinctValues.defaultExpectation.params) {
			mmDistinctValues.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDistinctValues.defaultExpectation.params)
		}
	}

	return mmDistinctValues
}

// Inspect accepts an inspector function that has same arguments as the sIndexInfo.DistinctValues
func (mmDistinctValues *mSIndexInfoMockDistinctValues) Inspect(f func(fieldName string)) *mSIndexInfoMockDistinctValues {
	if mmDistinctValues.mock.inspectFuncDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("Inspect function is already set for SIndexInfoMock.DistinctValues")
	}

	mmDistinctValues.mock.inspectFuncDistinctValues = f

	return mmDistinctValues
}

// Return sets up results that will be returned by sIndexInfo.DistinctValues
func (mmDistinctValues *mSIndexInfoMockDistinctValues) Return(i1 int64) *SIndexInfoMock {
	if mmDistinctValues.mock.funcDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("SIndexInfoMock.DistinctValues mock is already set by Set")
	}

	if mmDistinctValues.defaultExpectation == nil {
		mmDistinctValues.defaultExpectation = &SIndexInfoMockDistinctValuesExpectation{mock: mmDistinctValues.mock}
	}
	mmDistinctValues.defaultExpectation.results = &SIndexInfoMockDistinctValuesResults{i1}
	return mmDistinctValues.mock
}

//Set uses given function f to mock the sIndexInfo.DistinctValues method
func (mmDistinctValues *mSIndexInfoMockDistinctValues) Set(f func(fieldName string) (i1 int64)) *SIndexInfoMock {
	if mmDistinctValues.defaultExpectation != nil {
		mmDistinctValues.mock.t.Fatalf("Default expectation is already set for the sIndexInfo.DistinctValues method")
	}

	if len(mmDistinctValues.expectations) > 0 {
		mmDistinctValues.mock.t.Fatalf("Some expectations are already set for the sIndexInfo.DistinctValues method")
	}

	mmDistinctValues.mock.funcDistinctValues = f
	return mmDistinctValues.mock
}

// When sets expectation for the sIndexInfo.DistinctValues which will trigger the result defined by the following
// Then helper
func (mmDistinctValues *mSIndexInfoMockDistinctValues) When(fieldName string) *SIndexInfoMockDistinctValuesExpectation {
	if mmDistinctValues.mock.funcDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("SIndexInfoMock.DistinctValues mock is already set by Set")
	}

	expectation := &SIndexInfoMockDistinctValuesExpectation{
		mock:   mmDistinctValues.mock,
		params: &SIndexInfoMockDistinctValuesParams{fieldName},
	}
	mmDistinctValues.expectations = append(mmDistinctValues.expectations, expectation)
	return expectation
}

// Then sets up sIndexInfo.DistinctValues return parameters for the expectation previously defined by the When method
func (e *SIndexInfoMockDistinctValuesExpectation) Then(i1 int64) *SIndexInfoMock {
	e.results = &SIndexInfoMockDistinctValuesResults{i1}
	return e.mock
}

// DistinctValues implements sIndexInfo
func (mmDistinctValues *SIndexInfoMock) DistinctValues(fieldName string) (i1 int64) {
	mm_atomic.AddUint64(&mmDistinctValues.beforeDistinctValuesCounter, 1)
	defer mm_atomic.AddUint64(&mmDistinctValues.afterDistinctValuesCounter, 1)

	if mmDistinctValues.inspectFuncDistinctValues != nil {
		mmDistinctValues.inspectFuncDistinctValues(fieldName)
	}

	mm_params := &SIndexInfoMockDistinctValuesParams{fieldName}

	// Record call args
	mmDistinctValues.DistinctValuesMock.mutex.Lock()
	mmDistinctValues.DistinctValuesMock.callArgs = append(mmDistinctValues.DistinctValuesMock.callArgs, mm_params)
	mmDistinctValues.DistinctValuesMock.mutex.Unlock()

	for _, e := range mmDistinctValues.DistinctValuesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1
		}
	}

	if mmDistinctValues.DistinctValuesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDistinctValues.DistinctValuesMock.defaultExpectation.Counter, 1)
		mm_want := mmDistinctValues.DistinctValuesMock.defaultExpectation.params
		mm_got := SIndexInfoMockDistinctValuesParams{fieldName}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDistinctValues.t.Errorf("SIndexInfoMock.DistinctValues got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDistinctValues.DistinctValuesMock.defaultExpectation.results
		if mm_results == nil {
			mmDistinctValues.t.Fatal("No results are set for the SIndexInfoMock.DistinctValues")
		}
		return (*mm_results).i1
	}
	if mmDistinctValues.funcDistinctValues != nil {
		return mmDistinctValues.funcDistinctValues(fieldName)
	}
	mmDistinctValues.t.Fatalf("Unexpected call to SIndexInfoMock.DistinctValues. %v", fieldName)
	return
}

// DistinctValuesAfterCounter returns a count of finished SIndexInfoMock.DistinctValues invocations
func (mmDistinctValues *SIndexInfoMock) DistinctValuesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDistinctValues.afterDistinctValuesCounter)
}

// DistinctValuesBeforeCounter returns a count of SIndexInfoMock.DistinctValues invocations
func (mmDistinctValues *SIndexInfoMock) DistinctValuesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDistinctValues.beforeDistinctValuesCounter)
}

// Calls returns a list of arguments used in each call to SIndexInfoMock.DistinctValues.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDistinctValues *mSIndexInfoMockDistinctValues) Calls() []*SIndexInfoMockDistinctValuesParams {
	mmDistinctValues.mutex.RLock()

	argCopy := make([]*SIndexInfoMockDistinctValuesParams, len(mmDistinctValues.callArgs))
	copy(argCopy, mmDistinctValues.callArgs)

	mmDistinctValues.mutex.RUnlock()

	return argCopy
}

// MinimockDistinctValuesDone returns true if the count of the DistinctValues invocations corresponds
// the number of defined expectations
func (m *SIndexInfoMock) MinimockDistinctValuesDone() bool {
	for _, e := range m.DistinctValuesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DistinctValuesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDistinctValuesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDistinctValues != nil && mm_atomic.LoadUint64(&m.afterDistinctValuesCounter) < 1 {
		return false
	}
	return true
}

// MinimockDistinctValuesInspect logs each unmet expectation
func (m *SIndexInfoMock) MinimockDistinctValuesInspect() {
	for _, e := range m.DistinctValuesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SIndexInfoMock.DistinctValues with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DistinctValuesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDistinctValuesCounter) < 1 {
		if m.DistinctValuesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SIndexInfoMock.DistinctValues")
		} else {
			m.t.Errorf("Expected call to SIndexInfoMock.DistinctValues with params: %#v", *m.DistinctValuesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDistinctValues != nil && mm_atomic.LoadUint64(&m.afterDistinctValuesCounter) < 1 {
		m.t.Error("Expected call to SIndexInfoMock.DistinctValues")
	}
}

type mSIndexInfoMockOpen struct {
	mock               *SIndexInfoMock
	defaultExpectation *SIndexInfoMockOpenExpectation
	expectations       []*SIndexInfoMockOpenExpectation
}

// SIndexInfoMockOpenExpectation specifies expectation struct of the sIndexInfo.Open
type SIndexInfoMockOpenExpectation struct {
	mock *SIndexInfoMock

	results *SIndexInfoMockOpenResults
	Counter uint64
}

// SIndexInfoMockOpenResults contains results of the sIndexInfo.Open
type SIndexInfoMockOpenResults struct {
	i1  indexes.Index
	err error
}

// Expect sets up expected params for sIndexInfo.Open
func (mmOpen *mSIndexInfoMockOpen) Expect() *mSIndexInfoMockOpen {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("SIndexInfoMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &SIndexInfoMockOpenExpectation{}
	}

	return mmOpen
}

// Inspect accepts an inspector function that has same arguments as the sIndexInfo.Open
func (mmOpen *mSIndexInfoMockOpen) Inspect(f func()) *mSIndexInfoMockOpen {
	if mmOpen.mock.inspectFuncOpen != nil {
		mmOpen.mock.t.Fatalf("Inspect function is already set for SIndexInfoMock.Open")
	}

	mmOpen.mock.inspectFuncOpen = f

	return mmOpen
}

// Return sets up results that will be returned by sIndexInfo.Open
func (mmOpen *mSIndexInfoMockOpen) Return(i1 indexes.Index, err error) *SIndexInfoMock {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("SIndexInfoMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &SIndexInfoMockOpenExpectation{mock: mmOpen.mock}
	}
	mmOpen.defaultExpectation.results = &SIndexInfoMockOpenResults{i1, err}
	return mmOpen.mock
}

//Set uses given function f to mock the sIndexInfo.Open method
func (mmOpen *mSIndexInfoMockOpen) Set(f func() (i1 indexes.Index, err error)) *SIndexInfoMock {
	if mmOpen.defaultExpectation != nil {
		mmOpen.mock.t.Fatalf("Default expectation is already set for the sIndexInfo.Open method")
	}

	if len(mmOpen.expectations) > 0 {
		mmOpen.mock.t.Fatalf("Some expectations are already set for the sIndexInfo.Open method")
	}

	mmOpen.mock.funcOpen = f
	return mmOpen.mock
}

// Open implements sIndexInfo
func (mmOpen *SIndexInfoMock) Open() (i1 indexes.Index, err error) {
	mm_atomic.AddUint64(&mmOpen.beforeOpenCounter, 1)
	defer mm_atomic.AddUint64(&mmOpen.afterOpenCounter, 1)

	if mmOpen.inspectFuncOpen != nil {
		mmOpen.inspectFuncOpen()
	}

	if mmOpen.OpenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOpen.OpenMock.defaultExpectation.Counter, 1)

		mm_results := mmOpen.OpenMock.defaultExpectation.results
		if mm_results == nil {
			mmOpen.t.Fatal("No results are set for the SIndexInfoMock.Open")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmOpen.funcOpen != nil {
		return mmOpen.funcOpen()
	}
	mmOpen.t.Fatalf("Unexpected call to SIndexInfoMock.Open.")
	return
}

// OpenAfterCounter returns a count of finished SIndexInfoMock.Open invocations
func (mmOpen *SIndexInfoMock) OpenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.afterOpenCounter)
}

// OpenBeforeCounter returns a count of SIndexInfoMock.Open invocations
func (mmOpen *SIndexInfoMock) OpenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.beforeOpenCounter)
}

// MinimockOpenDone returns true if the count of the Open invocations corresponds
// the number of defined expectations
func (m *SIndexInfoMock) MinimockOpenDone() bool {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	return true
}

// MinimockOpenInspect logs each unmet expectation
func (m *SIndexInfoMock) MinimockOpenInspect() {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SIndexInfoMock.Open")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		m.t.Error("Expected call to SIndexInfoMock.Open")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		m.t.Error("Expected call to SIndexInfoMock.Open")
	}
}

type mSIndexInfoMockRecords struct {
	mock               *SIndexInfoMock
	defaultExpectation *SIndexInfoMockRecordsExpectation
	expectations       []*SIndexInfoMockRecordsExpectation
}

// SIndexInfoMockRecordsExpectation specifies expectation struct of the sIndexInfo.Records
type SIndexInfoMockRecordsExpectation struct {
	mock *SIndexInfoMock

	results *SIndexInfoMockRecordsResults
	Counter uint64
}

// SIndexInfoMockRecordsResults contains results of the sIndexInfo.Records
type SIndexInfoMockRecordsResults struct {
	i1 int64
}

// Expect sets up expected params for sIndexInfo.Records
func (mmRecords *mSIndexInfoMockRecords) Expect() *mSIndexInfoMockRecords {
	if mmRecords.mock.funcRecords != nil {
		mmRecords.mock.t.Fatalf("SIndexInfoMock.Records mock is already set by Set")
	}

	if mmRecords.defaultExpectation == nil {
		mmRecords.defaultExpectation = &SIndexInfoMockRecordsExpectation{}
	}

	return mmRecords
}

// Inspect accepts an inspector function that has same arguments as the sIndexInfo.Records
func (mmRecords *mSIndexInfoMockRecords) Inspect(f func()) *mSIndexInfoMockRecords {
	if mmRecords.mock.inspectFuncRecords != nil {
		mmRecords.mock.t.Fatalf("Inspect function is already set for SIndexInfoMock.Records")
	}

	mmRecords.mock.inspectFuncRecords = f

	return mmRecords
}

// Return sets up results that will be returned by sIndexInfo.Records
func (mmRecords *mSIndexInfoMockRecords) Return(i1 int64) *SIndexInfoMock {
	if mmRecords.mock.funcRecords != nil {
		mmRecords.mock.t.Fatalf("SIndexInfoMock.Records mock is already set by Set")
	}

	if mmRecords.defaultExpectation == nil {
		mmRecords.defaultExpectation = &SIndexInfoMockRecordsExpectation{mock: mmRecords.mock}
	}
	mmRecords.defaultExpectation.results = &SIndexInfoMockRecordsResults{i1}
	return mmRecords.mock
}

//Set uses given function f to mock the sIndexInfo.Records method
func (mmRecords *mSIndexInfoMockRecords) Set(f func() (i1 int64)) *SIndexInfoMock {
	if mmRecords.defaultExpectation != nil {
		mmRecords.mock.t.Fatalf("Default expectation is already set for the sIndexInfo.Records method")
	}

	if len(mmRecords.expectations) > 0 {
		mmRecords.mock.t.Fatalf("Some expectations are already set for the sIndexInfo.Records method")
	}

	mmRecords.mock.funcRecords = f
	return mmRecords.mock
}

// Records implements sIndexInfo
func (mmRecords *SIndexInfoMock) Records() (i1 int64) {
	mm_atomic.AddUint64(&mmRecords.beforeRecordsCounter, 1)
	defer mm_atomic.AddUint64(&mmRecords.afterRecordsCounter, 1)

	if mmRecords.inspectFuncRecords != nil {
		mmRecords.inspectFuncRecords()
	}

	if mmRecords.RecordsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecords.RecordsMock.defaultExpectation.Counter, 1)

		mm_results := mmRecords.RecordsMock.defaultExpectation.results
		if mm_results == nil {
			mmRecords.t.Fatal("No results are set for the SIndexInfoMock.Records")
		}
		return (*mm_results).i1
	}
	if mmRecords.funcRecords != nil {
		return mmRecords.funcRecords()
	}
	mmRecords.t.Fatalf("Unexpected call to SIndexInfoMock.Records.")
	return
}

// RecordsAfterCounter returns a count of finished SIndexInfoMock.Records invocations
func (mmRecords *SIndexInfoMock) RecordsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecords.afterRecordsCounter)
}

// RecordsBeforeCounter returns a count of SIndexInfoMock.Records invocations
func (mmRecords *SIndexInfoMock) RecordsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecords.beforeRecordsCounter)
}

// MinimockRecordsDone returns true if the count of the Records invocations corresponds
// the number of defined expectations
func (m *SIndexInfoMock) MinimockRecordsDone() bool {
	for _, e := range m.RecordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecordsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecordsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecords != nil && mm_atomic.LoadUint64(&m.afterRecordsCounter) < 1 {
		return false
	}
	return true
}

// MinimockRecordsInspect logs each unmet expectation
func (m *SIndexInfoMock) MinimockRecordsInspect() {
	for _, e := range m.RecordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SIndexInfoMock.Records")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecordsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecordsCounter) < 1 {
		m.t.Error("Expected call to SIndexInfoMock.Records")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecords != nil && mm_atomic.LoadUint64(&m.afterRecordsCounter) < 1 {
		m.t.Error("Expected call to SIndexInfoMock.Records")
	}
}

type mSIndexInfoMockString struct {
	mock               *SIndexInfoMock
	defaultExpectation *SIndexInfoMockStringExpectation
	expectations       []*SIndexInfoMockStringExpectation
}

// SIndexInfoMockStringExpectation specifies expectation struct of the sIndexInfo.String
type SIndexInfoMockStringExpectation struct {
	mock *SIndexInfoMock

	results *SIndexInfoMockStringResults
	Counter uint64
}

// SIndexInfoMockStringResults contains results of the sIndexInfo.String
type SIndexInfoMockStringResults struct {
	s1 string
}

// Expect sets up expected params for sIndexInfo.String
func (mmString *mSIndexInfoMockString) Expect() *mSIndexInfoMockString {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("SIndexInfoMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &SIndexInfoMockStringExpectation{}
	}

	return mmString
}

// Inspect accepts an inspector function that has same arguments as the sIndexInfo.String
func (mmString *mSIndexInfoMockString) Inspect(f func()) *mSIndexInfoMockString {
	if mmString.mock.inspectFuncString != nil {
		mmString.mock.t.Fatalf("Inspect function is already set for SIndexInfoMock.String")
	}

	mmString.mock.inspectFuncString = f

	return mmString
}

// Return sets up results that will be returned by sIndexInfo.String
func (mmString *mSIndexInfoMockString) Return(s1 string) *SIndexInfoMock {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("SIndexInfoMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &SIndexInfoMockStringExpectation{mock: mmString.mock}
	}
	mmString.defaultExpectation.results = &SIndexInfoMockStringResults{s1}
	return mmString.mock
}

//Set uses given function f to mock the sIndexInfo.String method
func (mmString *mSIndexInfoMockString) Set(f func() (s1 string)) *SIndexInfoMock {
	if mmString.defaultExpectation != nil {
		mmString.mock.t.Fatalf("Default expectation is already set for the sIndexInfo.String method")
	}

	if len(mmString.expectations) > 0 {
		mmString.mock.t.Fatalf("Some expectations are already set for the sIndexInfo.String method")
	}

	mmString.mock.funcString = f
	return mmString.mock
}

// String implements sIndexInfo
func (mmString *SIndexInfoMock) String() (s1 string) {
	mm_atomic.AddUint64(&mmString.beforeStringCounter, 1)
	defer mm_atomic.AddUint64(&mmString.afterStringCounter, 1)

	if mmString.inspectFuncString != nil {
		mmString.inspectFuncString()
	}

	if mmString.StringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmString.StringMock.defaultExpectation.Counter, 1)

		mm_results := mmString.StringMock.defaultExpectation.results
		if mm_results == nil {
			mmString.t.Fatal("No results are set for the SIndexInfoMock.String")
		}
		return (*mm_results).s1
	}
	if mmString.funcString != nil {
		return mmString.funcString()
	}
	mmString.t.Fatalf("Unexpected call to SIndexInfoMock.String.")
	return
}

// StringAfterCounter returns a count of finished SIndexInfoMock.String invocations
func (mmString *SIndexInfoMock) StringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.afterStringCounter)
}

// StringBeforeCounter returns a count of SIndexInfoMock.String invocations
func (mmString *SIndexInfoMock) StringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.beforeStringCounter)
}

// MinimockStringDone returns true if the count of the String invocations corresponds
// the number of defined expectations
func (m *SIndexInfoMock) MinimockStringDone() bool {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockStringInspect logs each unmet expectation
func (m *SIndexInfoMock) MinimockStringInspect() {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SIndexInfoMock.String")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		m.t.Error("Expected call to SIndexInfoMock.String")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		m.t.Error("Expected call to SIndexInfoMock.String")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SIndexInfoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBlocksAccessedInspect()

		m.MinimockDistinctValuesInspect()

		m.MinimockOpenInspect()

		m.MinimockRecordsInspect()

		m.MinimockStringInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SIndexInfoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SIndexInfoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBlocksAccessedDone() &&
		m.MinimockDistinctValuesDone() &&
		m.MinimockOpenDone() &&
		m.MinimockRecordsDone() &&
		m.MinimockStringDone()
}
