// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package indexplanner

//go:generate minimock -i github.com/unhandled-exception/sophiadb/internal/pkg/indexplanner.sIndexInfo -o mock_sindex_info_test.go -n SIndexInfoMock -p indexplanner

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/unhandled-exception/sophiadb/internal/pkg/indexes"
)

// SIndexInfoMock implements sIndexInfo
type SIndexInfoMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBlocksAccessed          func() (i1 int64)
	inspectFuncBlocksAccessed   func()
	afterBlocksAccessedCounter  uint64
	beforeBlocksAccessedCounter uint64
	BlocksAccessedMock          mSIndexInfoMockBlocksAccessed

	funcDistinctValues          func(fieldName string) (i1 int64)
	inspectFuncDistinctValues   func(fieldName string)
	afterDistinctValuesCounter  uint64
	beforeDistinctValuesCounter uint64
	DistinctValuesMock          mSIndexInfoMockDistinctValues

	funcOpen          func() (i1 indexes.Index, err error)
	inspectFuncOpen   func()
	afterOpenCounter  uint64
	beforeOpenCounter uint64
	OpenMock          mSIndexInfoMockOpen

	funcRecords          func() (i1 int64)
	inspectFuncRecords   func()
	afterRecordsCounter  uint64
	beforeRecordsCounter uint64
	RecordsMock          mSIndexInfoMockRecords

	funcString          func() (s1 string)
	inspectFuncString   func()
	afterStringCounter  uint64
	beforeStringCounter uint64
	StringMock          mSIndexInfoMockString
}

// NewSIndexInfoMock returns a mock for sIndexInfo
func NewSIndexInfoMock(t minimock.Tester) *SIndexInfoMock {
	m := &SIndexInfoMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BlocksAccessedMock = mSIndexInfoMockBlocksAccessed{mock: m}

	m.DistinctValuesMock = mSIndexInfoMockDistinctValues{mock: m}
	m.DistinctValuesMock.callArgs = []*SIndexInfoMockDistinctValuesParams{}

	m.OpenMock = mSIndexInfoMockOpen{mock: m}

	m.RecordsMock = mSIndexInfoMockRecords{mock: m}

	m.StringMock = mSIndexInfoMockString{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mSIndexInfoMockBlocksAccessed struct {
	optional           bool
	mock               *SIndexInfoMock
	defaultExpectation *SIndexInfoMockBlocksAccessedExpectation
	expectations       []*SIndexInfoMockBlocksAccessedExpectation

	expectedInvocations uint64
}

// SIndexInfoMockBlocksAccessedExpectation specifies expectation struct of the sIndexInfo.BlocksAccessed
type SIndexInfoMockBlocksAccessedExpectation struct {
	mock *SIndexInfoMock

	results *SIndexInfoMockBlocksAccessedResults
	Counter uint64
}

// SIndexInfoMockBlocksAccessedResults contains results of the sIndexInfo.BlocksAccessed
type SIndexInfoMockBlocksAccessedResults struct {
	i1 int64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBlocksAccessed *mSIndexInfoMockBlocksAccessed) Optional() *mSIndexInfoMockBlocksAccessed {
	mmBlocksAccessed.optional = true
	return mmBlocksAccessed
}

// Expect sets up expected params for sIndexInfo.BlocksAccessed
func (mmBlocksAccessed *mSIndexInfoMockBlocksAccessed) Expect() *mSIndexInfoMockBlocksAccessed {
	if mmBlocksAccessed.mock.funcBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("SIndexInfoMock.BlocksAccessed mock is already set by Set")
	}

	if mmBlocksAccessed.defaultExpectation == nil {
		mmBlocksAccessed.defaultExpectation = &SIndexInfoMockBlocksAccessedExpectation{}
	}

	return mmBlocksAccessed
}

// Inspect accepts an inspector function that has same arguments as the sIndexInfo.BlocksAccessed
func (mmBlocksAccessed *mSIndexInfoMockBlocksAccessed) Inspect(f func()) *mSIndexInfoMockBlocksAccessed {
	if mmBlocksAccessed.mock.inspectFuncBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("Inspect function is already set for SIndexInfoMock.BlocksAccessed")
	}

	mmBlocksAccessed.mock.inspectFuncBlocksAccessed = f

	return mmBlocksAccessed
}

// Return sets up results that will be returned by sIndexInfo.BlocksAccessed
func (mmBlocksAccessed *mSIndexInfoMockBlocksAccessed) Return(i1 int64) *SIndexInfoMock {
	if mmBlocksAccessed.mock.funcBlocksAccessed != nil {
		mmBlocksAccessed.mock.t.Fatalf("SIndexInfoMock.BlocksAccessed mock is already set by Set")
	}

	if mmBlocksAccessed.defaultExpectation == nil {
		mmBlocksAccessed.defaultExpectation = &SIndexInfoMockBlocksAccessedExpectation{mock: mmBlocksAccessed.mock}
	}
	mmBlocksAccessed.defaultExpectation.results = &SIndexInfoMockBlocksAccessedResults{i1}
	return mmBlocksAccessed.mock
}

// Set uses given function f to mock the sIndexInfo.BlocksAccessed method
func (mmBlocksAccessed *mSIndexInfoMockBlocksAccessed) Set(f func() (i1 int64)) *SIndexInfoMock {
	if mmBlocksAccessed.defaultExpectation != nil {
		mmBlocksAccessed.mock.t.Fatalf("Default expectation is already set for the sIndexInfo.BlocksAccessed method")
	}

	if len(mmBlocksAccessed.expectations) > 0 {
		mmBlocksAccessed.mock.t.Fatalf("Some expectations are already set for the sIndexInfo.BlocksAccessed method")
	}

	mmBlocksAccessed.mock.funcBlocksAccessed = f
	return mmBlocksAccessed.mock
}

// Times sets number of times sIndexInfo.BlocksAccessed should be invoked
func (mmBlocksAccessed *mSIndexInfoMockBlocksAccessed) Times(n uint64) *mSIndexInfoMockBlocksAccessed {
	if n == 0 {
		mmBlocksAccessed.mock.t.Fatalf("Times of SIndexInfoMock.BlocksAccessed mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBlocksAccessed.expectedInvocations, n)
	return mmBlocksAccessed
}

func (mmBlocksAccessed *mSIndexInfoMockBlocksAccessed) invocationsDone() bool {
	if len(mmBlocksAccessed.expectations) == 0 && mmBlocksAccessed.defaultExpectation == nil && mmBlocksAccessed.mock.funcBlocksAccessed == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBlocksAccessed.mock.afterBlocksAccessedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBlocksAccessed.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// BlocksAccessed implements sIndexInfo
func (mmBlocksAccessed *SIndexInfoMock) BlocksAccessed() (i1 int64) {
	mm_atomic.AddUint64(&mmBlocksAccessed.beforeBlocksAccessedCounter, 1)
	defer mm_atomic.AddUint64(&mmBlocksAccessed.afterBlocksAccessedCounter, 1)

	if mmBlocksAccessed.inspectFuncBlocksAccessed != nil {
		mmBlocksAccessed.inspectFuncBlocksAccessed()
	}

	if mmBlocksAccessed.BlocksAccessedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBlocksAccessed.BlocksAccessedMock.defaultExpectation.Counter, 1)

		mm_results := mmBlocksAccessed.BlocksAccessedMock.defaultExpectation.results
		if mm_results == nil {
			mmBlocksAccessed.t.Fatal("No results are set for the SIndexInfoMock.BlocksAccessed")
		}
		return (*mm_results).i1
	}
	if mmBlocksAccessed.funcBlocksAccessed != nil {
		return mmBlocksAccessed.funcBlocksAccessed()
	}
	mmBlocksAccessed.t.Fatalf("Unexpected call to SIndexInfoMock.BlocksAccessed.")
	return
}

// BlocksAccessedAfterCounter returns a count of finished SIndexInfoMock.BlocksAccessed invocations
func (mmBlocksAccessed *SIndexInfoMock) BlocksAccessedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBlocksAccessed.afterBlocksAccessedCounter)
}

// BlocksAccessedBeforeCounter returns a count of SIndexInfoMock.BlocksAccessed invocations
func (mmBlocksAccessed *SIndexInfoMock) BlocksAccessedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBlocksAccessed.beforeBlocksAccessedCounter)
}

// MinimockBlocksAccessedDone returns true if the count of the BlocksAccessed invocations corresponds
// the number of defined expectations
func (m *SIndexInfoMock) MinimockBlocksAccessedDone() bool {
	if m.BlocksAccessedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BlocksAccessedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BlocksAccessedMock.invocationsDone()
}

// MinimockBlocksAccessedInspect logs each unmet expectation
func (m *SIndexInfoMock) MinimockBlocksAccessedInspect() {
	for _, e := range m.BlocksAccessedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SIndexInfoMock.BlocksAccessed")
		}
	}

	afterBlocksAccessedCounter := mm_atomic.LoadUint64(&m.afterBlocksAccessedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BlocksAccessedMock.defaultExpectation != nil && afterBlocksAccessedCounter < 1 {
		m.t.Error("Expected call to SIndexInfoMock.BlocksAccessed")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBlocksAccessed != nil && afterBlocksAccessedCounter < 1 {
		m.t.Error("Expected call to SIndexInfoMock.BlocksAccessed")
	}

	if !m.BlocksAccessedMock.invocationsDone() && afterBlocksAccessedCounter > 0 {
		m.t.Errorf("Expected %d calls to SIndexInfoMock.BlocksAccessed but found %d calls",
			mm_atomic.LoadUint64(&m.BlocksAccessedMock.expectedInvocations), afterBlocksAccessedCounter)
	}
}

type mSIndexInfoMockDistinctValues struct {
	optional           bool
	mock               *SIndexInfoMock
	defaultExpectation *SIndexInfoMockDistinctValuesExpectation
	expectations       []*SIndexInfoMockDistinctValuesExpectation

	callArgs []*SIndexInfoMockDistinctValuesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// SIndexInfoMockDistinctValuesExpectation specifies expectation struct of the sIndexInfo.DistinctValues
type SIndexInfoMockDistinctValuesExpectation struct {
	mock      *SIndexInfoMock
	params    *SIndexInfoMockDistinctValuesParams
	paramPtrs *SIndexInfoMockDistinctValuesParamPtrs
	results   *SIndexInfoMockDistinctValuesResults
	Counter   uint64
}

// SIndexInfoMockDistinctValuesParams contains parameters of the sIndexInfo.DistinctValues
type SIndexInfoMockDistinctValuesParams struct {
	fieldName string
}

// SIndexInfoMockDistinctValuesParamPtrs contains pointers to parameters of the sIndexInfo.DistinctValues
type SIndexInfoMockDistinctValuesParamPtrs struct {
	fieldName *string
}

// SIndexInfoMockDistinctValuesResults contains results of the sIndexInfo.DistinctValues
type SIndexInfoMockDistinctValuesResults struct {
	i1 int64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDistinctValues *mSIndexInfoMockDistinctValues) Optional() *mSIndexInfoMockDistinctValues {
	mmDistinctValues.optional = true
	return mmDistinctValues
}

// Expect sets up expected params for sIndexInfo.DistinctValues
func (mmDistinctValues *mSIndexInfoMockDistinctValues) Expect(fieldName string) *mSIndexInfoMockDistinctValues {
	if mmDistinctValues.mock.funcDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("SIndexInfoMock.DistinctValues mock is already set by Set")
	}

	if mmDistinctValues.defaultExpectation == nil {
		mmDistinctValues.defaultExpectation = &SIndexInfoMockDistinctValuesExpectation{}
	}

	if mmDistinctValues.defaultExpectation.paramPtrs != nil {
		mmDistinctValues.mock.t.Fatalf("SIndexInfoMock.DistinctValues mock is already set by ExpectParams functions")
	}

	mmDistinctValues.defaultExpectation.params = &SIndexInfoMockDistinctValuesParams{fieldName}
	for _, e := range mmDistinctValues.expectations {
		if minimock.Equal(e.params, mmDistinctValues.defaultExpectation.params) {
			mmDistinctValues.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDistinctValues.defaultExpectation.params)
		}
	}

	return mmDistinctValues
}

// ExpectFieldNameParam1 sets up expected param fieldName for sIndexInfo.DistinctValues
func (mmDistinctValues *mSIndexInfoMockDistinctValues) ExpectFieldNameParam1(fieldName string) *mSIndexInfoMockDistinctValues {
	if mmDistinctValues.mock.funcDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("SIndexInfoMock.DistinctValues mock is already set by Set")
	}

	if mmDistinctValues.defaultExpectation == nil {
		mmDistinctValues.defaultExpectation = &SIndexInfoMockDistinctValuesExpectation{}
	}

	if mmDistinctValues.defaultExpectation.params != nil {
		mmDistinctValues.mock.t.Fatalf("SIndexInfoMock.DistinctValues mock is already set by Expect")
	}

	if mmDistinctValues.defaultExpectation.paramPtrs == nil {
		mmDistinctValues.defaultExpectation.paramPtrs = &SIndexInfoMockDistinctValuesParamPtrs{}
	}
	mmDistinctValues.defaultExpectation.paramPtrs.fieldName = &fieldName

	return mmDistinctValues
}

// Inspect accepts an inspector function that has same arguments as the sIndexInfo.DistinctValues
func (mmDistinctValues *mSIndexInfoMockDistinctValues) Inspect(f func(fieldName string)) *mSIndexInfoMockDistinctValues {
	if mmDistinctValues.mock.inspectFuncDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("Inspect function is already set for SIndexInfoMock.DistinctValues")
	}

	mmDistinctValues.mock.inspectFuncDistinctValues = f

	return mmDistinctValues
}

// Return sets up results that will be returned by sIndexInfo.DistinctValues
func (mmDistinctValues *mSIndexInfoMockDistinctValues) Return(i1 int64) *SIndexInfoMock {
	if mmDistinctValues.mock.funcDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("SIndexInfoMock.DistinctValues mock is already set by Set")
	}

	if mmDistinctValues.defaultExpectation == nil {
		mmDistinctValues.defaultExpectation = &SIndexInfoMockDistinctValuesExpectation{mock: mmDistinctValues.mock}
	}
	mmDistinctValues.defaultExpectation.results = &SIndexInfoMockDistinctValuesResults{i1}
	return mmDistinctValues.mock
}

// Set uses given function f to mock the sIndexInfo.DistinctValues method
func (mmDistinctValues *mSIndexInfoMockDistinctValues) Set(f func(fieldName string) (i1 int64)) *SIndexInfoMock {
	if mmDistinctValues.defaultExpectation != nil {
		mmDistinctValues.mock.t.Fatalf("Default expectation is already set for the sIndexInfo.DistinctValues method")
	}

	if len(mmDistinctValues.expectations) > 0 {
		mmDistinctValues.mock.t.Fatalf("Some expectations are already set for the sIndexInfo.DistinctValues method")
	}

	mmDistinctValues.mock.funcDistinctValues = f
	return mmDistinctValues.mock
}

// When sets expectation for the sIndexInfo.DistinctValues which will trigger the result defined by the following
// Then helper
func (mmDistinctValues *mSIndexInfoMockDistinctValues) When(fieldName string) *SIndexInfoMockDistinctValuesExpectation {
	if mmDistinctValues.mock.funcDistinctValues != nil {
		mmDistinctValues.mock.t.Fatalf("SIndexInfoMock.DistinctValues mock is already set by Set")
	}

	expectation := &SIndexInfoMockDistinctValuesExpectation{
		mock:   mmDistinctValues.mock,
		params: &SIndexInfoMockDistinctValuesParams{fieldName},
	}
	mmDistinctValues.expectations = append(mmDistinctValues.expectations, expectation)
	return expectation
}

// Then sets up sIndexInfo.DistinctValues return parameters for the expectation previously defined by the When method
func (e *SIndexInfoMockDistinctValuesExpectation) Then(i1 int64) *SIndexInfoMock {
	e.results = &SIndexInfoMockDistinctValuesResults{i1}
	return e.mock
}

// Times sets number of times sIndexInfo.DistinctValues should be invoked
func (mmDistinctValues *mSIndexInfoMockDistinctValues) Times(n uint64) *mSIndexInfoMockDistinctValues {
	if n == 0 {
		mmDistinctValues.mock.t.Fatalf("Times of SIndexInfoMock.DistinctValues mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDistinctValues.expectedInvocations, n)
	return mmDistinctValues
}

func (mmDistinctValues *mSIndexInfoMockDistinctValues) invocationsDone() bool {
	if len(mmDistinctValues.expectations) == 0 && mmDistinctValues.defaultExpectation == nil && mmDistinctValues.mock.funcDistinctValues == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDistinctValues.mock.afterDistinctValuesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDistinctValues.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DistinctValues implements sIndexInfo
func (mmDistinctValues *SIndexInfoMock) DistinctValues(fieldName string) (i1 int64) {
	mm_atomic.AddUint64(&mmDistinctValues.beforeDistinctValuesCounter, 1)
	defer mm_atomic.AddUint64(&mmDistinctValues.afterDistinctValuesCounter, 1)

	if mmDistinctValues.inspectFuncDistinctValues != nil {
		mmDistinctValues.inspectFuncDistinctValues(fieldName)
	}

	mm_params := SIndexInfoMockDistinctValuesParams{fieldName}

	// Record call args
	mmDistinctValues.DistinctValuesMock.mutex.Lock()
	mmDistinctValues.DistinctValuesMock.callArgs = append(mmDistinctValues.DistinctValuesMock.callArgs, &mm_params)
	mmDistinctValues.DistinctValuesMock.mutex.Unlock()

	for _, e := range mmDistinctValues.DistinctValuesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1
		}
	}

	if mmDistinctValues.DistinctValuesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDistinctValues.DistinctValuesMock.defaultExpectation.Counter, 1)
		mm_want := mmDistinctValues.DistinctValuesMock.defaultExpectation.params
		mm_want_ptrs := mmDistinctValues.DistinctValuesMock.defaultExpectation.paramPtrs

		mm_got := SIndexInfoMockDistinctValuesParams{fieldName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.fieldName != nil && !minimock.Equal(*mm_want_ptrs.fieldName, mm_got.fieldName) {
				mmDistinctValues.t.Errorf("SIndexInfoMock.DistinctValues got unexpected parameter fieldName, want: %#v, got: %#v%s\n", *mm_want_ptrs.fieldName, mm_got.fieldName, minimock.Diff(*mm_want_ptrs.fieldName, mm_got.fieldName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDistinctValues.t.Errorf("SIndexInfoMock.DistinctValues got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDistinctValues.DistinctValuesMock.defaultExpectation.results
		if mm_results == nil {
			mmDistinctValues.t.Fatal("No results are set for the SIndexInfoMock.DistinctValues")
		}
		return (*mm_results).i1
	}
	if mmDistinctValues.funcDistinctValues != nil {
		return mmDistinctValues.funcDistinctValues(fieldName)
	}
	mmDistinctValues.t.Fatalf("Unexpected call to SIndexInfoMock.DistinctValues. %v", fieldName)
	return
}

// DistinctValuesAfterCounter returns a count of finished SIndexInfoMock.DistinctValues invocations
func (mmDistinctValues *SIndexInfoMock) DistinctValuesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDistinctValues.afterDistinctValuesCounter)
}

// DistinctValuesBeforeCounter returns a count of SIndexInfoMock.DistinctValues invocations
func (mmDistinctValues *SIndexInfoMock) DistinctValuesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDistinctValues.beforeDistinctValuesCounter)
}

// Calls returns a list of arguments used in each call to SIndexInfoMock.DistinctValues.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDistinctValues *mSIndexInfoMockDistinctValues) Calls() []*SIndexInfoMockDistinctValuesParams {
	mmDistinctValues.mutex.RLock()

	argCopy := make([]*SIndexInfoMockDistinctValuesParams, len(mmDistinctValues.callArgs))
	copy(argCopy, mmDistinctValues.callArgs)

	mmDistinctValues.mutex.RUnlock()

	return argCopy
}

// MinimockDistinctValuesDone returns true if the count of the DistinctValues invocations corresponds
// the number of defined expectations
func (m *SIndexInfoMock) MinimockDistinctValuesDone() bool {
	if m.DistinctValuesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DistinctValuesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DistinctValuesMock.invocationsDone()
}

// MinimockDistinctValuesInspect logs each unmet expectation
func (m *SIndexInfoMock) MinimockDistinctValuesInspect() {
	for _, e := range m.DistinctValuesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SIndexInfoMock.DistinctValues with params: %#v", *e.params)
		}
	}

	afterDistinctValuesCounter := mm_atomic.LoadUint64(&m.afterDistinctValuesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DistinctValuesMock.defaultExpectation != nil && afterDistinctValuesCounter < 1 {
		if m.DistinctValuesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SIndexInfoMock.DistinctValues")
		} else {
			m.t.Errorf("Expected call to SIndexInfoMock.DistinctValues with params: %#v", *m.DistinctValuesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDistinctValues != nil && afterDistinctValuesCounter < 1 {
		m.t.Error("Expected call to SIndexInfoMock.DistinctValues")
	}

	if !m.DistinctValuesMock.invocationsDone() && afterDistinctValuesCounter > 0 {
		m.t.Errorf("Expected %d calls to SIndexInfoMock.DistinctValues but found %d calls",
			mm_atomic.LoadUint64(&m.DistinctValuesMock.expectedInvocations), afterDistinctValuesCounter)
	}
}

type mSIndexInfoMockOpen struct {
	optional           bool
	mock               *SIndexInfoMock
	defaultExpectation *SIndexInfoMockOpenExpectation
	expectations       []*SIndexInfoMockOpenExpectation

	expectedInvocations uint64
}

// SIndexInfoMockOpenExpectation specifies expectation struct of the sIndexInfo.Open
type SIndexInfoMockOpenExpectation struct {
	mock *SIndexInfoMock

	results *SIndexInfoMockOpenResults
	Counter uint64
}

// SIndexInfoMockOpenResults contains results of the sIndexInfo.Open
type SIndexInfoMockOpenResults struct {
	i1  indexes.Index
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOpen *mSIndexInfoMockOpen) Optional() *mSIndexInfoMockOpen {
	mmOpen.optional = true
	return mmOpen
}

// Expect sets up expected params for sIndexInfo.Open
func (mmOpen *mSIndexInfoMockOpen) Expect() *mSIndexInfoMockOpen {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("SIndexInfoMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &SIndexInfoMockOpenExpectation{}
	}

	return mmOpen
}

// Inspect accepts an inspector function that has same arguments as the sIndexInfo.Open
func (mmOpen *mSIndexInfoMockOpen) Inspect(f func()) *mSIndexInfoMockOpen {
	if mmOpen.mock.inspectFuncOpen != nil {
		mmOpen.mock.t.Fatalf("Inspect function is already set for SIndexInfoMock.Open")
	}

	mmOpen.mock.inspectFuncOpen = f

	return mmOpen
}

// Return sets up results that will be returned by sIndexInfo.Open
func (mmOpen *mSIndexInfoMockOpen) Return(i1 indexes.Index, err error) *SIndexInfoMock {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("SIndexInfoMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &SIndexInfoMockOpenExpectation{mock: mmOpen.mock}
	}
	mmOpen.defaultExpectation.results = &SIndexInfoMockOpenResults{i1, err}
	return mmOpen.mock
}

// Set uses given function f to mock the sIndexInfo.Open method
func (mmOpen *mSIndexInfoMockOpen) Set(f func() (i1 indexes.Index, err error)) *SIndexInfoMock {
	if mmOpen.defaultExpectation != nil {
		mmOpen.mock.t.Fatalf("Default expectation is already set for the sIndexInfo.Open method")
	}

	if len(mmOpen.expectations) > 0 {
		mmOpen.mock.t.Fatalf("Some expectations are already set for the sIndexInfo.Open method")
	}

	mmOpen.mock.funcOpen = f
	return mmOpen.mock
}

// Times sets number of times sIndexInfo.Open should be invoked
func (mmOpen *mSIndexInfoMockOpen) Times(n uint64) *mSIndexInfoMockOpen {
	if n == 0 {
		mmOpen.mock.t.Fatalf("Times of SIndexInfoMock.Open mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOpen.expectedInvocations, n)
	return mmOpen
}

func (mmOpen *mSIndexInfoMockOpen) invocationsDone() bool {
	if len(mmOpen.expectations) == 0 && mmOpen.defaultExpectation == nil && mmOpen.mock.funcOpen == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOpen.mock.afterOpenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOpen.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Open implements sIndexInfo
func (mmOpen *SIndexInfoMock) Open() (i1 indexes.Index, err error) {
	mm_atomic.AddUint64(&mmOpen.beforeOpenCounter, 1)
	defer mm_atomic.AddUint64(&mmOpen.afterOpenCounter, 1)

	if mmOpen.inspectFuncOpen != nil {
		mmOpen.inspectFuncOpen()
	}

	if mmOpen.OpenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOpen.OpenMock.defaultExpectation.Counter, 1)

		mm_results := mmOpen.OpenMock.defaultExpectation.results
		if mm_results == nil {
			mmOpen.t.Fatal("No results are set for the SIndexInfoMock.Open")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmOpen.funcOpen != nil {
		return mmOpen.funcOpen()
	}
	mmOpen.t.Fatalf("Unexpected call to SIndexInfoMock.Open.")
	return
}

// OpenAfterCounter returns a count of finished SIndexInfoMock.Open invocations
func (mmOpen *SIndexInfoMock) OpenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.afterOpenCounter)
}

// OpenBeforeCounter returns a count of SIndexInfoMock.Open invocations
func (mmOpen *SIndexInfoMock) OpenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.beforeOpenCounter)
}

// MinimockOpenDone returns true if the count of the Open invocations corresponds
// the number of defined expectations
func (m *SIndexInfoMock) MinimockOpenDone() bool {
	if m.OpenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OpenMock.invocationsDone()
}

// MinimockOpenInspect logs each unmet expectation
func (m *SIndexInfoMock) MinimockOpenInspect() {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SIndexInfoMock.Open")
		}
	}

	afterOpenCounter := mm_atomic.LoadUint64(&m.afterOpenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && afterOpenCounter < 1 {
		m.t.Error("Expected call to SIndexInfoMock.Open")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && afterOpenCounter < 1 {
		m.t.Error("Expected call to SIndexInfoMock.Open")
	}

	if !m.OpenMock.invocationsDone() && afterOpenCounter > 0 {
		m.t.Errorf("Expected %d calls to SIndexInfoMock.Open but found %d calls",
			mm_atomic.LoadUint64(&m.OpenMock.expectedInvocations), afterOpenCounter)
	}
}

type mSIndexInfoMockRecords struct {
	optional           bool
	mock               *SIndexInfoMock
	defaultExpectation *SIndexInfoMockRecordsExpectation
	expectations       []*SIndexInfoMockRecordsExpectation

	expectedInvocations uint64
}

// SIndexInfoMockRecordsExpectation specifies expectation struct of the sIndexInfo.Records
type SIndexInfoMockRecordsExpectation struct {
	mock *SIndexInfoMock

	results *SIndexInfoMockRecordsResults
	Counter uint64
}

// SIndexInfoMockRecordsResults contains results of the sIndexInfo.Records
type SIndexInfoMockRecordsResults struct {
	i1 int64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRecords *mSIndexInfoMockRecords) Optional() *mSIndexInfoMockRecords {
	mmRecords.optional = true
	return mmRecords
}

// Expect sets up expected params for sIndexInfo.Records
func (mmRecords *mSIndexInfoMockRecords) Expect() *mSIndexInfoMockRecords {
	if mmRecords.mock.funcRecords != nil {
		mmRecords.mock.t.Fatalf("SIndexInfoMock.Records mock is already set by Set")
	}

	if mmRecords.defaultExpectation == nil {
		mmRecords.defaultExpectation = &SIndexInfoMockRecordsExpectation{}
	}

	return mmRecords
}

// Inspect accepts an inspector function that has same arguments as the sIndexInfo.Records
func (mmRecords *mSIndexInfoMockRecords) Inspect(f func()) *mSIndexInfoMockRecords {
	if mmRecords.mock.inspectFuncRecords != nil {
		mmRecords.mock.t.Fatalf("Inspect function is already set for SIndexInfoMock.Records")
	}

	mmRecords.mock.inspectFuncRecords = f

	return mmRecords
}

// Return sets up results that will be returned by sIndexInfo.Records
func (mmRecords *mSIndexInfoMockRecords) Return(i1 int64) *SIndexInfoMock {
	if mmRecords.mock.funcRecords != nil {
		mmRecords.mock.t.Fatalf("SIndexInfoMock.Records mock is already set by Set")
	}

	if mmRecords.defaultExpectation == nil {
		mmRecords.defaultExpectation = &SIndexInfoMockRecordsExpectation{mock: mmRecords.mock}
	}
	mmRecords.defaultExpectation.results = &SIndexInfoMockRecordsResults{i1}
	return mmRecords.mock
}

// Set uses given function f to mock the sIndexInfo.Records method
func (mmRecords *mSIndexInfoMockRecords) Set(f func() (i1 int64)) *SIndexInfoMock {
	if mmRecords.defaultExpectation != nil {
		mmRecords.mock.t.Fatalf("Default expectation is already set for the sIndexInfo.Records method")
	}

	if len(mmRecords.expectations) > 0 {
		mmRecords.mock.t.Fatalf("Some expectations are already set for the sIndexInfo.Records method")
	}

	mmRecords.mock.funcRecords = f
	return mmRecords.mock
}

// Times sets number of times sIndexInfo.Records should be invoked
func (mmRecords *mSIndexInfoMockRecords) Times(n uint64) *mSIndexInfoMockRecords {
	if n == 0 {
		mmRecords.mock.t.Fatalf("Times of SIndexInfoMock.Records mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRecords.expectedInvocations, n)
	return mmRecords
}

func (mmRecords *mSIndexInfoMockRecords) invocationsDone() bool {
	if len(mmRecords.expectations) == 0 && mmRecords.defaultExpectation == nil && mmRecords.mock.funcRecords == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRecords.mock.afterRecordsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRecords.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Records implements sIndexInfo
func (mmRecords *SIndexInfoMock) Records() (i1 int64) {
	mm_atomic.AddUint64(&mmRecords.beforeRecordsCounter, 1)
	defer mm_atomic.AddUint64(&mmRecords.afterRecordsCounter, 1)

	if mmRecords.inspectFuncRecords != nil {
		mmRecords.inspectFuncRecords()
	}

	if mmRecords.RecordsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecords.RecordsMock.defaultExpectation.Counter, 1)

		mm_results := mmRecords.RecordsMock.defaultExpectation.results
		if mm_results == nil {
			mmRecords.t.Fatal("No results are set for the SIndexInfoMock.Records")
		}
		return (*mm_results).i1
	}
	if mmRecords.funcRecords != nil {
		return mmRecords.funcRecords()
	}
	mmRecords.t.Fatalf("Unexpected call to SIndexInfoMock.Records.")
	return
}

// RecordsAfterCounter returns a count of finished SIndexInfoMock.Records invocations
func (mmRecords *SIndexInfoMock) RecordsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecords.afterRecordsCounter)
}

// RecordsBeforeCounter returns a count of SIndexInfoMock.Records invocations
func (mmRecords *SIndexInfoMock) RecordsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecords.beforeRecordsCounter)
}

// MinimockRecordsDone returns true if the count of the Records invocations corresponds
// the number of defined expectations
func (m *SIndexInfoMock) MinimockRecordsDone() bool {
	if m.RecordsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RecordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RecordsMock.invocationsDone()
}

// MinimockRecordsInspect logs each unmet expectation
func (m *SIndexInfoMock) MinimockRecordsInspect() {
	for _, e := range m.RecordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SIndexInfoMock.Records")
		}
	}

	afterRecordsCounter := mm_atomic.LoadUint64(&m.afterRecordsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RecordsMock.defaultExpectation != nil && afterRecordsCounter < 1 {
		m.t.Error("Expected call to SIndexInfoMock.Records")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecords != nil && afterRecordsCounter < 1 {
		m.t.Error("Expected call to SIndexInfoMock.Records")
	}

	if !m.RecordsMock.invocationsDone() && afterRecordsCounter > 0 {
		m.t.Errorf("Expected %d calls to SIndexInfoMock.Records but found %d calls",
			mm_atomic.LoadUint64(&m.RecordsMock.expectedInvocations), afterRecordsCounter)
	}
}

type mSIndexInfoMockString struct {
	optional           bool
	mock               *SIndexInfoMock
	defaultExpectation *SIndexInfoMockStringExpectation
	expectations       []*SIndexInfoMockStringExpectation

	expectedInvocations uint64
}

// SIndexInfoMockStringExpectation specifies expectation struct of the sIndexInfo.String
type SIndexInfoMockStringExpectation struct {
	mock *SIndexInfoMock

	results *SIndexInfoMockStringResults
	Counter uint64
}

// SIndexInfoMockStringResults contains results of the sIndexInfo.String
type SIndexInfoMockStringResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmString *mSIndexInfoMockString) Optional() *mSIndexInfoMockString {
	mmString.optional = true
	return mmString
}

// Expect sets up expected params for sIndexInfo.String
func (mmString *mSIndexInfoMockString) Expect() *mSIndexInfoMockString {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("SIndexInfoMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &SIndexInfoMockStringExpectation{}
	}

	return mmString
}

// Inspect accepts an inspector function that has same arguments as the sIndexInfo.String
func (mmString *mSIndexInfoMockString) Inspect(f func()) *mSIndexInfoMockString {
	if mmString.mock.inspectFuncString != nil {
		mmString.mock.t.Fatalf("Inspect function is already set for SIndexInfoMock.String")
	}

	mmString.mock.inspectFuncString = f

	return mmString
}

// Return sets up results that will be returned by sIndexInfo.String
func (mmString *mSIndexInfoMockString) Return(s1 string) *SIndexInfoMock {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("SIndexInfoMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &SIndexInfoMockStringExpectation{mock: mmString.mock}
	}
	mmString.defaultExpectation.results = &SIndexInfoMockStringResults{s1}
	return mmString.mock
}

// Set uses given function f to mock the sIndexInfo.String method
func (mmString *mSIndexInfoMockString) Set(f func() (s1 string)) *SIndexInfoMock {
	if mmString.defaultExpectation != nil {
		mmString.mock.t.Fatalf("Default expectation is already set for the sIndexInfo.String method")
	}

	if len(mmString.expectations) > 0 {
		mmString.mock.t.Fatalf("Some expectations are already set for the sIndexInfo.String method")
	}

	mmString.mock.funcString = f
	return mmString.mock
}

// Times sets number of times sIndexInfo.String should be invoked
func (mmString *mSIndexInfoMockString) Times(n uint64) *mSIndexInfoMockString {
	if n == 0 {
		mmString.mock.t.Fatalf("Times of SIndexInfoMock.String mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmString.expectedInvocations, n)
	return mmString
}

func (mmString *mSIndexInfoMockString) invocationsDone() bool {
	if len(mmString.expectations) == 0 && mmString.defaultExpectation == nil && mmString.mock.funcString == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmString.mock.afterStringCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmString.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// String implements sIndexInfo
func (mmString *SIndexInfoMock) String() (s1 string) {
	mm_atomic.AddUint64(&mmString.beforeStringCounter, 1)
	defer mm_atomic.AddUint64(&mmString.afterStringCounter, 1)

	if mmString.inspectFuncString != nil {
		mmString.inspectFuncString()
	}

	if mmString.StringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmString.StringMock.defaultExpectation.Counter, 1)

		mm_results := mmString.StringMock.defaultExpectation.results
		if mm_results == nil {
			mmString.t.Fatal("No results are set for the SIndexInfoMock.String")
		}
		return (*mm_results).s1
	}
	if mmString.funcString != nil {
		return mmString.funcString()
	}
	mmString.t.Fatalf("Unexpected call to SIndexInfoMock.String.")
	return
}

// StringAfterCounter returns a count of finished SIndexInfoMock.String invocations
func (mmString *SIndexInfoMock) StringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.afterStringCounter)
}

// StringBeforeCounter returns a count of SIndexInfoMock.String invocations
func (mmString *SIndexInfoMock) StringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.beforeStringCounter)
}

// MinimockStringDone returns true if the count of the String invocations corresponds
// the number of defined expectations
func (m *SIndexInfoMock) MinimockStringDone() bool {
	if m.StringMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StringMock.invocationsDone()
}

// MinimockStringInspect logs each unmet expectation
func (m *SIndexInfoMock) MinimockStringInspect() {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SIndexInfoMock.String")
		}
	}

	afterStringCounter := mm_atomic.LoadUint64(&m.afterStringCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && afterStringCounter < 1 {
		m.t.Error("Expected call to SIndexInfoMock.String")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && afterStringCounter < 1 {
		m.t.Error("Expected call to SIndexInfoMock.String")
	}

	if !m.StringMock.invocationsDone() && afterStringCounter > 0 {
		m.t.Errorf("Expected %d calls to SIndexInfoMock.String but found %d calls",
			mm_atomic.LoadUint64(&m.StringMock.expectedInvocations), afterStringCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SIndexInfoMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBlocksAccessedInspect()

			m.MinimockDistinctValuesInspect()

			m.MinimockOpenInspect()

			m.MinimockRecordsInspect()

			m.MinimockStringInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SIndexInfoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SIndexInfoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBlocksAccessedDone() &&
		m.MinimockDistinctValuesDone() &&
		m.MinimockOpenDone() &&
		m.MinimockRecordsDone() &&
		m.MinimockStringDone()
}
