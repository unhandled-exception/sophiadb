// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package planner

//go:generate minimock -i github.com/unhandled-exception/sophiadb/internal/pkg/planner.tablePlanMetadataManager -o table_plan_metadata_manager_mock_test.go -n TablePlanMetadataManagerMock -p planner

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/unhandled-exception/sophiadb/internal/pkg/metadata"
	"github.com/unhandled-exception/sophiadb/internal/pkg/records"
	"github.com/unhandled-exception/sophiadb/internal/pkg/scan"
)

// TablePlanMetadataManagerMock implements tablePlanMetadataManager
type TablePlanMetadataManagerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetStatInfo          func(tableName string, layout records.Layout, trx scan.TRXInt) (s1 metadata.StatInfo, err error)
	inspectFuncGetStatInfo   func(tableName string, layout records.Layout, trx scan.TRXInt)
	afterGetStatInfoCounter  uint64
	beforeGetStatInfoCounter uint64
	GetStatInfoMock          mTablePlanMetadataManagerMockGetStatInfo

	funcLayout          func(tableName string, trx scan.TRXInt) (l1 records.Layout, err error)
	inspectFuncLayout   func(tableName string, trx scan.TRXInt)
	afterLayoutCounter  uint64
	beforeLayoutCounter uint64
	LayoutMock          mTablePlanMetadataManagerMockLayout
}

// NewTablePlanMetadataManagerMock returns a mock for tablePlanMetadataManager
func NewTablePlanMetadataManagerMock(t minimock.Tester) *TablePlanMetadataManagerMock {
	m := &TablePlanMetadataManagerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetStatInfoMock = mTablePlanMetadataManagerMockGetStatInfo{mock: m}
	m.GetStatInfoMock.callArgs = []*TablePlanMetadataManagerMockGetStatInfoParams{}

	m.LayoutMock = mTablePlanMetadataManagerMockLayout{mock: m}
	m.LayoutMock.callArgs = []*TablePlanMetadataManagerMockLayoutParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTablePlanMetadataManagerMockGetStatInfo struct {
	optional           bool
	mock               *TablePlanMetadataManagerMock
	defaultExpectation *TablePlanMetadataManagerMockGetStatInfoExpectation
	expectations       []*TablePlanMetadataManagerMockGetStatInfoExpectation

	callArgs []*TablePlanMetadataManagerMockGetStatInfoParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TablePlanMetadataManagerMockGetStatInfoExpectation specifies expectation struct of the tablePlanMetadataManager.GetStatInfo
type TablePlanMetadataManagerMockGetStatInfoExpectation struct {
	mock      *TablePlanMetadataManagerMock
	params    *TablePlanMetadataManagerMockGetStatInfoParams
	paramPtrs *TablePlanMetadataManagerMockGetStatInfoParamPtrs
	results   *TablePlanMetadataManagerMockGetStatInfoResults
	Counter   uint64
}

// TablePlanMetadataManagerMockGetStatInfoParams contains parameters of the tablePlanMetadataManager.GetStatInfo
type TablePlanMetadataManagerMockGetStatInfoParams struct {
	tableName string
	layout    records.Layout
	trx       scan.TRXInt
}

// TablePlanMetadataManagerMockGetStatInfoParamPtrs contains pointers to parameters of the tablePlanMetadataManager.GetStatInfo
type TablePlanMetadataManagerMockGetStatInfoParamPtrs struct {
	tableName *string
	layout    *records.Layout
	trx       *scan.TRXInt
}

// TablePlanMetadataManagerMockGetStatInfoResults contains results of the tablePlanMetadataManager.GetStatInfo
type TablePlanMetadataManagerMockGetStatInfoResults struct {
	s1  metadata.StatInfo
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetStatInfo *mTablePlanMetadataManagerMockGetStatInfo) Optional() *mTablePlanMetadataManagerMockGetStatInfo {
	mmGetStatInfo.optional = true
	return mmGetStatInfo
}

// Expect sets up expected params for tablePlanMetadataManager.GetStatInfo
func (mmGetStatInfo *mTablePlanMetadataManagerMockGetStatInfo) Expect(tableName string, layout records.Layout, trx scan.TRXInt) *mTablePlanMetadataManagerMockGetStatInfo {
	if mmGetStatInfo.mock.funcGetStatInfo != nil {
		mmGetStatInfo.mock.t.Fatalf("TablePlanMetadataManagerMock.GetStatInfo mock is already set by Set")
	}

	if mmGetStatInfo.defaultExpectation == nil {
		mmGetStatInfo.defaultExpectation = &TablePlanMetadataManagerMockGetStatInfoExpectation{}
	}

	if mmGetStatInfo.defaultExpectation.paramPtrs != nil {
		mmGetStatInfo.mock.t.Fatalf("TablePlanMetadataManagerMock.GetStatInfo mock is already set by ExpectParams functions")
	}

	mmGetStatInfo.defaultExpectation.params = &TablePlanMetadataManagerMockGetStatInfoParams{tableName, layout, trx}
	for _, e := range mmGetStatInfo.expectations {
		if minimock.Equal(e.params, mmGetStatInfo.defaultExpectation.params) {
			mmGetStatInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetStatInfo.defaultExpectation.params)
		}
	}

	return mmGetStatInfo
}

// ExpectTableNameParam1 sets up expected param tableName for tablePlanMetadataManager.GetStatInfo
func (mmGetStatInfo *mTablePlanMetadataManagerMockGetStatInfo) ExpectTableNameParam1(tableName string) *mTablePlanMetadataManagerMockGetStatInfo {
	if mmGetStatInfo.mock.funcGetStatInfo != nil {
		mmGetStatInfo.mock.t.Fatalf("TablePlanMetadataManagerMock.GetStatInfo mock is already set by Set")
	}

	if mmGetStatInfo.defaultExpectation == nil {
		mmGetStatInfo.defaultExpectation = &TablePlanMetadataManagerMockGetStatInfoExpectation{}
	}

	if mmGetStatInfo.defaultExpectation.params != nil {
		mmGetStatInfo.mock.t.Fatalf("TablePlanMetadataManagerMock.GetStatInfo mock is already set by Expect")
	}

	if mmGetStatInfo.defaultExpectation.paramPtrs == nil {
		mmGetStatInfo.defaultExpectation.paramPtrs = &TablePlanMetadataManagerMockGetStatInfoParamPtrs{}
	}
	mmGetStatInfo.defaultExpectation.paramPtrs.tableName = &tableName

	return mmGetStatInfo
}

// ExpectLayoutParam2 sets up expected param layout for tablePlanMetadataManager.GetStatInfo
func (mmGetStatInfo *mTablePlanMetadataManagerMockGetStatInfo) ExpectLayoutParam2(layout records.Layout) *mTablePlanMetadataManagerMockGetStatInfo {
	if mmGetStatInfo.mock.funcGetStatInfo != nil {
		mmGetStatInfo.mock.t.Fatalf("TablePlanMetadataManagerMock.GetStatInfo mock is already set by Set")
	}

	if mmGetStatInfo.defaultExpectation == nil {
		mmGetStatInfo.defaultExpectation = &TablePlanMetadataManagerMockGetStatInfoExpectation{}
	}

	if mmGetStatInfo.defaultExpectation.params != nil {
		mmGetStatInfo.mock.t.Fatalf("TablePlanMetadataManagerMock.GetStatInfo mock is already set by Expect")
	}

	if mmGetStatInfo.defaultExpectation.paramPtrs == nil {
		mmGetStatInfo.defaultExpectation.paramPtrs = &TablePlanMetadataManagerMockGetStatInfoParamPtrs{}
	}
	mmGetStatInfo.defaultExpectation.paramPtrs.layout = &layout

	return mmGetStatInfo
}

// ExpectTrxParam3 sets up expected param trx for tablePlanMetadataManager.GetStatInfo
func (mmGetStatInfo *mTablePlanMetadataManagerMockGetStatInfo) ExpectTrxParam3(trx scan.TRXInt) *mTablePlanMetadataManagerMockGetStatInfo {
	if mmGetStatInfo.mock.funcGetStatInfo != nil {
		mmGetStatInfo.mock.t.Fatalf("TablePlanMetadataManagerMock.GetStatInfo mock is already set by Set")
	}

	if mmGetStatInfo.defaultExpectation == nil {
		mmGetStatInfo.defaultExpectation = &TablePlanMetadataManagerMockGetStatInfoExpectation{}
	}

	if mmGetStatInfo.defaultExpectation.params != nil {
		mmGetStatInfo.mock.t.Fatalf("TablePlanMetadataManagerMock.GetStatInfo mock is already set by Expect")
	}

	if mmGetStatInfo.defaultExpectation.paramPtrs == nil {
		mmGetStatInfo.defaultExpectation.paramPtrs = &TablePlanMetadataManagerMockGetStatInfoParamPtrs{}
	}
	mmGetStatInfo.defaultExpectation.paramPtrs.trx = &trx

	return mmGetStatInfo
}

// Inspect accepts an inspector function that has same arguments as the tablePlanMetadataManager.GetStatInfo
func (mmGetStatInfo *mTablePlanMetadataManagerMockGetStatInfo) Inspect(f func(tableName string, layout records.Layout, trx scan.TRXInt)) *mTablePlanMetadataManagerMockGetStatInfo {
	if mmGetStatInfo.mock.inspectFuncGetStatInfo != nil {
		mmGetStatInfo.mock.t.Fatalf("Inspect function is already set for TablePlanMetadataManagerMock.GetStatInfo")
	}

	mmGetStatInfo.mock.inspectFuncGetStatInfo = f

	return mmGetStatInfo
}

// Return sets up results that will be returned by tablePlanMetadataManager.GetStatInfo
func (mmGetStatInfo *mTablePlanMetadataManagerMockGetStatInfo) Return(s1 metadata.StatInfo, err error) *TablePlanMetadataManagerMock {
	if mmGetStatInfo.mock.funcGetStatInfo != nil {
		mmGetStatInfo.mock.t.Fatalf("TablePlanMetadataManagerMock.GetStatInfo mock is already set by Set")
	}

	if mmGetStatInfo.defaultExpectation == nil {
		mmGetStatInfo.defaultExpectation = &TablePlanMetadataManagerMockGetStatInfoExpectation{mock: mmGetStatInfo.mock}
	}
	mmGetStatInfo.defaultExpectation.results = &TablePlanMetadataManagerMockGetStatInfoResults{s1, err}
	return mmGetStatInfo.mock
}

// Set uses given function f to mock the tablePlanMetadataManager.GetStatInfo method
func (mmGetStatInfo *mTablePlanMetadataManagerMockGetStatInfo) Set(f func(tableName string, layout records.Layout, trx scan.TRXInt) (s1 metadata.StatInfo, err error)) *TablePlanMetadataManagerMock {
	if mmGetStatInfo.defaultExpectation != nil {
		mmGetStatInfo.mock.t.Fatalf("Default expectation is already set for the tablePlanMetadataManager.GetStatInfo method")
	}

	if len(mmGetStatInfo.expectations) > 0 {
		mmGetStatInfo.mock.t.Fatalf("Some expectations are already set for the tablePlanMetadataManager.GetStatInfo method")
	}

	mmGetStatInfo.mock.funcGetStatInfo = f
	return mmGetStatInfo.mock
}

// When sets expectation for the tablePlanMetadataManager.GetStatInfo which will trigger the result defined by the following
// Then helper
func (mmGetStatInfo *mTablePlanMetadataManagerMockGetStatInfo) When(tableName string, layout records.Layout, trx scan.TRXInt) *TablePlanMetadataManagerMockGetStatInfoExpectation {
	if mmGetStatInfo.mock.funcGetStatInfo != nil {
		mmGetStatInfo.mock.t.Fatalf("TablePlanMetadataManagerMock.GetStatInfo mock is already set by Set")
	}

	expectation := &TablePlanMetadataManagerMockGetStatInfoExpectation{
		mock:   mmGetStatInfo.mock,
		params: &TablePlanMetadataManagerMockGetStatInfoParams{tableName, layout, trx},
	}
	mmGetStatInfo.expectations = append(mmGetStatInfo.expectations, expectation)
	return expectation
}

// Then sets up tablePlanMetadataManager.GetStatInfo return parameters for the expectation previously defined by the When method
func (e *TablePlanMetadataManagerMockGetStatInfoExpectation) Then(s1 metadata.StatInfo, err error) *TablePlanMetadataManagerMock {
	e.results = &TablePlanMetadataManagerMockGetStatInfoResults{s1, err}
	return e.mock
}

// Times sets number of times tablePlanMetadataManager.GetStatInfo should be invoked
func (mmGetStatInfo *mTablePlanMetadataManagerMockGetStatInfo) Times(n uint64) *mTablePlanMetadataManagerMockGetStatInfo {
	if n == 0 {
		mmGetStatInfo.mock.t.Fatalf("Times of TablePlanMetadataManagerMock.GetStatInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetStatInfo.expectedInvocations, n)
	return mmGetStatInfo
}

func (mmGetStatInfo *mTablePlanMetadataManagerMockGetStatInfo) invocationsDone() bool {
	if len(mmGetStatInfo.expectations) == 0 && mmGetStatInfo.defaultExpectation == nil && mmGetStatInfo.mock.funcGetStatInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetStatInfo.mock.afterGetStatInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetStatInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetStatInfo implements tablePlanMetadataManager
func (mmGetStatInfo *TablePlanMetadataManagerMock) GetStatInfo(tableName string, layout records.Layout, trx scan.TRXInt) (s1 metadata.StatInfo, err error) {
	mm_atomic.AddUint64(&mmGetStatInfo.beforeGetStatInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStatInfo.afterGetStatInfoCounter, 1)

	if mmGetStatInfo.inspectFuncGetStatInfo != nil {
		mmGetStatInfo.inspectFuncGetStatInfo(tableName, layout, trx)
	}

	mm_params := TablePlanMetadataManagerMockGetStatInfoParams{tableName, layout, trx}

	// Record call args
	mmGetStatInfo.GetStatInfoMock.mutex.Lock()
	mmGetStatInfo.GetStatInfoMock.callArgs = append(mmGetStatInfo.GetStatInfoMock.callArgs, &mm_params)
	mmGetStatInfo.GetStatInfoMock.mutex.Unlock()

	for _, e := range mmGetStatInfo.GetStatInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetStatInfo.GetStatInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStatInfo.GetStatInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmGetStatInfo.GetStatInfoMock.defaultExpectation.params
		mm_want_ptrs := mmGetStatInfo.GetStatInfoMock.defaultExpectation.paramPtrs

		mm_got := TablePlanMetadataManagerMockGetStatInfoParams{tableName, layout, trx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.tableName != nil && !minimock.Equal(*mm_want_ptrs.tableName, mm_got.tableName) {
				mmGetStatInfo.t.Errorf("TablePlanMetadataManagerMock.GetStatInfo got unexpected parameter tableName, want: %#v, got: %#v%s\n", *mm_want_ptrs.tableName, mm_got.tableName, minimock.Diff(*mm_want_ptrs.tableName, mm_got.tableName))
			}

			if mm_want_ptrs.layout != nil && !minimock.Equal(*mm_want_ptrs.layout, mm_got.layout) {
				mmGetStatInfo.t.Errorf("TablePlanMetadataManagerMock.GetStatInfo got unexpected parameter layout, want: %#v, got: %#v%s\n", *mm_want_ptrs.layout, mm_got.layout, minimock.Diff(*mm_want_ptrs.layout, mm_got.layout))
			}

			if mm_want_ptrs.trx != nil && !minimock.Equal(*mm_want_ptrs.trx, mm_got.trx) {
				mmGetStatInfo.t.Errorf("TablePlanMetadataManagerMock.GetStatInfo got unexpected parameter trx, want: %#v, got: %#v%s\n", *mm_want_ptrs.trx, mm_got.trx, minimock.Diff(*mm_want_ptrs.trx, mm_got.trx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetStatInfo.t.Errorf("TablePlanMetadataManagerMock.GetStatInfo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetStatInfo.GetStatInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStatInfo.t.Fatal("No results are set for the TablePlanMetadataManagerMock.GetStatInfo")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetStatInfo.funcGetStatInfo != nil {
		return mmGetStatInfo.funcGetStatInfo(tableName, layout, trx)
	}
	mmGetStatInfo.t.Fatalf("Unexpected call to TablePlanMetadataManagerMock.GetStatInfo. %v %v %v", tableName, layout, trx)
	return
}

// GetStatInfoAfterCounter returns a count of finished TablePlanMetadataManagerMock.GetStatInfo invocations
func (mmGetStatInfo *TablePlanMetadataManagerMock) GetStatInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStatInfo.afterGetStatInfoCounter)
}

// GetStatInfoBeforeCounter returns a count of TablePlanMetadataManagerMock.GetStatInfo invocations
func (mmGetStatInfo *TablePlanMetadataManagerMock) GetStatInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStatInfo.beforeGetStatInfoCounter)
}

// Calls returns a list of arguments used in each call to TablePlanMetadataManagerMock.GetStatInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetStatInfo *mTablePlanMetadataManagerMockGetStatInfo) Calls() []*TablePlanMetadataManagerMockGetStatInfoParams {
	mmGetStatInfo.mutex.RLock()

	argCopy := make([]*TablePlanMetadataManagerMockGetStatInfoParams, len(mmGetStatInfo.callArgs))
	copy(argCopy, mmGetStatInfo.callArgs)

	mmGetStatInfo.mutex.RUnlock()

	return argCopy
}

// MinimockGetStatInfoDone returns true if the count of the GetStatInfo invocations corresponds
// the number of defined expectations
func (m *TablePlanMetadataManagerMock) MinimockGetStatInfoDone() bool {
	if m.GetStatInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetStatInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetStatInfoMock.invocationsDone()
}

// MinimockGetStatInfoInspect logs each unmet expectation
func (m *TablePlanMetadataManagerMock) MinimockGetStatInfoInspect() {
	for _, e := range m.GetStatInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TablePlanMetadataManagerMock.GetStatInfo with params: %#v", *e.params)
		}
	}

	afterGetStatInfoCounter := mm_atomic.LoadUint64(&m.afterGetStatInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetStatInfoMock.defaultExpectation != nil && afterGetStatInfoCounter < 1 {
		if m.GetStatInfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TablePlanMetadataManagerMock.GetStatInfo")
		} else {
			m.t.Errorf("Expected call to TablePlanMetadataManagerMock.GetStatInfo with params: %#v", *m.GetStatInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStatInfo != nil && afterGetStatInfoCounter < 1 {
		m.t.Error("Expected call to TablePlanMetadataManagerMock.GetStatInfo")
	}

	if !m.GetStatInfoMock.invocationsDone() && afterGetStatInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to TablePlanMetadataManagerMock.GetStatInfo but found %d calls",
			mm_atomic.LoadUint64(&m.GetStatInfoMock.expectedInvocations), afterGetStatInfoCounter)
	}
}

type mTablePlanMetadataManagerMockLayout struct {
	optional           bool
	mock               *TablePlanMetadataManagerMock
	defaultExpectation *TablePlanMetadataManagerMockLayoutExpectation
	expectations       []*TablePlanMetadataManagerMockLayoutExpectation

	callArgs []*TablePlanMetadataManagerMockLayoutParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TablePlanMetadataManagerMockLayoutExpectation specifies expectation struct of the tablePlanMetadataManager.Layout
type TablePlanMetadataManagerMockLayoutExpectation struct {
	mock      *TablePlanMetadataManagerMock
	params    *TablePlanMetadataManagerMockLayoutParams
	paramPtrs *TablePlanMetadataManagerMockLayoutParamPtrs
	results   *TablePlanMetadataManagerMockLayoutResults
	Counter   uint64
}

// TablePlanMetadataManagerMockLayoutParams contains parameters of the tablePlanMetadataManager.Layout
type TablePlanMetadataManagerMockLayoutParams struct {
	tableName string
	trx       scan.TRXInt
}

// TablePlanMetadataManagerMockLayoutParamPtrs contains pointers to parameters of the tablePlanMetadataManager.Layout
type TablePlanMetadataManagerMockLayoutParamPtrs struct {
	tableName *string
	trx       *scan.TRXInt
}

// TablePlanMetadataManagerMockLayoutResults contains results of the tablePlanMetadataManager.Layout
type TablePlanMetadataManagerMockLayoutResults struct {
	l1  records.Layout
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLayout *mTablePlanMetadataManagerMockLayout) Optional() *mTablePlanMetadataManagerMockLayout {
	mmLayout.optional = true
	return mmLayout
}

// Expect sets up expected params for tablePlanMetadataManager.Layout
func (mmLayout *mTablePlanMetadataManagerMockLayout) Expect(tableName string, trx scan.TRXInt) *mTablePlanMetadataManagerMockLayout {
	if mmLayout.mock.funcLayout != nil {
		mmLayout.mock.t.Fatalf("TablePlanMetadataManagerMock.Layout mock is already set by Set")
	}

	if mmLayout.defaultExpectation == nil {
		mmLayout.defaultExpectation = &TablePlanMetadataManagerMockLayoutExpectation{}
	}

	if mmLayout.defaultExpectation.paramPtrs != nil {
		mmLayout.mock.t.Fatalf("TablePlanMetadataManagerMock.Layout mock is already set by ExpectParams functions")
	}

	mmLayout.defaultExpectation.params = &TablePlanMetadataManagerMockLayoutParams{tableName, trx}
	for _, e := range mmLayout.expectations {
		if minimock.Equal(e.params, mmLayout.defaultExpectation.params) {
			mmLayout.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLayout.defaultExpectation.params)
		}
	}

	return mmLayout
}

// ExpectTableNameParam1 sets up expected param tableName for tablePlanMetadataManager.Layout
func (mmLayout *mTablePlanMetadataManagerMockLayout) ExpectTableNameParam1(tableName string) *mTablePlanMetadataManagerMockLayout {
	if mmLayout.mock.funcLayout != nil {
		mmLayout.mock.t.Fatalf("TablePlanMetadataManagerMock.Layout mock is already set by Set")
	}

	if mmLayout.defaultExpectation == nil {
		mmLayout.defaultExpectation = &TablePlanMetadataManagerMockLayoutExpectation{}
	}

	if mmLayout.defaultExpectation.params != nil {
		mmLayout.mock.t.Fatalf("TablePlanMetadataManagerMock.Layout mock is already set by Expect")
	}

	if mmLayout.defaultExpectation.paramPtrs == nil {
		mmLayout.defaultExpectation.paramPtrs = &TablePlanMetadataManagerMockLayoutParamPtrs{}
	}
	mmLayout.defaultExpectation.paramPtrs.tableName = &tableName

	return mmLayout
}

// ExpectTrxParam2 sets up expected param trx for tablePlanMetadataManager.Layout
func (mmLayout *mTablePlanMetadataManagerMockLayout) ExpectTrxParam2(trx scan.TRXInt) *mTablePlanMetadataManagerMockLayout {
	if mmLayout.mock.funcLayout != nil {
		mmLayout.mock.t.Fatalf("TablePlanMetadataManagerMock.Layout mock is already set by Set")
	}

	if mmLayout.defaultExpectation == nil {
		mmLayout.defaultExpectation = &TablePlanMetadataManagerMockLayoutExpectation{}
	}

	if mmLayout.defaultExpectation.params != nil {
		mmLayout.mock.t.Fatalf("TablePlanMetadataManagerMock.Layout mock is already set by Expect")
	}

	if mmLayout.defaultExpectation.paramPtrs == nil {
		mmLayout.defaultExpectation.paramPtrs = &TablePlanMetadataManagerMockLayoutParamPtrs{}
	}
	mmLayout.defaultExpectation.paramPtrs.trx = &trx

	return mmLayout
}

// Inspect accepts an inspector function that has same arguments as the tablePlanMetadataManager.Layout
func (mmLayout *mTablePlanMetadataManagerMockLayout) Inspect(f func(tableName string, trx scan.TRXInt)) *mTablePlanMetadataManagerMockLayout {
	if mmLayout.mock.inspectFuncLayout != nil {
		mmLayout.mock.t.Fatalf("Inspect function is already set for TablePlanMetadataManagerMock.Layout")
	}

	mmLayout.mock.inspectFuncLayout = f

	return mmLayout
}

// Return sets up results that will be returned by tablePlanMetadataManager.Layout
func (mmLayout *mTablePlanMetadataManagerMockLayout) Return(l1 records.Layout, err error) *TablePlanMetadataManagerMock {
	if mmLayout.mock.funcLayout != nil {
		mmLayout.mock.t.Fatalf("TablePlanMetadataManagerMock.Layout mock is already set by Set")
	}

	if mmLayout.defaultExpectation == nil {
		mmLayout.defaultExpectation = &TablePlanMetadataManagerMockLayoutExpectation{mock: mmLayout.mock}
	}
	mmLayout.defaultExpectation.results = &TablePlanMetadataManagerMockLayoutResults{l1, err}
	return mmLayout.mock
}

// Set uses given function f to mock the tablePlanMetadataManager.Layout method
func (mmLayout *mTablePlanMetadataManagerMockLayout) Set(f func(tableName string, trx scan.TRXInt) (l1 records.Layout, err error)) *TablePlanMetadataManagerMock {
	if mmLayout.defaultExpectation != nil {
		mmLayout.mock.t.Fatalf("Default expectation is already set for the tablePlanMetadataManager.Layout method")
	}

	if len(mmLayout.expectations) > 0 {
		mmLayout.mock.t.Fatalf("Some expectations are already set for the tablePlanMetadataManager.Layout method")
	}

	mmLayout.mock.funcLayout = f
	return mmLayout.mock
}

// When sets expectation for the tablePlanMetadataManager.Layout which will trigger the result defined by the following
// Then helper
func (mmLayout *mTablePlanMetadataManagerMockLayout) When(tableName string, trx scan.TRXInt) *TablePlanMetadataManagerMockLayoutExpectation {
	if mmLayout.mock.funcLayout != nil {
		mmLayout.mock.t.Fatalf("TablePlanMetadataManagerMock.Layout mock is already set by Set")
	}

	expectation := &TablePlanMetadataManagerMockLayoutExpectation{
		mock:   mmLayout.mock,
		params: &TablePlanMetadataManagerMockLayoutParams{tableName, trx},
	}
	mmLayout.expectations = append(mmLayout.expectations, expectation)
	return expectation
}

// Then sets up tablePlanMetadataManager.Layout return parameters for the expectation previously defined by the When method
func (e *TablePlanMetadataManagerMockLayoutExpectation) Then(l1 records.Layout, err error) *TablePlanMetadataManagerMock {
	e.results = &TablePlanMetadataManagerMockLayoutResults{l1, err}
	return e.mock
}

// Times sets number of times tablePlanMetadataManager.Layout should be invoked
func (mmLayout *mTablePlanMetadataManagerMockLayout) Times(n uint64) *mTablePlanMetadataManagerMockLayout {
	if n == 0 {
		mmLayout.mock.t.Fatalf("Times of TablePlanMetadataManagerMock.Layout mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLayout.expectedInvocations, n)
	return mmLayout
}

func (mmLayout *mTablePlanMetadataManagerMockLayout) invocationsDone() bool {
	if len(mmLayout.expectations) == 0 && mmLayout.defaultExpectation == nil && mmLayout.mock.funcLayout == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLayout.mock.afterLayoutCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLayout.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Layout implements tablePlanMetadataManager
func (mmLayout *TablePlanMetadataManagerMock) Layout(tableName string, trx scan.TRXInt) (l1 records.Layout, err error) {
	mm_atomic.AddUint64(&mmLayout.beforeLayoutCounter, 1)
	defer mm_atomic.AddUint64(&mmLayout.afterLayoutCounter, 1)

	if mmLayout.inspectFuncLayout != nil {
		mmLayout.inspectFuncLayout(tableName, trx)
	}

	mm_params := TablePlanMetadataManagerMockLayoutParams{tableName, trx}

	// Record call args
	mmLayout.LayoutMock.mutex.Lock()
	mmLayout.LayoutMock.callArgs = append(mmLayout.LayoutMock.callArgs, &mm_params)
	mmLayout.LayoutMock.mutex.Unlock()

	for _, e := range mmLayout.LayoutMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1, e.results.err
		}
	}

	if mmLayout.LayoutMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLayout.LayoutMock.defaultExpectation.Counter, 1)
		mm_want := mmLayout.LayoutMock.defaultExpectation.params
		mm_want_ptrs := mmLayout.LayoutMock.defaultExpectation.paramPtrs

		mm_got := TablePlanMetadataManagerMockLayoutParams{tableName, trx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.tableName != nil && !minimock.Equal(*mm_want_ptrs.tableName, mm_got.tableName) {
				mmLayout.t.Errorf("TablePlanMetadataManagerMock.Layout got unexpected parameter tableName, want: %#v, got: %#v%s\n", *mm_want_ptrs.tableName, mm_got.tableName, minimock.Diff(*mm_want_ptrs.tableName, mm_got.tableName))
			}

			if mm_want_ptrs.trx != nil && !minimock.Equal(*mm_want_ptrs.trx, mm_got.trx) {
				mmLayout.t.Errorf("TablePlanMetadataManagerMock.Layout got unexpected parameter trx, want: %#v, got: %#v%s\n", *mm_want_ptrs.trx, mm_got.trx, minimock.Diff(*mm_want_ptrs.trx, mm_got.trx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLayout.t.Errorf("TablePlanMetadataManagerMock.Layout got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLayout.LayoutMock.defaultExpectation.results
		if mm_results == nil {
			mmLayout.t.Fatal("No results are set for the TablePlanMetadataManagerMock.Layout")
		}
		return (*mm_results).l1, (*mm_results).err
	}
	if mmLayout.funcLayout != nil {
		return mmLayout.funcLayout(tableName, trx)
	}
	mmLayout.t.Fatalf("Unexpected call to TablePlanMetadataManagerMock.Layout. %v %v", tableName, trx)
	return
}

// LayoutAfterCounter returns a count of finished TablePlanMetadataManagerMock.Layout invocations
func (mmLayout *TablePlanMetadataManagerMock) LayoutAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLayout.afterLayoutCounter)
}

// LayoutBeforeCounter returns a count of TablePlanMetadataManagerMock.Layout invocations
func (mmLayout *TablePlanMetadataManagerMock) LayoutBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLayout.beforeLayoutCounter)
}

// Calls returns a list of arguments used in each call to TablePlanMetadataManagerMock.Layout.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLayout *mTablePlanMetadataManagerMockLayout) Calls() []*TablePlanMetadataManagerMockLayoutParams {
	mmLayout.mutex.RLock()

	argCopy := make([]*TablePlanMetadataManagerMockLayoutParams, len(mmLayout.callArgs))
	copy(argCopy, mmLayout.callArgs)

	mmLayout.mutex.RUnlock()

	return argCopy
}

// MinimockLayoutDone returns true if the count of the Layout invocations corresponds
// the number of defined expectations
func (m *TablePlanMetadataManagerMock) MinimockLayoutDone() bool {
	if m.LayoutMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LayoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LayoutMock.invocationsDone()
}

// MinimockLayoutInspect logs each unmet expectation
func (m *TablePlanMetadataManagerMock) MinimockLayoutInspect() {
	for _, e := range m.LayoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TablePlanMetadataManagerMock.Layout with params: %#v", *e.params)
		}
	}

	afterLayoutCounter := mm_atomic.LoadUint64(&m.afterLayoutCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LayoutMock.defaultExpectation != nil && afterLayoutCounter < 1 {
		if m.LayoutMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TablePlanMetadataManagerMock.Layout")
		} else {
			m.t.Errorf("Expected call to TablePlanMetadataManagerMock.Layout with params: %#v", *m.LayoutMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLayout != nil && afterLayoutCounter < 1 {
		m.t.Error("Expected call to TablePlanMetadataManagerMock.Layout")
	}

	if !m.LayoutMock.invocationsDone() && afterLayoutCounter > 0 {
		m.t.Errorf("Expected %d calls to TablePlanMetadataManagerMock.Layout but found %d calls",
			mm_atomic.LoadUint64(&m.LayoutMock.expectedInvocations), afterLayoutCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TablePlanMetadataManagerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetStatInfoInspect()

			m.MinimockLayoutInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TablePlanMetadataManagerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TablePlanMetadataManagerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetStatInfoDone() &&
		m.MinimockLayoutDone()
}
