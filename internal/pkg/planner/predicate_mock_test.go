// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package planner

//go:generate minimock -i github.com/unhandled-exception/sophiadb/internal/pkg/scan.Predicate -o predicate_mock_test.go -n PredicateMock -p planner

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/unhandled-exception/sophiadb/internal/pkg/records"
	mm_scan "github.com/unhandled-exception/sophiadb/internal/pkg/scan"
)

// PredicateMock implements scan.Predicate
type PredicateMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcConjoinWith          func(p1 mm_scan.Predicate)
	inspectFuncConjoinWith   func(p1 mm_scan.Predicate)
	afterConjoinWithCounter  uint64
	beforeConjoinWithCounter uint64
	ConjoinWithMock          mPredicateMockConjoinWith

	funcEquatesWithConstant          func(s1 string) (c1 mm_scan.Constant, b1 bool)
	inspectFuncEquatesWithConstant   func(s1 string)
	afterEquatesWithConstantCounter  uint64
	beforeEquatesWithConstantCounter uint64
	EquatesWithConstantMock          mPredicateMockEquatesWithConstant

	funcEquatesWithField          func(s1 string) (s2 string, b1 bool)
	inspectFuncEquatesWithField   func(s1 string)
	afterEquatesWithFieldCounter  uint64
	beforeEquatesWithFieldCounter uint64
	EquatesWithFieldMock          mPredicateMockEquatesWithField

	funcIsSatisfied          func(s1 mm_scan.Scan) (b1 bool, err error)
	inspectFuncIsSatisfied   func(s1 mm_scan.Scan)
	afterIsSatisfiedCounter  uint64
	beforeIsSatisfiedCounter uint64
	IsSatisfiedMock          mPredicateMockIsSatisfied

	funcJoinSubPred          func(s1 records.Schema, s2 records.Schema) (p1 mm_scan.Predicate)
	inspectFuncJoinSubPred   func(s1 records.Schema, s2 records.Schema)
	afterJoinSubPredCounter  uint64
	beforeJoinSubPredCounter uint64
	JoinSubPredMock          mPredicateMockJoinSubPred

	funcReductionFactor          func(p1 mm_scan.Plan) (i1 int64, b1 bool)
	inspectFuncReductionFactor   func(p1 mm_scan.Plan)
	afterReductionFactorCounter  uint64
	beforeReductionFactorCounter uint64
	ReductionFactorMock          mPredicateMockReductionFactor

	funcSelectSubPred          func(s1 records.Schema) (p1 mm_scan.Predicate)
	inspectFuncSelectSubPred   func(s1 records.Schema)
	afterSelectSubPredCounter  uint64
	beforeSelectSubPredCounter uint64
	SelectSubPredMock          mPredicateMockSelectSubPred

	funcString          func() (s1 string)
	inspectFuncString   func()
	afterStringCounter  uint64
	beforeStringCounter uint64
	StringMock          mPredicateMockString

	funcTerms          func() (ta1 []mm_scan.Term)
	inspectFuncTerms   func()
	afterTermsCounter  uint64
	beforeTermsCounter uint64
	TermsMock          mPredicateMockTerms
}

// NewPredicateMock returns a mock for scan.Predicate
func NewPredicateMock(t minimock.Tester) *PredicateMock {
	m := &PredicateMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ConjoinWithMock = mPredicateMockConjoinWith{mock: m}
	m.ConjoinWithMock.callArgs = []*PredicateMockConjoinWithParams{}

	m.EquatesWithConstantMock = mPredicateMockEquatesWithConstant{mock: m}
	m.EquatesWithConstantMock.callArgs = []*PredicateMockEquatesWithConstantParams{}

	m.EquatesWithFieldMock = mPredicateMockEquatesWithField{mock: m}
	m.EquatesWithFieldMock.callArgs = []*PredicateMockEquatesWithFieldParams{}

	m.IsSatisfiedMock = mPredicateMockIsSatisfied{mock: m}
	m.IsSatisfiedMock.callArgs = []*PredicateMockIsSatisfiedParams{}

	m.JoinSubPredMock = mPredicateMockJoinSubPred{mock: m}
	m.JoinSubPredMock.callArgs = []*PredicateMockJoinSubPredParams{}

	m.ReductionFactorMock = mPredicateMockReductionFactor{mock: m}
	m.ReductionFactorMock.callArgs = []*PredicateMockReductionFactorParams{}

	m.SelectSubPredMock = mPredicateMockSelectSubPred{mock: m}
	m.SelectSubPredMock.callArgs = []*PredicateMockSelectSubPredParams{}

	m.StringMock = mPredicateMockString{mock: m}

	m.TermsMock = mPredicateMockTerms{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPredicateMockConjoinWith struct {
	optional           bool
	mock               *PredicateMock
	defaultExpectation *PredicateMockConjoinWithExpectation
	expectations       []*PredicateMockConjoinWithExpectation

	callArgs []*PredicateMockConjoinWithParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// PredicateMockConjoinWithExpectation specifies expectation struct of the Predicate.ConjoinWith
type PredicateMockConjoinWithExpectation struct {
	mock      *PredicateMock
	params    *PredicateMockConjoinWithParams
	paramPtrs *PredicateMockConjoinWithParamPtrs

	Counter uint64
}

// PredicateMockConjoinWithParams contains parameters of the Predicate.ConjoinWith
type PredicateMockConjoinWithParams struct {
	p1 mm_scan.Predicate
}

// PredicateMockConjoinWithParamPtrs contains pointers to parameters of the Predicate.ConjoinWith
type PredicateMockConjoinWithParamPtrs struct {
	p1 *mm_scan.Predicate
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConjoinWith *mPredicateMockConjoinWith) Optional() *mPredicateMockConjoinWith {
	mmConjoinWith.optional = true
	return mmConjoinWith
}

// Expect sets up expected params for Predicate.ConjoinWith
func (mmConjoinWith *mPredicateMockConjoinWith) Expect(p1 mm_scan.Predicate) *mPredicateMockConjoinWith {
	if mmConjoinWith.mock.funcConjoinWith != nil {
		mmConjoinWith.mock.t.Fatalf("PredicateMock.ConjoinWith mock is already set by Set")
	}

	if mmConjoinWith.defaultExpectation == nil {
		mmConjoinWith.defaultExpectation = &PredicateMockConjoinWithExpectation{}
	}

	if mmConjoinWith.defaultExpectation.paramPtrs != nil {
		mmConjoinWith.mock.t.Fatalf("PredicateMock.ConjoinWith mock is already set by ExpectParams functions")
	}

	mmConjoinWith.defaultExpectation.params = &PredicateMockConjoinWithParams{p1}
	for _, e := range mmConjoinWith.expectations {
		if minimock.Equal(e.params, mmConjoinWith.defaultExpectation.params) {
			mmConjoinWith.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConjoinWith.defaultExpectation.params)
		}
	}

	return mmConjoinWith
}

// ExpectP1Param1 sets up expected param p1 for Predicate.ConjoinWith
func (mmConjoinWith *mPredicateMockConjoinWith) ExpectP1Param1(p1 mm_scan.Predicate) *mPredicateMockConjoinWith {
	if mmConjoinWith.mock.funcConjoinWith != nil {
		mmConjoinWith.mock.t.Fatalf("PredicateMock.ConjoinWith mock is already set by Set")
	}

	if mmConjoinWith.defaultExpectation == nil {
		mmConjoinWith.defaultExpectation = &PredicateMockConjoinWithExpectation{}
	}

	if mmConjoinWith.defaultExpectation.params != nil {
		mmConjoinWith.mock.t.Fatalf("PredicateMock.ConjoinWith mock is already set by Expect")
	}

	if mmConjoinWith.defaultExpectation.paramPtrs == nil {
		mmConjoinWith.defaultExpectation.paramPtrs = &PredicateMockConjoinWithParamPtrs{}
	}
	mmConjoinWith.defaultExpectation.paramPtrs.p1 = &p1

	return mmConjoinWith
}

// Inspect accepts an inspector function that has same arguments as the Predicate.ConjoinWith
func (mmConjoinWith *mPredicateMockConjoinWith) Inspect(f func(p1 mm_scan.Predicate)) *mPredicateMockConjoinWith {
	if mmConjoinWith.mock.inspectFuncConjoinWith != nil {
		mmConjoinWith.mock.t.Fatalf("Inspect function is already set for PredicateMock.ConjoinWith")
	}

	mmConjoinWith.mock.inspectFuncConjoinWith = f

	return mmConjoinWith
}

// Return sets up results that will be returned by Predicate.ConjoinWith
func (mmConjoinWith *mPredicateMockConjoinWith) Return() *PredicateMock {
	if mmConjoinWith.mock.funcConjoinWith != nil {
		mmConjoinWith.mock.t.Fatalf("PredicateMock.ConjoinWith mock is already set by Set")
	}

	if mmConjoinWith.defaultExpectation == nil {
		mmConjoinWith.defaultExpectation = &PredicateMockConjoinWithExpectation{mock: mmConjoinWith.mock}
	}

	return mmConjoinWith.mock
}

// Set uses given function f to mock the Predicate.ConjoinWith method
func (mmConjoinWith *mPredicateMockConjoinWith) Set(f func(p1 mm_scan.Predicate)) *PredicateMock {
	if mmConjoinWith.defaultExpectation != nil {
		mmConjoinWith.mock.t.Fatalf("Default expectation is already set for the Predicate.ConjoinWith method")
	}

	if len(mmConjoinWith.expectations) > 0 {
		mmConjoinWith.mock.t.Fatalf("Some expectations are already set for the Predicate.ConjoinWith method")
	}

	mmConjoinWith.mock.funcConjoinWith = f
	return mmConjoinWith.mock
}

// Times sets number of times Predicate.ConjoinWith should be invoked
func (mmConjoinWith *mPredicateMockConjoinWith) Times(n uint64) *mPredicateMockConjoinWith {
	if n == 0 {
		mmConjoinWith.mock.t.Fatalf("Times of PredicateMock.ConjoinWith mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConjoinWith.expectedInvocations, n)
	return mmConjoinWith
}

func (mmConjoinWith *mPredicateMockConjoinWith) invocationsDone() bool {
	if len(mmConjoinWith.expectations) == 0 && mmConjoinWith.defaultExpectation == nil && mmConjoinWith.mock.funcConjoinWith == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConjoinWith.mock.afterConjoinWithCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConjoinWith.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConjoinWith implements scan.Predicate
func (mmConjoinWith *PredicateMock) ConjoinWith(p1 mm_scan.Predicate) {
	mm_atomic.AddUint64(&mmConjoinWith.beforeConjoinWithCounter, 1)
	defer mm_atomic.AddUint64(&mmConjoinWith.afterConjoinWithCounter, 1)

	if mmConjoinWith.inspectFuncConjoinWith != nil {
		mmConjoinWith.inspectFuncConjoinWith(p1)
	}

	mm_params := PredicateMockConjoinWithParams{p1}

	// Record call args
	mmConjoinWith.ConjoinWithMock.mutex.Lock()
	mmConjoinWith.ConjoinWithMock.callArgs = append(mmConjoinWith.ConjoinWithMock.callArgs, &mm_params)
	mmConjoinWith.ConjoinWithMock.mutex.Unlock()

	for _, e := range mmConjoinWith.ConjoinWithMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmConjoinWith.ConjoinWithMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConjoinWith.ConjoinWithMock.defaultExpectation.Counter, 1)
		mm_want := mmConjoinWith.ConjoinWithMock.defaultExpectation.params
		mm_want_ptrs := mmConjoinWith.ConjoinWithMock.defaultExpectation.paramPtrs

		mm_got := PredicateMockConjoinWithParams{p1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.p1 != nil && !minimock.Equal(*mm_want_ptrs.p1, mm_got.p1) {
				mmConjoinWith.t.Errorf("PredicateMock.ConjoinWith got unexpected parameter p1, want: %#v, got: %#v%s\n", *mm_want_ptrs.p1, mm_got.p1, minimock.Diff(*mm_want_ptrs.p1, mm_got.p1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConjoinWith.t.Errorf("PredicateMock.ConjoinWith got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmConjoinWith.funcConjoinWith != nil {
		mmConjoinWith.funcConjoinWith(p1)
		return
	}
	mmConjoinWith.t.Fatalf("Unexpected call to PredicateMock.ConjoinWith. %v", p1)

}

// ConjoinWithAfterCounter returns a count of finished PredicateMock.ConjoinWith invocations
func (mmConjoinWith *PredicateMock) ConjoinWithAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConjoinWith.afterConjoinWithCounter)
}

// ConjoinWithBeforeCounter returns a count of PredicateMock.ConjoinWith invocations
func (mmConjoinWith *PredicateMock) ConjoinWithBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConjoinWith.beforeConjoinWithCounter)
}

// Calls returns a list of arguments used in each call to PredicateMock.ConjoinWith.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConjoinWith *mPredicateMockConjoinWith) Calls() []*PredicateMockConjoinWithParams {
	mmConjoinWith.mutex.RLock()

	argCopy := make([]*PredicateMockConjoinWithParams, len(mmConjoinWith.callArgs))
	copy(argCopy, mmConjoinWith.callArgs)

	mmConjoinWith.mutex.RUnlock()

	return argCopy
}

// MinimockConjoinWithDone returns true if the count of the ConjoinWith invocations corresponds
// the number of defined expectations
func (m *PredicateMock) MinimockConjoinWithDone() bool {
	if m.ConjoinWithMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConjoinWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConjoinWithMock.invocationsDone()
}

// MinimockConjoinWithInspect logs each unmet expectation
func (m *PredicateMock) MinimockConjoinWithInspect() {
	for _, e := range m.ConjoinWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PredicateMock.ConjoinWith with params: %#v", *e.params)
		}
	}

	afterConjoinWithCounter := mm_atomic.LoadUint64(&m.afterConjoinWithCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConjoinWithMock.defaultExpectation != nil && afterConjoinWithCounter < 1 {
		if m.ConjoinWithMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PredicateMock.ConjoinWith")
		} else {
			m.t.Errorf("Expected call to PredicateMock.ConjoinWith with params: %#v", *m.ConjoinWithMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConjoinWith != nil && afterConjoinWithCounter < 1 {
		m.t.Error("Expected call to PredicateMock.ConjoinWith")
	}

	if !m.ConjoinWithMock.invocationsDone() && afterConjoinWithCounter > 0 {
		m.t.Errorf("Expected %d calls to PredicateMock.ConjoinWith but found %d calls",
			mm_atomic.LoadUint64(&m.ConjoinWithMock.expectedInvocations), afterConjoinWithCounter)
	}
}

type mPredicateMockEquatesWithConstant struct {
	optional           bool
	mock               *PredicateMock
	defaultExpectation *PredicateMockEquatesWithConstantExpectation
	expectations       []*PredicateMockEquatesWithConstantExpectation

	callArgs []*PredicateMockEquatesWithConstantParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// PredicateMockEquatesWithConstantExpectation specifies expectation struct of the Predicate.EquatesWithConstant
type PredicateMockEquatesWithConstantExpectation struct {
	mock      *PredicateMock
	params    *PredicateMockEquatesWithConstantParams
	paramPtrs *PredicateMockEquatesWithConstantParamPtrs
	results   *PredicateMockEquatesWithConstantResults
	Counter   uint64
}

// PredicateMockEquatesWithConstantParams contains parameters of the Predicate.EquatesWithConstant
type PredicateMockEquatesWithConstantParams struct {
	s1 string
}

// PredicateMockEquatesWithConstantParamPtrs contains pointers to parameters of the Predicate.EquatesWithConstant
type PredicateMockEquatesWithConstantParamPtrs struct {
	s1 *string
}

// PredicateMockEquatesWithConstantResults contains results of the Predicate.EquatesWithConstant
type PredicateMockEquatesWithConstantResults struct {
	c1 mm_scan.Constant
	b1 bool
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEquatesWithConstant *mPredicateMockEquatesWithConstant) Optional() *mPredicateMockEquatesWithConstant {
	mmEquatesWithConstant.optional = true
	return mmEquatesWithConstant
}

// Expect sets up expected params for Predicate.EquatesWithConstant
func (mmEquatesWithConstant *mPredicateMockEquatesWithConstant) Expect(s1 string) *mPredicateMockEquatesWithConstant {
	if mmEquatesWithConstant.mock.funcEquatesWithConstant != nil {
		mmEquatesWithConstant.mock.t.Fatalf("PredicateMock.EquatesWithConstant mock is already set by Set")
	}

	if mmEquatesWithConstant.defaultExpectation == nil {
		mmEquatesWithConstant.defaultExpectation = &PredicateMockEquatesWithConstantExpectation{}
	}

	if mmEquatesWithConstant.defaultExpectation.paramPtrs != nil {
		mmEquatesWithConstant.mock.t.Fatalf("PredicateMock.EquatesWithConstant mock is already set by ExpectParams functions")
	}

	mmEquatesWithConstant.defaultExpectation.params = &PredicateMockEquatesWithConstantParams{s1}
	for _, e := range mmEquatesWithConstant.expectations {
		if minimock.Equal(e.params, mmEquatesWithConstant.defaultExpectation.params) {
			mmEquatesWithConstant.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEquatesWithConstant.defaultExpectation.params)
		}
	}

	return mmEquatesWithConstant
}

// ExpectS1Param1 sets up expected param s1 for Predicate.EquatesWithConstant
func (mmEquatesWithConstant *mPredicateMockEquatesWithConstant) ExpectS1Param1(s1 string) *mPredicateMockEquatesWithConstant {
	if mmEquatesWithConstant.mock.funcEquatesWithConstant != nil {
		mmEquatesWithConstant.mock.t.Fatalf("PredicateMock.EquatesWithConstant mock is already set by Set")
	}

	if mmEquatesWithConstant.defaultExpectation == nil {
		mmEquatesWithConstant.defaultExpectation = &PredicateMockEquatesWithConstantExpectation{}
	}

	if mmEquatesWithConstant.defaultExpectation.params != nil {
		mmEquatesWithConstant.mock.t.Fatalf("PredicateMock.EquatesWithConstant mock is already set by Expect")
	}

	if mmEquatesWithConstant.defaultExpectation.paramPtrs == nil {
		mmEquatesWithConstant.defaultExpectation.paramPtrs = &PredicateMockEquatesWithConstantParamPtrs{}
	}
	mmEquatesWithConstant.defaultExpectation.paramPtrs.s1 = &s1

	return mmEquatesWithConstant
}

// Inspect accepts an inspector function that has same arguments as the Predicate.EquatesWithConstant
func (mmEquatesWithConstant *mPredicateMockEquatesWithConstant) Inspect(f func(s1 string)) *mPredicateMockEquatesWithConstant {
	if mmEquatesWithConstant.mock.inspectFuncEquatesWithConstant != nil {
		mmEquatesWithConstant.mock.t.Fatalf("Inspect function is already set for PredicateMock.EquatesWithConstant")
	}

	mmEquatesWithConstant.mock.inspectFuncEquatesWithConstant = f

	return mmEquatesWithConstant
}

// Return sets up results that will be returned by Predicate.EquatesWithConstant
func (mmEquatesWithConstant *mPredicateMockEquatesWithConstant) Return(c1 mm_scan.Constant, b1 bool) *PredicateMock {
	if mmEquatesWithConstant.mock.funcEquatesWithConstant != nil {
		mmEquatesWithConstant.mock.t.Fatalf("PredicateMock.EquatesWithConstant mock is already set by Set")
	}

	if mmEquatesWithConstant.defaultExpectation == nil {
		mmEquatesWithConstant.defaultExpectation = &PredicateMockEquatesWithConstantExpectation{mock: mmEquatesWithConstant.mock}
	}
	mmEquatesWithConstant.defaultExpectation.results = &PredicateMockEquatesWithConstantResults{c1, b1}
	return mmEquatesWithConstant.mock
}

// Set uses given function f to mock the Predicate.EquatesWithConstant method
func (mmEquatesWithConstant *mPredicateMockEquatesWithConstant) Set(f func(s1 string) (c1 mm_scan.Constant, b1 bool)) *PredicateMock {
	if mmEquatesWithConstant.defaultExpectation != nil {
		mmEquatesWithConstant.mock.t.Fatalf("Default expectation is already set for the Predicate.EquatesWithConstant method")
	}

	if len(mmEquatesWithConstant.expectations) > 0 {
		mmEquatesWithConstant.mock.t.Fatalf("Some expectations are already set for the Predicate.EquatesWithConstant method")
	}

	mmEquatesWithConstant.mock.funcEquatesWithConstant = f
	return mmEquatesWithConstant.mock
}

// When sets expectation for the Predicate.EquatesWithConstant which will trigger the result defined by the following
// Then helper
func (mmEquatesWithConstant *mPredicateMockEquatesWithConstant) When(s1 string) *PredicateMockEquatesWithConstantExpectation {
	if mmEquatesWithConstant.mock.funcEquatesWithConstant != nil {
		mmEquatesWithConstant.mock.t.Fatalf("PredicateMock.EquatesWithConstant mock is already set by Set")
	}

	expectation := &PredicateMockEquatesWithConstantExpectation{
		mock:   mmEquatesWithConstant.mock,
		params: &PredicateMockEquatesWithConstantParams{s1},
	}
	mmEquatesWithConstant.expectations = append(mmEquatesWithConstant.expectations, expectation)
	return expectation
}

// Then sets up Predicate.EquatesWithConstant return parameters for the expectation previously defined by the When method
func (e *PredicateMockEquatesWithConstantExpectation) Then(c1 mm_scan.Constant, b1 bool) *PredicateMock {
	e.results = &PredicateMockEquatesWithConstantResults{c1, b1}
	return e.mock
}

// Times sets number of times Predicate.EquatesWithConstant should be invoked
func (mmEquatesWithConstant *mPredicateMockEquatesWithConstant) Times(n uint64) *mPredicateMockEquatesWithConstant {
	if n == 0 {
		mmEquatesWithConstant.mock.t.Fatalf("Times of PredicateMock.EquatesWithConstant mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEquatesWithConstant.expectedInvocations, n)
	return mmEquatesWithConstant
}

func (mmEquatesWithConstant *mPredicateMockEquatesWithConstant) invocationsDone() bool {
	if len(mmEquatesWithConstant.expectations) == 0 && mmEquatesWithConstant.defaultExpectation == nil && mmEquatesWithConstant.mock.funcEquatesWithConstant == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEquatesWithConstant.mock.afterEquatesWithConstantCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEquatesWithConstant.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// EquatesWithConstant implements scan.Predicate
func (mmEquatesWithConstant *PredicateMock) EquatesWithConstant(s1 string) (c1 mm_scan.Constant, b1 bool) {
	mm_atomic.AddUint64(&mmEquatesWithConstant.beforeEquatesWithConstantCounter, 1)
	defer mm_atomic.AddUint64(&mmEquatesWithConstant.afterEquatesWithConstantCounter, 1)

	if mmEquatesWithConstant.inspectFuncEquatesWithConstant != nil {
		mmEquatesWithConstant.inspectFuncEquatesWithConstant(s1)
	}

	mm_params := PredicateMockEquatesWithConstantParams{s1}

	// Record call args
	mmEquatesWithConstant.EquatesWithConstantMock.mutex.Lock()
	mmEquatesWithConstant.EquatesWithConstantMock.callArgs = append(mmEquatesWithConstant.EquatesWithConstantMock.callArgs, &mm_params)
	mmEquatesWithConstant.EquatesWithConstantMock.mutex.Unlock()

	for _, e := range mmEquatesWithConstant.EquatesWithConstantMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c1, e.results.b1
		}
	}

	if mmEquatesWithConstant.EquatesWithConstantMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEquatesWithConstant.EquatesWithConstantMock.defaultExpectation.Counter, 1)
		mm_want := mmEquatesWithConstant.EquatesWithConstantMock.defaultExpectation.params
		mm_want_ptrs := mmEquatesWithConstant.EquatesWithConstantMock.defaultExpectation.paramPtrs

		mm_got := PredicateMockEquatesWithConstantParams{s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmEquatesWithConstant.t.Errorf("PredicateMock.EquatesWithConstant got unexpected parameter s1, want: %#v, got: %#v%s\n", *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEquatesWithConstant.t.Errorf("PredicateMock.EquatesWithConstant got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEquatesWithConstant.EquatesWithConstantMock.defaultExpectation.results
		if mm_results == nil {
			mmEquatesWithConstant.t.Fatal("No results are set for the PredicateMock.EquatesWithConstant")
		}
		return (*mm_results).c1, (*mm_results).b1
	}
	if mmEquatesWithConstant.funcEquatesWithConstant != nil {
		return mmEquatesWithConstant.funcEquatesWithConstant(s1)
	}
	mmEquatesWithConstant.t.Fatalf("Unexpected call to PredicateMock.EquatesWithConstant. %v", s1)
	return
}

// EquatesWithConstantAfterCounter returns a count of finished PredicateMock.EquatesWithConstant invocations
func (mmEquatesWithConstant *PredicateMock) EquatesWithConstantAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquatesWithConstant.afterEquatesWithConstantCounter)
}

// EquatesWithConstantBeforeCounter returns a count of PredicateMock.EquatesWithConstant invocations
func (mmEquatesWithConstant *PredicateMock) EquatesWithConstantBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquatesWithConstant.beforeEquatesWithConstantCounter)
}

// Calls returns a list of arguments used in each call to PredicateMock.EquatesWithConstant.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEquatesWithConstant *mPredicateMockEquatesWithConstant) Calls() []*PredicateMockEquatesWithConstantParams {
	mmEquatesWithConstant.mutex.RLock()

	argCopy := make([]*PredicateMockEquatesWithConstantParams, len(mmEquatesWithConstant.callArgs))
	copy(argCopy, mmEquatesWithConstant.callArgs)

	mmEquatesWithConstant.mutex.RUnlock()

	return argCopy
}

// MinimockEquatesWithConstantDone returns true if the count of the EquatesWithConstant invocations corresponds
// the number of defined expectations
func (m *PredicateMock) MinimockEquatesWithConstantDone() bool {
	if m.EquatesWithConstantMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EquatesWithConstantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EquatesWithConstantMock.invocationsDone()
}

// MinimockEquatesWithConstantInspect logs each unmet expectation
func (m *PredicateMock) MinimockEquatesWithConstantInspect() {
	for _, e := range m.EquatesWithConstantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PredicateMock.EquatesWithConstant with params: %#v", *e.params)
		}
	}

	afterEquatesWithConstantCounter := mm_atomic.LoadUint64(&m.afterEquatesWithConstantCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EquatesWithConstantMock.defaultExpectation != nil && afterEquatesWithConstantCounter < 1 {
		if m.EquatesWithConstantMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PredicateMock.EquatesWithConstant")
		} else {
			m.t.Errorf("Expected call to PredicateMock.EquatesWithConstant with params: %#v", *m.EquatesWithConstantMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquatesWithConstant != nil && afterEquatesWithConstantCounter < 1 {
		m.t.Error("Expected call to PredicateMock.EquatesWithConstant")
	}

	if !m.EquatesWithConstantMock.invocationsDone() && afterEquatesWithConstantCounter > 0 {
		m.t.Errorf("Expected %d calls to PredicateMock.EquatesWithConstant but found %d calls",
			mm_atomic.LoadUint64(&m.EquatesWithConstantMock.expectedInvocations), afterEquatesWithConstantCounter)
	}
}

type mPredicateMockEquatesWithField struct {
	optional           bool
	mock               *PredicateMock
	defaultExpectation *PredicateMockEquatesWithFieldExpectation
	expectations       []*PredicateMockEquatesWithFieldExpectation

	callArgs []*PredicateMockEquatesWithFieldParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// PredicateMockEquatesWithFieldExpectation specifies expectation struct of the Predicate.EquatesWithField
type PredicateMockEquatesWithFieldExpectation struct {
	mock      *PredicateMock
	params    *PredicateMockEquatesWithFieldParams
	paramPtrs *PredicateMockEquatesWithFieldParamPtrs
	results   *PredicateMockEquatesWithFieldResults
	Counter   uint64
}

// PredicateMockEquatesWithFieldParams contains parameters of the Predicate.EquatesWithField
type PredicateMockEquatesWithFieldParams struct {
	s1 string
}

// PredicateMockEquatesWithFieldParamPtrs contains pointers to parameters of the Predicate.EquatesWithField
type PredicateMockEquatesWithFieldParamPtrs struct {
	s1 *string
}

// PredicateMockEquatesWithFieldResults contains results of the Predicate.EquatesWithField
type PredicateMockEquatesWithFieldResults struct {
	s2 string
	b1 bool
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEquatesWithField *mPredicateMockEquatesWithField) Optional() *mPredicateMockEquatesWithField {
	mmEquatesWithField.optional = true
	return mmEquatesWithField
}

// Expect sets up expected params for Predicate.EquatesWithField
func (mmEquatesWithField *mPredicateMockEquatesWithField) Expect(s1 string) *mPredicateMockEquatesWithField {
	if mmEquatesWithField.mock.funcEquatesWithField != nil {
		mmEquatesWithField.mock.t.Fatalf("PredicateMock.EquatesWithField mock is already set by Set")
	}

	if mmEquatesWithField.defaultExpectation == nil {
		mmEquatesWithField.defaultExpectation = &PredicateMockEquatesWithFieldExpectation{}
	}

	if mmEquatesWithField.defaultExpectation.paramPtrs != nil {
		mmEquatesWithField.mock.t.Fatalf("PredicateMock.EquatesWithField mock is already set by ExpectParams functions")
	}

	mmEquatesWithField.defaultExpectation.params = &PredicateMockEquatesWithFieldParams{s1}
	for _, e := range mmEquatesWithField.expectations {
		if minimock.Equal(e.params, mmEquatesWithField.defaultExpectation.params) {
			mmEquatesWithField.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEquatesWithField.defaultExpectation.params)
		}
	}

	return mmEquatesWithField
}

// ExpectS1Param1 sets up expected param s1 for Predicate.EquatesWithField
func (mmEquatesWithField *mPredicateMockEquatesWithField) ExpectS1Param1(s1 string) *mPredicateMockEquatesWithField {
	if mmEquatesWithField.mock.funcEquatesWithField != nil {
		mmEquatesWithField.mock.t.Fatalf("PredicateMock.EquatesWithField mock is already set by Set")
	}

	if mmEquatesWithField.defaultExpectation == nil {
		mmEquatesWithField.defaultExpectation = &PredicateMockEquatesWithFieldExpectation{}
	}

	if mmEquatesWithField.defaultExpectation.params != nil {
		mmEquatesWithField.mock.t.Fatalf("PredicateMock.EquatesWithField mock is already set by Expect")
	}

	if mmEquatesWithField.defaultExpectation.paramPtrs == nil {
		mmEquatesWithField.defaultExpectation.paramPtrs = &PredicateMockEquatesWithFieldParamPtrs{}
	}
	mmEquatesWithField.defaultExpectation.paramPtrs.s1 = &s1

	return mmEquatesWithField
}

// Inspect accepts an inspector function that has same arguments as the Predicate.EquatesWithField
func (mmEquatesWithField *mPredicateMockEquatesWithField) Inspect(f func(s1 string)) *mPredicateMockEquatesWithField {
	if mmEquatesWithField.mock.inspectFuncEquatesWithField != nil {
		mmEquatesWithField.mock.t.Fatalf("Inspect function is already set for PredicateMock.EquatesWithField")
	}

	mmEquatesWithField.mock.inspectFuncEquatesWithField = f

	return mmEquatesWithField
}

// Return sets up results that will be returned by Predicate.EquatesWithField
func (mmEquatesWithField *mPredicateMockEquatesWithField) Return(s2 string, b1 bool) *PredicateMock {
	if mmEquatesWithField.mock.funcEquatesWithField != nil {
		mmEquatesWithField.mock.t.Fatalf("PredicateMock.EquatesWithField mock is already set by Set")
	}

	if mmEquatesWithField.defaultExpectation == nil {
		mmEquatesWithField.defaultExpectation = &PredicateMockEquatesWithFieldExpectation{mock: mmEquatesWithField.mock}
	}
	mmEquatesWithField.defaultExpectation.results = &PredicateMockEquatesWithFieldResults{s2, b1}
	return mmEquatesWithField.mock
}

// Set uses given function f to mock the Predicate.EquatesWithField method
func (mmEquatesWithField *mPredicateMockEquatesWithField) Set(f func(s1 string) (s2 string, b1 bool)) *PredicateMock {
	if mmEquatesWithField.defaultExpectation != nil {
		mmEquatesWithField.mock.t.Fatalf("Default expectation is already set for the Predicate.EquatesWithField method")
	}

	if len(mmEquatesWithField.expectations) > 0 {
		mmEquatesWithField.mock.t.Fatalf("Some expectations are already set for the Predicate.EquatesWithField method")
	}

	mmEquatesWithField.mock.funcEquatesWithField = f
	return mmEquatesWithField.mock
}

// When sets expectation for the Predicate.EquatesWithField which will trigger the result defined by the following
// Then helper
func (mmEquatesWithField *mPredicateMockEquatesWithField) When(s1 string) *PredicateMockEquatesWithFieldExpectation {
	if mmEquatesWithField.mock.funcEquatesWithField != nil {
		mmEquatesWithField.mock.t.Fatalf("PredicateMock.EquatesWithField mock is already set by Set")
	}

	expectation := &PredicateMockEquatesWithFieldExpectation{
		mock:   mmEquatesWithField.mock,
		params: &PredicateMockEquatesWithFieldParams{s1},
	}
	mmEquatesWithField.expectations = append(mmEquatesWithField.expectations, expectation)
	return expectation
}

// Then sets up Predicate.EquatesWithField return parameters for the expectation previously defined by the When method
func (e *PredicateMockEquatesWithFieldExpectation) Then(s2 string, b1 bool) *PredicateMock {
	e.results = &PredicateMockEquatesWithFieldResults{s2, b1}
	return e.mock
}

// Times sets number of times Predicate.EquatesWithField should be invoked
func (mmEquatesWithField *mPredicateMockEquatesWithField) Times(n uint64) *mPredicateMockEquatesWithField {
	if n == 0 {
		mmEquatesWithField.mock.t.Fatalf("Times of PredicateMock.EquatesWithField mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEquatesWithField.expectedInvocations, n)
	return mmEquatesWithField
}

func (mmEquatesWithField *mPredicateMockEquatesWithField) invocationsDone() bool {
	if len(mmEquatesWithField.expectations) == 0 && mmEquatesWithField.defaultExpectation == nil && mmEquatesWithField.mock.funcEquatesWithField == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEquatesWithField.mock.afterEquatesWithFieldCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEquatesWithField.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// EquatesWithField implements scan.Predicate
func (mmEquatesWithField *PredicateMock) EquatesWithField(s1 string) (s2 string, b1 bool) {
	mm_atomic.AddUint64(&mmEquatesWithField.beforeEquatesWithFieldCounter, 1)
	defer mm_atomic.AddUint64(&mmEquatesWithField.afterEquatesWithFieldCounter, 1)

	if mmEquatesWithField.inspectFuncEquatesWithField != nil {
		mmEquatesWithField.inspectFuncEquatesWithField(s1)
	}

	mm_params := PredicateMockEquatesWithFieldParams{s1}

	// Record call args
	mmEquatesWithField.EquatesWithFieldMock.mutex.Lock()
	mmEquatesWithField.EquatesWithFieldMock.callArgs = append(mmEquatesWithField.EquatesWithFieldMock.callArgs, &mm_params)
	mmEquatesWithField.EquatesWithFieldMock.mutex.Unlock()

	for _, e := range mmEquatesWithField.EquatesWithFieldMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2, e.results.b1
		}
	}

	if mmEquatesWithField.EquatesWithFieldMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEquatesWithField.EquatesWithFieldMock.defaultExpectation.Counter, 1)
		mm_want := mmEquatesWithField.EquatesWithFieldMock.defaultExpectation.params
		mm_want_ptrs := mmEquatesWithField.EquatesWithFieldMock.defaultExpectation.paramPtrs

		mm_got := PredicateMockEquatesWithFieldParams{s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmEquatesWithField.t.Errorf("PredicateMock.EquatesWithField got unexpected parameter s1, want: %#v, got: %#v%s\n", *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEquatesWithField.t.Errorf("PredicateMock.EquatesWithField got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEquatesWithField.EquatesWithFieldMock.defaultExpectation.results
		if mm_results == nil {
			mmEquatesWithField.t.Fatal("No results are set for the PredicateMock.EquatesWithField")
		}
		return (*mm_results).s2, (*mm_results).b1
	}
	if mmEquatesWithField.funcEquatesWithField != nil {
		return mmEquatesWithField.funcEquatesWithField(s1)
	}
	mmEquatesWithField.t.Fatalf("Unexpected call to PredicateMock.EquatesWithField. %v", s1)
	return
}

// EquatesWithFieldAfterCounter returns a count of finished PredicateMock.EquatesWithField invocations
func (mmEquatesWithField *PredicateMock) EquatesWithFieldAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquatesWithField.afterEquatesWithFieldCounter)
}

// EquatesWithFieldBeforeCounter returns a count of PredicateMock.EquatesWithField invocations
func (mmEquatesWithField *PredicateMock) EquatesWithFieldBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquatesWithField.beforeEquatesWithFieldCounter)
}

// Calls returns a list of arguments used in each call to PredicateMock.EquatesWithField.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEquatesWithField *mPredicateMockEquatesWithField) Calls() []*PredicateMockEquatesWithFieldParams {
	mmEquatesWithField.mutex.RLock()

	argCopy := make([]*PredicateMockEquatesWithFieldParams, len(mmEquatesWithField.callArgs))
	copy(argCopy, mmEquatesWithField.callArgs)

	mmEquatesWithField.mutex.RUnlock()

	return argCopy
}

// MinimockEquatesWithFieldDone returns true if the count of the EquatesWithField invocations corresponds
// the number of defined expectations
func (m *PredicateMock) MinimockEquatesWithFieldDone() bool {
	if m.EquatesWithFieldMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EquatesWithFieldMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EquatesWithFieldMock.invocationsDone()
}

// MinimockEquatesWithFieldInspect logs each unmet expectation
func (m *PredicateMock) MinimockEquatesWithFieldInspect() {
	for _, e := range m.EquatesWithFieldMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PredicateMock.EquatesWithField with params: %#v", *e.params)
		}
	}

	afterEquatesWithFieldCounter := mm_atomic.LoadUint64(&m.afterEquatesWithFieldCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EquatesWithFieldMock.defaultExpectation != nil && afterEquatesWithFieldCounter < 1 {
		if m.EquatesWithFieldMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PredicateMock.EquatesWithField")
		} else {
			m.t.Errorf("Expected call to PredicateMock.EquatesWithField with params: %#v", *m.EquatesWithFieldMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquatesWithField != nil && afterEquatesWithFieldCounter < 1 {
		m.t.Error("Expected call to PredicateMock.EquatesWithField")
	}

	if !m.EquatesWithFieldMock.invocationsDone() && afterEquatesWithFieldCounter > 0 {
		m.t.Errorf("Expected %d calls to PredicateMock.EquatesWithField but found %d calls",
			mm_atomic.LoadUint64(&m.EquatesWithFieldMock.expectedInvocations), afterEquatesWithFieldCounter)
	}
}

type mPredicateMockIsSatisfied struct {
	optional           bool
	mock               *PredicateMock
	defaultExpectation *PredicateMockIsSatisfiedExpectation
	expectations       []*PredicateMockIsSatisfiedExpectation

	callArgs []*PredicateMockIsSatisfiedParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// PredicateMockIsSatisfiedExpectation specifies expectation struct of the Predicate.IsSatisfied
type PredicateMockIsSatisfiedExpectation struct {
	mock      *PredicateMock
	params    *PredicateMockIsSatisfiedParams
	paramPtrs *PredicateMockIsSatisfiedParamPtrs
	results   *PredicateMockIsSatisfiedResults
	Counter   uint64
}

// PredicateMockIsSatisfiedParams contains parameters of the Predicate.IsSatisfied
type PredicateMockIsSatisfiedParams struct {
	s1 mm_scan.Scan
}

// PredicateMockIsSatisfiedParamPtrs contains pointers to parameters of the Predicate.IsSatisfied
type PredicateMockIsSatisfiedParamPtrs struct {
	s1 *mm_scan.Scan
}

// PredicateMockIsSatisfiedResults contains results of the Predicate.IsSatisfied
type PredicateMockIsSatisfiedResults struct {
	b1  bool
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsSatisfied *mPredicateMockIsSatisfied) Optional() *mPredicateMockIsSatisfied {
	mmIsSatisfied.optional = true
	return mmIsSatisfied
}

// Expect sets up expected params for Predicate.IsSatisfied
func (mmIsSatisfied *mPredicateMockIsSatisfied) Expect(s1 mm_scan.Scan) *mPredicateMockIsSatisfied {
	if mmIsSatisfied.mock.funcIsSatisfied != nil {
		mmIsSatisfied.mock.t.Fatalf("PredicateMock.IsSatisfied mock is already set by Set")
	}

	if mmIsSatisfied.defaultExpectation == nil {
		mmIsSatisfied.defaultExpectation = &PredicateMockIsSatisfiedExpectation{}
	}

	if mmIsSatisfied.defaultExpectation.paramPtrs != nil {
		mmIsSatisfied.mock.t.Fatalf("PredicateMock.IsSatisfied mock is already set by ExpectParams functions")
	}

	mmIsSatisfied.defaultExpectation.params = &PredicateMockIsSatisfiedParams{s1}
	for _, e := range mmIsSatisfied.expectations {
		if minimock.Equal(e.params, mmIsSatisfied.defaultExpectation.params) {
			mmIsSatisfied.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsSatisfied.defaultExpectation.params)
		}
	}

	return mmIsSatisfied
}

// ExpectS1Param1 sets up expected param s1 for Predicate.IsSatisfied
func (mmIsSatisfied *mPredicateMockIsSatisfied) ExpectS1Param1(s1 mm_scan.Scan) *mPredicateMockIsSatisfied {
	if mmIsSatisfied.mock.funcIsSatisfied != nil {
		mmIsSatisfied.mock.t.Fatalf("PredicateMock.IsSatisfied mock is already set by Set")
	}

	if mmIsSatisfied.defaultExpectation == nil {
		mmIsSatisfied.defaultExpectation = &PredicateMockIsSatisfiedExpectation{}
	}

	if mmIsSatisfied.defaultExpectation.params != nil {
		mmIsSatisfied.mock.t.Fatalf("PredicateMock.IsSatisfied mock is already set by Expect")
	}

	if mmIsSatisfied.defaultExpectation.paramPtrs == nil {
		mmIsSatisfied.defaultExpectation.paramPtrs = &PredicateMockIsSatisfiedParamPtrs{}
	}
	mmIsSatisfied.defaultExpectation.paramPtrs.s1 = &s1

	return mmIsSatisfied
}

// Inspect accepts an inspector function that has same arguments as the Predicate.IsSatisfied
func (mmIsSatisfied *mPredicateMockIsSatisfied) Inspect(f func(s1 mm_scan.Scan)) *mPredicateMockIsSatisfied {
	if mmIsSatisfied.mock.inspectFuncIsSatisfied != nil {
		mmIsSatisfied.mock.t.Fatalf("Inspect function is already set for PredicateMock.IsSatisfied")
	}

	mmIsSatisfied.mock.inspectFuncIsSatisfied = f

	return mmIsSatisfied
}

// Return sets up results that will be returned by Predicate.IsSatisfied
func (mmIsSatisfied *mPredicateMockIsSatisfied) Return(b1 bool, err error) *PredicateMock {
	if mmIsSatisfied.mock.funcIsSatisfied != nil {
		mmIsSatisfied.mock.t.Fatalf("PredicateMock.IsSatisfied mock is already set by Set")
	}

	if mmIsSatisfied.defaultExpectation == nil {
		mmIsSatisfied.defaultExpectation = &PredicateMockIsSatisfiedExpectation{mock: mmIsSatisfied.mock}
	}
	mmIsSatisfied.defaultExpectation.results = &PredicateMockIsSatisfiedResults{b1, err}
	return mmIsSatisfied.mock
}

// Set uses given function f to mock the Predicate.IsSatisfied method
func (mmIsSatisfied *mPredicateMockIsSatisfied) Set(f func(s1 mm_scan.Scan) (b1 bool, err error)) *PredicateMock {
	if mmIsSatisfied.defaultExpectation != nil {
		mmIsSatisfied.mock.t.Fatalf("Default expectation is already set for the Predicate.IsSatisfied method")
	}

	if len(mmIsSatisfied.expectations) > 0 {
		mmIsSatisfied.mock.t.Fatalf("Some expectations are already set for the Predicate.IsSatisfied method")
	}

	mmIsSatisfied.mock.funcIsSatisfied = f
	return mmIsSatisfied.mock
}

// When sets expectation for the Predicate.IsSatisfied which will trigger the result defined by the following
// Then helper
func (mmIsSatisfied *mPredicateMockIsSatisfied) When(s1 mm_scan.Scan) *PredicateMockIsSatisfiedExpectation {
	if mmIsSatisfied.mock.funcIsSatisfied != nil {
		mmIsSatisfied.mock.t.Fatalf("PredicateMock.IsSatisfied mock is already set by Set")
	}

	expectation := &PredicateMockIsSatisfiedExpectation{
		mock:   mmIsSatisfied.mock,
		params: &PredicateMockIsSatisfiedParams{s1},
	}
	mmIsSatisfied.expectations = append(mmIsSatisfied.expectations, expectation)
	return expectation
}

// Then sets up Predicate.IsSatisfied return parameters for the expectation previously defined by the When method
func (e *PredicateMockIsSatisfiedExpectation) Then(b1 bool, err error) *PredicateMock {
	e.results = &PredicateMockIsSatisfiedResults{b1, err}
	return e.mock
}

// Times sets number of times Predicate.IsSatisfied should be invoked
func (mmIsSatisfied *mPredicateMockIsSatisfied) Times(n uint64) *mPredicateMockIsSatisfied {
	if n == 0 {
		mmIsSatisfied.mock.t.Fatalf("Times of PredicateMock.IsSatisfied mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsSatisfied.expectedInvocations, n)
	return mmIsSatisfied
}

func (mmIsSatisfied *mPredicateMockIsSatisfied) invocationsDone() bool {
	if len(mmIsSatisfied.expectations) == 0 && mmIsSatisfied.defaultExpectation == nil && mmIsSatisfied.mock.funcIsSatisfied == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsSatisfied.mock.afterIsSatisfiedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsSatisfied.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsSatisfied implements scan.Predicate
func (mmIsSatisfied *PredicateMock) IsSatisfied(s1 mm_scan.Scan) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsSatisfied.beforeIsSatisfiedCounter, 1)
	defer mm_atomic.AddUint64(&mmIsSatisfied.afterIsSatisfiedCounter, 1)

	if mmIsSatisfied.inspectFuncIsSatisfied != nil {
		mmIsSatisfied.inspectFuncIsSatisfied(s1)
	}

	mm_params := PredicateMockIsSatisfiedParams{s1}

	// Record call args
	mmIsSatisfied.IsSatisfiedMock.mutex.Lock()
	mmIsSatisfied.IsSatisfiedMock.callArgs = append(mmIsSatisfied.IsSatisfiedMock.callArgs, &mm_params)
	mmIsSatisfied.IsSatisfiedMock.mutex.Unlock()

	for _, e := range mmIsSatisfied.IsSatisfiedMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsSatisfied.IsSatisfiedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsSatisfied.IsSatisfiedMock.defaultExpectation.Counter, 1)
		mm_want := mmIsSatisfied.IsSatisfiedMock.defaultExpectation.params
		mm_want_ptrs := mmIsSatisfied.IsSatisfiedMock.defaultExpectation.paramPtrs

		mm_got := PredicateMockIsSatisfiedParams{s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmIsSatisfied.t.Errorf("PredicateMock.IsSatisfied got unexpected parameter s1, want: %#v, got: %#v%s\n", *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsSatisfied.t.Errorf("PredicateMock.IsSatisfied got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsSatisfied.IsSatisfiedMock.defaultExpectation.results
		if mm_results == nil {
			mmIsSatisfied.t.Fatal("No results are set for the PredicateMock.IsSatisfied")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsSatisfied.funcIsSatisfied != nil {
		return mmIsSatisfied.funcIsSatisfied(s1)
	}
	mmIsSatisfied.t.Fatalf("Unexpected call to PredicateMock.IsSatisfied. %v", s1)
	return
}

// IsSatisfiedAfterCounter returns a count of finished PredicateMock.IsSatisfied invocations
func (mmIsSatisfied *PredicateMock) IsSatisfiedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsSatisfied.afterIsSatisfiedCounter)
}

// IsSatisfiedBeforeCounter returns a count of PredicateMock.IsSatisfied invocations
func (mmIsSatisfied *PredicateMock) IsSatisfiedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsSatisfied.beforeIsSatisfiedCounter)
}

// Calls returns a list of arguments used in each call to PredicateMock.IsSatisfied.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsSatisfied *mPredicateMockIsSatisfied) Calls() []*PredicateMockIsSatisfiedParams {
	mmIsSatisfied.mutex.RLock()

	argCopy := make([]*PredicateMockIsSatisfiedParams, len(mmIsSatisfied.callArgs))
	copy(argCopy, mmIsSatisfied.callArgs)

	mmIsSatisfied.mutex.RUnlock()

	return argCopy
}

// MinimockIsSatisfiedDone returns true if the count of the IsSatisfied invocations corresponds
// the number of defined expectations
func (m *PredicateMock) MinimockIsSatisfiedDone() bool {
	if m.IsSatisfiedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsSatisfiedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsSatisfiedMock.invocationsDone()
}

// MinimockIsSatisfiedInspect logs each unmet expectation
func (m *PredicateMock) MinimockIsSatisfiedInspect() {
	for _, e := range m.IsSatisfiedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PredicateMock.IsSatisfied with params: %#v", *e.params)
		}
	}

	afterIsSatisfiedCounter := mm_atomic.LoadUint64(&m.afterIsSatisfiedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsSatisfiedMock.defaultExpectation != nil && afterIsSatisfiedCounter < 1 {
		if m.IsSatisfiedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PredicateMock.IsSatisfied")
		} else {
			m.t.Errorf("Expected call to PredicateMock.IsSatisfied with params: %#v", *m.IsSatisfiedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsSatisfied != nil && afterIsSatisfiedCounter < 1 {
		m.t.Error("Expected call to PredicateMock.IsSatisfied")
	}

	if !m.IsSatisfiedMock.invocationsDone() && afterIsSatisfiedCounter > 0 {
		m.t.Errorf("Expected %d calls to PredicateMock.IsSatisfied but found %d calls",
			mm_atomic.LoadUint64(&m.IsSatisfiedMock.expectedInvocations), afterIsSatisfiedCounter)
	}
}

type mPredicateMockJoinSubPred struct {
	optional           bool
	mock               *PredicateMock
	defaultExpectation *PredicateMockJoinSubPredExpectation
	expectations       []*PredicateMockJoinSubPredExpectation

	callArgs []*PredicateMockJoinSubPredParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// PredicateMockJoinSubPredExpectation specifies expectation struct of the Predicate.JoinSubPred
type PredicateMockJoinSubPredExpectation struct {
	mock      *PredicateMock
	params    *PredicateMockJoinSubPredParams
	paramPtrs *PredicateMockJoinSubPredParamPtrs
	results   *PredicateMockJoinSubPredResults
	Counter   uint64
}

// PredicateMockJoinSubPredParams contains parameters of the Predicate.JoinSubPred
type PredicateMockJoinSubPredParams struct {
	s1 records.Schema
	s2 records.Schema
}

// PredicateMockJoinSubPredParamPtrs contains pointers to parameters of the Predicate.JoinSubPred
type PredicateMockJoinSubPredParamPtrs struct {
	s1 *records.Schema
	s2 *records.Schema
}

// PredicateMockJoinSubPredResults contains results of the Predicate.JoinSubPred
type PredicateMockJoinSubPredResults struct {
	p1 mm_scan.Predicate
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmJoinSubPred *mPredicateMockJoinSubPred) Optional() *mPredicateMockJoinSubPred {
	mmJoinSubPred.optional = true
	return mmJoinSubPred
}

// Expect sets up expected params for Predicate.JoinSubPred
func (mmJoinSubPred *mPredicateMockJoinSubPred) Expect(s1 records.Schema, s2 records.Schema) *mPredicateMockJoinSubPred {
	if mmJoinSubPred.mock.funcJoinSubPred != nil {
		mmJoinSubPred.mock.t.Fatalf("PredicateMock.JoinSubPred mock is already set by Set")
	}

	if mmJoinSubPred.defaultExpectation == nil {
		mmJoinSubPred.defaultExpectation = &PredicateMockJoinSubPredExpectation{}
	}

	if mmJoinSubPred.defaultExpectation.paramPtrs != nil {
		mmJoinSubPred.mock.t.Fatalf("PredicateMock.JoinSubPred mock is already set by ExpectParams functions")
	}

	mmJoinSubPred.defaultExpectation.params = &PredicateMockJoinSubPredParams{s1, s2}
	for _, e := range mmJoinSubPred.expectations {
		if minimock.Equal(e.params, mmJoinSubPred.defaultExpectation.params) {
			mmJoinSubPred.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmJoinSubPred.defaultExpectation.params)
		}
	}

	return mmJoinSubPred
}

// ExpectS1Param1 sets up expected param s1 for Predicate.JoinSubPred
func (mmJoinSubPred *mPredicateMockJoinSubPred) ExpectS1Param1(s1 records.Schema) *mPredicateMockJoinSubPred {
	if mmJoinSubPred.mock.funcJoinSubPred != nil {
		mmJoinSubPred.mock.t.Fatalf("PredicateMock.JoinSubPred mock is already set by Set")
	}

	if mmJoinSubPred.defaultExpectation == nil {
		mmJoinSubPred.defaultExpectation = &PredicateMockJoinSubPredExpectation{}
	}

	if mmJoinSubPred.defaultExpectation.params != nil {
		mmJoinSubPred.mock.t.Fatalf("PredicateMock.JoinSubPred mock is already set by Expect")
	}

	if mmJoinSubPred.defaultExpectation.paramPtrs == nil {
		mmJoinSubPred.defaultExpectation.paramPtrs = &PredicateMockJoinSubPredParamPtrs{}
	}
	mmJoinSubPred.defaultExpectation.paramPtrs.s1 = &s1

	return mmJoinSubPred
}

// ExpectS2Param2 sets up expected param s2 for Predicate.JoinSubPred
func (mmJoinSubPred *mPredicateMockJoinSubPred) ExpectS2Param2(s2 records.Schema) *mPredicateMockJoinSubPred {
	if mmJoinSubPred.mock.funcJoinSubPred != nil {
		mmJoinSubPred.mock.t.Fatalf("PredicateMock.JoinSubPred mock is already set by Set")
	}

	if mmJoinSubPred.defaultExpectation == nil {
		mmJoinSubPred.defaultExpectation = &PredicateMockJoinSubPredExpectation{}
	}

	if mmJoinSubPred.defaultExpectation.params != nil {
		mmJoinSubPred.mock.t.Fatalf("PredicateMock.JoinSubPred mock is already set by Expect")
	}

	if mmJoinSubPred.defaultExpectation.paramPtrs == nil {
		mmJoinSubPred.defaultExpectation.paramPtrs = &PredicateMockJoinSubPredParamPtrs{}
	}
	mmJoinSubPred.defaultExpectation.paramPtrs.s2 = &s2

	return mmJoinSubPred
}

// Inspect accepts an inspector function that has same arguments as the Predicate.JoinSubPred
func (mmJoinSubPred *mPredicateMockJoinSubPred) Inspect(f func(s1 records.Schema, s2 records.Schema)) *mPredicateMockJoinSubPred {
	if mmJoinSubPred.mock.inspectFuncJoinSubPred != nil {
		mmJoinSubPred.mock.t.Fatalf("Inspect function is already set for PredicateMock.JoinSubPred")
	}

	mmJoinSubPred.mock.inspectFuncJoinSubPred = f

	return mmJoinSubPred
}

// Return sets up results that will be returned by Predicate.JoinSubPred
func (mmJoinSubPred *mPredicateMockJoinSubPred) Return(p1 mm_scan.Predicate) *PredicateMock {
	if mmJoinSubPred.mock.funcJoinSubPred != nil {
		mmJoinSubPred.mock.t.Fatalf("PredicateMock.JoinSubPred mock is already set by Set")
	}

	if mmJoinSubPred.defaultExpectation == nil {
		mmJoinSubPred.defaultExpectation = &PredicateMockJoinSubPredExpectation{mock: mmJoinSubPred.mock}
	}
	mmJoinSubPred.defaultExpectation.results = &PredicateMockJoinSubPredResults{p1}
	return mmJoinSubPred.mock
}

// Set uses given function f to mock the Predicate.JoinSubPred method
func (mmJoinSubPred *mPredicateMockJoinSubPred) Set(f func(s1 records.Schema, s2 records.Schema) (p1 mm_scan.Predicate)) *PredicateMock {
	if mmJoinSubPred.defaultExpectation != nil {
		mmJoinSubPred.mock.t.Fatalf("Default expectation is already set for the Predicate.JoinSubPred method")
	}

	if len(mmJoinSubPred.expectations) > 0 {
		mmJoinSubPred.mock.t.Fatalf("Some expectations are already set for the Predicate.JoinSubPred method")
	}

	mmJoinSubPred.mock.funcJoinSubPred = f
	return mmJoinSubPred.mock
}

// When sets expectation for the Predicate.JoinSubPred which will trigger the result defined by the following
// Then helper
func (mmJoinSubPred *mPredicateMockJoinSubPred) When(s1 records.Schema, s2 records.Schema) *PredicateMockJoinSubPredExpectation {
	if mmJoinSubPred.mock.funcJoinSubPred != nil {
		mmJoinSubPred.mock.t.Fatalf("PredicateMock.JoinSubPred mock is already set by Set")
	}

	expectation := &PredicateMockJoinSubPredExpectation{
		mock:   mmJoinSubPred.mock,
		params: &PredicateMockJoinSubPredParams{s1, s2},
	}
	mmJoinSubPred.expectations = append(mmJoinSubPred.expectations, expectation)
	return expectation
}

// Then sets up Predicate.JoinSubPred return parameters for the expectation previously defined by the When method
func (e *PredicateMockJoinSubPredExpectation) Then(p1 mm_scan.Predicate) *PredicateMock {
	e.results = &PredicateMockJoinSubPredResults{p1}
	return e.mock
}

// Times sets number of times Predicate.JoinSubPred should be invoked
func (mmJoinSubPred *mPredicateMockJoinSubPred) Times(n uint64) *mPredicateMockJoinSubPred {
	if n == 0 {
		mmJoinSubPred.mock.t.Fatalf("Times of PredicateMock.JoinSubPred mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmJoinSubPred.expectedInvocations, n)
	return mmJoinSubPred
}

func (mmJoinSubPred *mPredicateMockJoinSubPred) invocationsDone() bool {
	if len(mmJoinSubPred.expectations) == 0 && mmJoinSubPred.defaultExpectation == nil && mmJoinSubPred.mock.funcJoinSubPred == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmJoinSubPred.mock.afterJoinSubPredCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmJoinSubPred.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// JoinSubPred implements scan.Predicate
func (mmJoinSubPred *PredicateMock) JoinSubPred(s1 records.Schema, s2 records.Schema) (p1 mm_scan.Predicate) {
	mm_atomic.AddUint64(&mmJoinSubPred.beforeJoinSubPredCounter, 1)
	defer mm_atomic.AddUint64(&mmJoinSubPred.afterJoinSubPredCounter, 1)

	if mmJoinSubPred.inspectFuncJoinSubPred != nil {
		mmJoinSubPred.inspectFuncJoinSubPred(s1, s2)
	}

	mm_params := PredicateMockJoinSubPredParams{s1, s2}

	// Record call args
	mmJoinSubPred.JoinSubPredMock.mutex.Lock()
	mmJoinSubPred.JoinSubPredMock.callArgs = append(mmJoinSubPred.JoinSubPredMock.callArgs, &mm_params)
	mmJoinSubPred.JoinSubPredMock.mutex.Unlock()

	for _, e := range mmJoinSubPred.JoinSubPredMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1
		}
	}

	if mmJoinSubPred.JoinSubPredMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmJoinSubPred.JoinSubPredMock.defaultExpectation.Counter, 1)
		mm_want := mmJoinSubPred.JoinSubPredMock.defaultExpectation.params
		mm_want_ptrs := mmJoinSubPred.JoinSubPredMock.defaultExpectation.paramPtrs

		mm_got := PredicateMockJoinSubPredParams{s1, s2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmJoinSubPred.t.Errorf("PredicateMock.JoinSubPred got unexpected parameter s1, want: %#v, got: %#v%s\n", *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

			if mm_want_ptrs.s2 != nil && !minimock.Equal(*mm_want_ptrs.s2, mm_got.s2) {
				mmJoinSubPred.t.Errorf("PredicateMock.JoinSubPred got unexpected parameter s2, want: %#v, got: %#v%s\n", *mm_want_ptrs.s2, mm_got.s2, minimock.Diff(*mm_want_ptrs.s2, mm_got.s2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmJoinSubPred.t.Errorf("PredicateMock.JoinSubPred got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmJoinSubPred.JoinSubPredMock.defaultExpectation.results
		if mm_results == nil {
			mmJoinSubPred.t.Fatal("No results are set for the PredicateMock.JoinSubPred")
		}
		return (*mm_results).p1
	}
	if mmJoinSubPred.funcJoinSubPred != nil {
		return mmJoinSubPred.funcJoinSubPred(s1, s2)
	}
	mmJoinSubPred.t.Fatalf("Unexpected call to PredicateMock.JoinSubPred. %v %v", s1, s2)
	return
}

// JoinSubPredAfterCounter returns a count of finished PredicateMock.JoinSubPred invocations
func (mmJoinSubPred *PredicateMock) JoinSubPredAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJoinSubPred.afterJoinSubPredCounter)
}

// JoinSubPredBeforeCounter returns a count of PredicateMock.JoinSubPred invocations
func (mmJoinSubPred *PredicateMock) JoinSubPredBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJoinSubPred.beforeJoinSubPredCounter)
}

// Calls returns a list of arguments used in each call to PredicateMock.JoinSubPred.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmJoinSubPred *mPredicateMockJoinSubPred) Calls() []*PredicateMockJoinSubPredParams {
	mmJoinSubPred.mutex.RLock()

	argCopy := make([]*PredicateMockJoinSubPredParams, len(mmJoinSubPred.callArgs))
	copy(argCopy, mmJoinSubPred.callArgs)

	mmJoinSubPred.mutex.RUnlock()

	return argCopy
}

// MinimockJoinSubPredDone returns true if the count of the JoinSubPred invocations corresponds
// the number of defined expectations
func (m *PredicateMock) MinimockJoinSubPredDone() bool {
	if m.JoinSubPredMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.JoinSubPredMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.JoinSubPredMock.invocationsDone()
}

// MinimockJoinSubPredInspect logs each unmet expectation
func (m *PredicateMock) MinimockJoinSubPredInspect() {
	for _, e := range m.JoinSubPredMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PredicateMock.JoinSubPred with params: %#v", *e.params)
		}
	}

	afterJoinSubPredCounter := mm_atomic.LoadUint64(&m.afterJoinSubPredCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.JoinSubPredMock.defaultExpectation != nil && afterJoinSubPredCounter < 1 {
		if m.JoinSubPredMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PredicateMock.JoinSubPred")
		} else {
			m.t.Errorf("Expected call to PredicateMock.JoinSubPred with params: %#v", *m.JoinSubPredMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJoinSubPred != nil && afterJoinSubPredCounter < 1 {
		m.t.Error("Expected call to PredicateMock.JoinSubPred")
	}

	if !m.JoinSubPredMock.invocationsDone() && afterJoinSubPredCounter > 0 {
		m.t.Errorf("Expected %d calls to PredicateMock.JoinSubPred but found %d calls",
			mm_atomic.LoadUint64(&m.JoinSubPredMock.expectedInvocations), afterJoinSubPredCounter)
	}
}

type mPredicateMockReductionFactor struct {
	optional           bool
	mock               *PredicateMock
	defaultExpectation *PredicateMockReductionFactorExpectation
	expectations       []*PredicateMockReductionFactorExpectation

	callArgs []*PredicateMockReductionFactorParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// PredicateMockReductionFactorExpectation specifies expectation struct of the Predicate.ReductionFactor
type PredicateMockReductionFactorExpectation struct {
	mock      *PredicateMock
	params    *PredicateMockReductionFactorParams
	paramPtrs *PredicateMockReductionFactorParamPtrs
	results   *PredicateMockReductionFactorResults
	Counter   uint64
}

// PredicateMockReductionFactorParams contains parameters of the Predicate.ReductionFactor
type PredicateMockReductionFactorParams struct {
	p1 mm_scan.Plan
}

// PredicateMockReductionFactorParamPtrs contains pointers to parameters of the Predicate.ReductionFactor
type PredicateMockReductionFactorParamPtrs struct {
	p1 *mm_scan.Plan
}

// PredicateMockReductionFactorResults contains results of the Predicate.ReductionFactor
type PredicateMockReductionFactorResults struct {
	i1 int64
	b1 bool
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReductionFactor *mPredicateMockReductionFactor) Optional() *mPredicateMockReductionFactor {
	mmReductionFactor.optional = true
	return mmReductionFactor
}

// Expect sets up expected params for Predicate.ReductionFactor
func (mmReductionFactor *mPredicateMockReductionFactor) Expect(p1 mm_scan.Plan) *mPredicateMockReductionFactor {
	if mmReductionFactor.mock.funcReductionFactor != nil {
		mmReductionFactor.mock.t.Fatalf("PredicateMock.ReductionFactor mock is already set by Set")
	}

	if mmReductionFactor.defaultExpectation == nil {
		mmReductionFactor.defaultExpectation = &PredicateMockReductionFactorExpectation{}
	}

	if mmReductionFactor.defaultExpectation.paramPtrs != nil {
		mmReductionFactor.mock.t.Fatalf("PredicateMock.ReductionFactor mock is already set by ExpectParams functions")
	}

	mmReductionFactor.defaultExpectation.params = &PredicateMockReductionFactorParams{p1}
	for _, e := range mmReductionFactor.expectations {
		if minimock.Equal(e.params, mmReductionFactor.defaultExpectation.params) {
			mmReductionFactor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReductionFactor.defaultExpectation.params)
		}
	}

	return mmReductionFactor
}

// ExpectP1Param1 sets up expected param p1 for Predicate.ReductionFactor
func (mmReductionFactor *mPredicateMockReductionFactor) ExpectP1Param1(p1 mm_scan.Plan) *mPredicateMockReductionFactor {
	if mmReductionFactor.mock.funcReductionFactor != nil {
		mmReductionFactor.mock.t.Fatalf("PredicateMock.ReductionFactor mock is already set by Set")
	}

	if mmReductionFactor.defaultExpectation == nil {
		mmReductionFactor.defaultExpectation = &PredicateMockReductionFactorExpectation{}
	}

	if mmReductionFactor.defaultExpectation.params != nil {
		mmReductionFactor.mock.t.Fatalf("PredicateMock.ReductionFactor mock is already set by Expect")
	}

	if mmReductionFactor.defaultExpectation.paramPtrs == nil {
		mmReductionFactor.defaultExpectation.paramPtrs = &PredicateMockReductionFactorParamPtrs{}
	}
	mmReductionFactor.defaultExpectation.paramPtrs.p1 = &p1

	return mmReductionFactor
}

// Inspect accepts an inspector function that has same arguments as the Predicate.ReductionFactor
func (mmReductionFactor *mPredicateMockReductionFactor) Inspect(f func(p1 mm_scan.Plan)) *mPredicateMockReductionFactor {
	if mmReductionFactor.mock.inspectFuncReductionFactor != nil {
		mmReductionFactor.mock.t.Fatalf("Inspect function is already set for PredicateMock.ReductionFactor")
	}

	mmReductionFactor.mock.inspectFuncReductionFactor = f

	return mmReductionFactor
}

// Return sets up results that will be returned by Predicate.ReductionFactor
func (mmReductionFactor *mPredicateMockReductionFactor) Return(i1 int64, b1 bool) *PredicateMock {
	if mmReductionFactor.mock.funcReductionFactor != nil {
		mmReductionFactor.mock.t.Fatalf("PredicateMock.ReductionFactor mock is already set by Set")
	}

	if mmReductionFactor.defaultExpectation == nil {
		mmReductionFactor.defaultExpectation = &PredicateMockReductionFactorExpectation{mock: mmReductionFactor.mock}
	}
	mmReductionFactor.defaultExpectation.results = &PredicateMockReductionFactorResults{i1, b1}
	return mmReductionFactor.mock
}

// Set uses given function f to mock the Predicate.ReductionFactor method
func (mmReductionFactor *mPredicateMockReductionFactor) Set(f func(p1 mm_scan.Plan) (i1 int64, b1 bool)) *PredicateMock {
	if mmReductionFactor.defaultExpectation != nil {
		mmReductionFactor.mock.t.Fatalf("Default expectation is already set for the Predicate.ReductionFactor method")
	}

	if len(mmReductionFactor.expectations) > 0 {
		mmReductionFactor.mock.t.Fatalf("Some expectations are already set for the Predicate.ReductionFactor method")
	}

	mmReductionFactor.mock.funcReductionFactor = f
	return mmReductionFactor.mock
}

// When sets expectation for the Predicate.ReductionFactor which will trigger the result defined by the following
// Then helper
func (mmReductionFactor *mPredicateMockReductionFactor) When(p1 mm_scan.Plan) *PredicateMockReductionFactorExpectation {
	if mmReductionFactor.mock.funcReductionFactor != nil {
		mmReductionFactor.mock.t.Fatalf("PredicateMock.ReductionFactor mock is already set by Set")
	}

	expectation := &PredicateMockReductionFactorExpectation{
		mock:   mmReductionFactor.mock,
		params: &PredicateMockReductionFactorParams{p1},
	}
	mmReductionFactor.expectations = append(mmReductionFactor.expectations, expectation)
	return expectation
}

// Then sets up Predicate.ReductionFactor return parameters for the expectation previously defined by the When method
func (e *PredicateMockReductionFactorExpectation) Then(i1 int64, b1 bool) *PredicateMock {
	e.results = &PredicateMockReductionFactorResults{i1, b1}
	return e.mock
}

// Times sets number of times Predicate.ReductionFactor should be invoked
func (mmReductionFactor *mPredicateMockReductionFactor) Times(n uint64) *mPredicateMockReductionFactor {
	if n == 0 {
		mmReductionFactor.mock.t.Fatalf("Times of PredicateMock.ReductionFactor mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReductionFactor.expectedInvocations, n)
	return mmReductionFactor
}

func (mmReductionFactor *mPredicateMockReductionFactor) invocationsDone() bool {
	if len(mmReductionFactor.expectations) == 0 && mmReductionFactor.defaultExpectation == nil && mmReductionFactor.mock.funcReductionFactor == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReductionFactor.mock.afterReductionFactorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReductionFactor.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReductionFactor implements scan.Predicate
func (mmReductionFactor *PredicateMock) ReductionFactor(p1 mm_scan.Plan) (i1 int64, b1 bool) {
	mm_atomic.AddUint64(&mmReductionFactor.beforeReductionFactorCounter, 1)
	defer mm_atomic.AddUint64(&mmReductionFactor.afterReductionFactorCounter, 1)

	if mmReductionFactor.inspectFuncReductionFactor != nil {
		mmReductionFactor.inspectFuncReductionFactor(p1)
	}

	mm_params := PredicateMockReductionFactorParams{p1}

	// Record call args
	mmReductionFactor.ReductionFactorMock.mutex.Lock()
	mmReductionFactor.ReductionFactorMock.callArgs = append(mmReductionFactor.ReductionFactorMock.callArgs, &mm_params)
	mmReductionFactor.ReductionFactorMock.mutex.Unlock()

	for _, e := range mmReductionFactor.ReductionFactorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.b1
		}
	}

	if mmReductionFactor.ReductionFactorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReductionFactor.ReductionFactorMock.defaultExpectation.Counter, 1)
		mm_want := mmReductionFactor.ReductionFactorMock.defaultExpectation.params
		mm_want_ptrs := mmReductionFactor.ReductionFactorMock.defaultExpectation.paramPtrs

		mm_got := PredicateMockReductionFactorParams{p1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.p1 != nil && !minimock.Equal(*mm_want_ptrs.p1, mm_got.p1) {
				mmReductionFactor.t.Errorf("PredicateMock.ReductionFactor got unexpected parameter p1, want: %#v, got: %#v%s\n", *mm_want_ptrs.p1, mm_got.p1, minimock.Diff(*mm_want_ptrs.p1, mm_got.p1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReductionFactor.t.Errorf("PredicateMock.ReductionFactor got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReductionFactor.ReductionFactorMock.defaultExpectation.results
		if mm_results == nil {
			mmReductionFactor.t.Fatal("No results are set for the PredicateMock.ReductionFactor")
		}
		return (*mm_results).i1, (*mm_results).b1
	}
	if mmReductionFactor.funcReductionFactor != nil {
		return mmReductionFactor.funcReductionFactor(p1)
	}
	mmReductionFactor.t.Fatalf("Unexpected call to PredicateMock.ReductionFactor. %v", p1)
	return
}

// ReductionFactorAfterCounter returns a count of finished PredicateMock.ReductionFactor invocations
func (mmReductionFactor *PredicateMock) ReductionFactorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReductionFactor.afterReductionFactorCounter)
}

// ReductionFactorBeforeCounter returns a count of PredicateMock.ReductionFactor invocations
func (mmReductionFactor *PredicateMock) ReductionFactorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReductionFactor.beforeReductionFactorCounter)
}

// Calls returns a list of arguments used in each call to PredicateMock.ReductionFactor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReductionFactor *mPredicateMockReductionFactor) Calls() []*PredicateMockReductionFactorParams {
	mmReductionFactor.mutex.RLock()

	argCopy := make([]*PredicateMockReductionFactorParams, len(mmReductionFactor.callArgs))
	copy(argCopy, mmReductionFactor.callArgs)

	mmReductionFactor.mutex.RUnlock()

	return argCopy
}

// MinimockReductionFactorDone returns true if the count of the ReductionFactor invocations corresponds
// the number of defined expectations
func (m *PredicateMock) MinimockReductionFactorDone() bool {
	if m.ReductionFactorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReductionFactorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReductionFactorMock.invocationsDone()
}

// MinimockReductionFactorInspect logs each unmet expectation
func (m *PredicateMock) MinimockReductionFactorInspect() {
	for _, e := range m.ReductionFactorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PredicateMock.ReductionFactor with params: %#v", *e.params)
		}
	}

	afterReductionFactorCounter := mm_atomic.LoadUint64(&m.afterReductionFactorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReductionFactorMock.defaultExpectation != nil && afterReductionFactorCounter < 1 {
		if m.ReductionFactorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PredicateMock.ReductionFactor")
		} else {
			m.t.Errorf("Expected call to PredicateMock.ReductionFactor with params: %#v", *m.ReductionFactorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReductionFactor != nil && afterReductionFactorCounter < 1 {
		m.t.Error("Expected call to PredicateMock.ReductionFactor")
	}

	if !m.ReductionFactorMock.invocationsDone() && afterReductionFactorCounter > 0 {
		m.t.Errorf("Expected %d calls to PredicateMock.ReductionFactor but found %d calls",
			mm_atomic.LoadUint64(&m.ReductionFactorMock.expectedInvocations), afterReductionFactorCounter)
	}
}

type mPredicateMockSelectSubPred struct {
	optional           bool
	mock               *PredicateMock
	defaultExpectation *PredicateMockSelectSubPredExpectation
	expectations       []*PredicateMockSelectSubPredExpectation

	callArgs []*PredicateMockSelectSubPredParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// PredicateMockSelectSubPredExpectation specifies expectation struct of the Predicate.SelectSubPred
type PredicateMockSelectSubPredExpectation struct {
	mock      *PredicateMock
	params    *PredicateMockSelectSubPredParams
	paramPtrs *PredicateMockSelectSubPredParamPtrs
	results   *PredicateMockSelectSubPredResults
	Counter   uint64
}

// PredicateMockSelectSubPredParams contains parameters of the Predicate.SelectSubPred
type PredicateMockSelectSubPredParams struct {
	s1 records.Schema
}

// PredicateMockSelectSubPredParamPtrs contains pointers to parameters of the Predicate.SelectSubPred
type PredicateMockSelectSubPredParamPtrs struct {
	s1 *records.Schema
}

// PredicateMockSelectSubPredResults contains results of the Predicate.SelectSubPred
type PredicateMockSelectSubPredResults struct {
	p1 mm_scan.Predicate
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectSubPred *mPredicateMockSelectSubPred) Optional() *mPredicateMockSelectSubPred {
	mmSelectSubPred.optional = true
	return mmSelectSubPred
}

// Expect sets up expected params for Predicate.SelectSubPred
func (mmSelectSubPred *mPredicateMockSelectSubPred) Expect(s1 records.Schema) *mPredicateMockSelectSubPred {
	if mmSelectSubPred.mock.funcSelectSubPred != nil {
		mmSelectSubPred.mock.t.Fatalf("PredicateMock.SelectSubPred mock is already set by Set")
	}

	if mmSelectSubPred.defaultExpectation == nil {
		mmSelectSubPred.defaultExpectation = &PredicateMockSelectSubPredExpectation{}
	}

	if mmSelectSubPred.defaultExpectation.paramPtrs != nil {
		mmSelectSubPred.mock.t.Fatalf("PredicateMock.SelectSubPred mock is already set by ExpectParams functions")
	}

	mmSelectSubPred.defaultExpectation.params = &PredicateMockSelectSubPredParams{s1}
	for _, e := range mmSelectSubPred.expectations {
		if minimock.Equal(e.params, mmSelectSubPred.defaultExpectation.params) {
			mmSelectSubPred.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectSubPred.defaultExpectation.params)
		}
	}

	return mmSelectSubPred
}

// ExpectS1Param1 sets up expected param s1 for Predicate.SelectSubPred
func (mmSelectSubPred *mPredicateMockSelectSubPred) ExpectS1Param1(s1 records.Schema) *mPredicateMockSelectSubPred {
	if mmSelectSubPred.mock.funcSelectSubPred != nil {
		mmSelectSubPred.mock.t.Fatalf("PredicateMock.SelectSubPred mock is already set by Set")
	}

	if mmSelectSubPred.defaultExpectation == nil {
		mmSelectSubPred.defaultExpectation = &PredicateMockSelectSubPredExpectation{}
	}

	if mmSelectSubPred.defaultExpectation.params != nil {
		mmSelectSubPred.mock.t.Fatalf("PredicateMock.SelectSubPred mock is already set by Expect")
	}

	if mmSelectSubPred.defaultExpectation.paramPtrs == nil {
		mmSelectSubPred.defaultExpectation.paramPtrs = &PredicateMockSelectSubPredParamPtrs{}
	}
	mmSelectSubPred.defaultExpectation.paramPtrs.s1 = &s1

	return mmSelectSubPred
}

// Inspect accepts an inspector function that has same arguments as the Predicate.SelectSubPred
func (mmSelectSubPred *mPredicateMockSelectSubPred) Inspect(f func(s1 records.Schema)) *mPredicateMockSelectSubPred {
	if mmSelectSubPred.mock.inspectFuncSelectSubPred != nil {
		mmSelectSubPred.mock.t.Fatalf("Inspect function is already set for PredicateMock.SelectSubPred")
	}

	mmSelectSubPred.mock.inspectFuncSelectSubPred = f

	return mmSelectSubPred
}

// Return sets up results that will be returned by Predicate.SelectSubPred
func (mmSelectSubPred *mPredicateMockSelectSubPred) Return(p1 mm_scan.Predicate) *PredicateMock {
	if mmSelectSubPred.mock.funcSelectSubPred != nil {
		mmSelectSubPred.mock.t.Fatalf("PredicateMock.SelectSubPred mock is already set by Set")
	}

	if mmSelectSubPred.defaultExpectation == nil {
		mmSelectSubPred.defaultExpectation = &PredicateMockSelectSubPredExpectation{mock: mmSelectSubPred.mock}
	}
	mmSelectSubPred.defaultExpectation.results = &PredicateMockSelectSubPredResults{p1}
	return mmSelectSubPred.mock
}

// Set uses given function f to mock the Predicate.SelectSubPred method
func (mmSelectSubPred *mPredicateMockSelectSubPred) Set(f func(s1 records.Schema) (p1 mm_scan.Predicate)) *PredicateMock {
	if mmSelectSubPred.defaultExpectation != nil {
		mmSelectSubPred.mock.t.Fatalf("Default expectation is already set for the Predicate.SelectSubPred method")
	}

	if len(mmSelectSubPred.expectations) > 0 {
		mmSelectSubPred.mock.t.Fatalf("Some expectations are already set for the Predicate.SelectSubPred method")
	}

	mmSelectSubPred.mock.funcSelectSubPred = f
	return mmSelectSubPred.mock
}

// When sets expectation for the Predicate.SelectSubPred which will trigger the result defined by the following
// Then helper
func (mmSelectSubPred *mPredicateMockSelectSubPred) When(s1 records.Schema) *PredicateMockSelectSubPredExpectation {
	if mmSelectSubPred.mock.funcSelectSubPred != nil {
		mmSelectSubPred.mock.t.Fatalf("PredicateMock.SelectSubPred mock is already set by Set")
	}

	expectation := &PredicateMockSelectSubPredExpectation{
		mock:   mmSelectSubPred.mock,
		params: &PredicateMockSelectSubPredParams{s1},
	}
	mmSelectSubPred.expectations = append(mmSelectSubPred.expectations, expectation)
	return expectation
}

// Then sets up Predicate.SelectSubPred return parameters for the expectation previously defined by the When method
func (e *PredicateMockSelectSubPredExpectation) Then(p1 mm_scan.Predicate) *PredicateMock {
	e.results = &PredicateMockSelectSubPredResults{p1}
	return e.mock
}

// Times sets number of times Predicate.SelectSubPred should be invoked
func (mmSelectSubPred *mPredicateMockSelectSubPred) Times(n uint64) *mPredicateMockSelectSubPred {
	if n == 0 {
		mmSelectSubPred.mock.t.Fatalf("Times of PredicateMock.SelectSubPred mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectSubPred.expectedInvocations, n)
	return mmSelectSubPred
}

func (mmSelectSubPred *mPredicateMockSelectSubPred) invocationsDone() bool {
	if len(mmSelectSubPred.expectations) == 0 && mmSelectSubPred.defaultExpectation == nil && mmSelectSubPred.mock.funcSelectSubPred == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectSubPred.mock.afterSelectSubPredCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectSubPred.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectSubPred implements scan.Predicate
func (mmSelectSubPred *PredicateMock) SelectSubPred(s1 records.Schema) (p1 mm_scan.Predicate) {
	mm_atomic.AddUint64(&mmSelectSubPred.beforeSelectSubPredCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectSubPred.afterSelectSubPredCounter, 1)

	if mmSelectSubPred.inspectFuncSelectSubPred != nil {
		mmSelectSubPred.inspectFuncSelectSubPred(s1)
	}

	mm_params := PredicateMockSelectSubPredParams{s1}

	// Record call args
	mmSelectSubPred.SelectSubPredMock.mutex.Lock()
	mmSelectSubPred.SelectSubPredMock.callArgs = append(mmSelectSubPred.SelectSubPredMock.callArgs, &mm_params)
	mmSelectSubPred.SelectSubPredMock.mutex.Unlock()

	for _, e := range mmSelectSubPred.SelectSubPredMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1
		}
	}

	if mmSelectSubPred.SelectSubPredMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectSubPred.SelectSubPredMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectSubPred.SelectSubPredMock.defaultExpectation.params
		mm_want_ptrs := mmSelectSubPred.SelectSubPredMock.defaultExpectation.paramPtrs

		mm_got := PredicateMockSelectSubPredParams{s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmSelectSubPred.t.Errorf("PredicateMock.SelectSubPred got unexpected parameter s1, want: %#v, got: %#v%s\n", *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectSubPred.t.Errorf("PredicateMock.SelectSubPred got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectSubPred.SelectSubPredMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectSubPred.t.Fatal("No results are set for the PredicateMock.SelectSubPred")
		}
		return (*mm_results).p1
	}
	if mmSelectSubPred.funcSelectSubPred != nil {
		return mmSelectSubPred.funcSelectSubPred(s1)
	}
	mmSelectSubPred.t.Fatalf("Unexpected call to PredicateMock.SelectSubPred. %v", s1)
	return
}

// SelectSubPredAfterCounter returns a count of finished PredicateMock.SelectSubPred invocations
func (mmSelectSubPred *PredicateMock) SelectSubPredAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectSubPred.afterSelectSubPredCounter)
}

// SelectSubPredBeforeCounter returns a count of PredicateMock.SelectSubPred invocations
func (mmSelectSubPred *PredicateMock) SelectSubPredBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectSubPred.beforeSelectSubPredCounter)
}

// Calls returns a list of arguments used in each call to PredicateMock.SelectSubPred.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectSubPred *mPredicateMockSelectSubPred) Calls() []*PredicateMockSelectSubPredParams {
	mmSelectSubPred.mutex.RLock()

	argCopy := make([]*PredicateMockSelectSubPredParams, len(mmSelectSubPred.callArgs))
	copy(argCopy, mmSelectSubPred.callArgs)

	mmSelectSubPred.mutex.RUnlock()

	return argCopy
}

// MinimockSelectSubPredDone returns true if the count of the SelectSubPred invocations corresponds
// the number of defined expectations
func (m *PredicateMock) MinimockSelectSubPredDone() bool {
	if m.SelectSubPredMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectSubPredMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectSubPredMock.invocationsDone()
}

// MinimockSelectSubPredInspect logs each unmet expectation
func (m *PredicateMock) MinimockSelectSubPredInspect() {
	for _, e := range m.SelectSubPredMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PredicateMock.SelectSubPred with params: %#v", *e.params)
		}
	}

	afterSelectSubPredCounter := mm_atomic.LoadUint64(&m.afterSelectSubPredCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectSubPredMock.defaultExpectation != nil && afterSelectSubPredCounter < 1 {
		if m.SelectSubPredMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PredicateMock.SelectSubPred")
		} else {
			m.t.Errorf("Expected call to PredicateMock.SelectSubPred with params: %#v", *m.SelectSubPredMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectSubPred != nil && afterSelectSubPredCounter < 1 {
		m.t.Error("Expected call to PredicateMock.SelectSubPred")
	}

	if !m.SelectSubPredMock.invocationsDone() && afterSelectSubPredCounter > 0 {
		m.t.Errorf("Expected %d calls to PredicateMock.SelectSubPred but found %d calls",
			mm_atomic.LoadUint64(&m.SelectSubPredMock.expectedInvocations), afterSelectSubPredCounter)
	}
}

type mPredicateMockString struct {
	optional           bool
	mock               *PredicateMock
	defaultExpectation *PredicateMockStringExpectation
	expectations       []*PredicateMockStringExpectation

	expectedInvocations uint64
}

// PredicateMockStringExpectation specifies expectation struct of the Predicate.String
type PredicateMockStringExpectation struct {
	mock *PredicateMock

	results *PredicateMockStringResults
	Counter uint64
}

// PredicateMockStringResults contains results of the Predicate.String
type PredicateMockStringResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmString *mPredicateMockString) Optional() *mPredicateMockString {
	mmString.optional = true
	return mmString
}

// Expect sets up expected params for Predicate.String
func (mmString *mPredicateMockString) Expect() *mPredicateMockString {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("PredicateMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &PredicateMockStringExpectation{}
	}

	return mmString
}

// Inspect accepts an inspector function that has same arguments as the Predicate.String
func (mmString *mPredicateMockString) Inspect(f func()) *mPredicateMockString {
	if mmString.mock.inspectFuncString != nil {
		mmString.mock.t.Fatalf("Inspect function is already set for PredicateMock.String")
	}

	mmString.mock.inspectFuncString = f

	return mmString
}

// Return sets up results that will be returned by Predicate.String
func (mmString *mPredicateMockString) Return(s1 string) *PredicateMock {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("PredicateMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &PredicateMockStringExpectation{mock: mmString.mock}
	}
	mmString.defaultExpectation.results = &PredicateMockStringResults{s1}
	return mmString.mock
}

// Set uses given function f to mock the Predicate.String method
func (mmString *mPredicateMockString) Set(f func() (s1 string)) *PredicateMock {
	if mmString.defaultExpectation != nil {
		mmString.mock.t.Fatalf("Default expectation is already set for the Predicate.String method")
	}

	if len(mmString.expectations) > 0 {
		mmString.mock.t.Fatalf("Some expectations are already set for the Predicate.String method")
	}

	mmString.mock.funcString = f
	return mmString.mock
}

// Times sets number of times Predicate.String should be invoked
func (mmString *mPredicateMockString) Times(n uint64) *mPredicateMockString {
	if n == 0 {
		mmString.mock.t.Fatalf("Times of PredicateMock.String mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmString.expectedInvocations, n)
	return mmString
}

func (mmString *mPredicateMockString) invocationsDone() bool {
	if len(mmString.expectations) == 0 && mmString.defaultExpectation == nil && mmString.mock.funcString == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmString.mock.afterStringCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmString.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// String implements scan.Predicate
func (mmString *PredicateMock) String() (s1 string) {
	mm_atomic.AddUint64(&mmString.beforeStringCounter, 1)
	defer mm_atomic.AddUint64(&mmString.afterStringCounter, 1)

	if mmString.inspectFuncString != nil {
		mmString.inspectFuncString()
	}

	if mmString.StringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmString.StringMock.defaultExpectation.Counter, 1)

		mm_results := mmString.StringMock.defaultExpectation.results
		if mm_results == nil {
			mmString.t.Fatal("No results are set for the PredicateMock.String")
		}
		return (*mm_results).s1
	}
	if mmString.funcString != nil {
		return mmString.funcString()
	}
	mmString.t.Fatalf("Unexpected call to PredicateMock.String.")
	return
}

// StringAfterCounter returns a count of finished PredicateMock.String invocations
func (mmString *PredicateMock) StringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.afterStringCounter)
}

// StringBeforeCounter returns a count of PredicateMock.String invocations
func (mmString *PredicateMock) StringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.beforeStringCounter)
}

// MinimockStringDone returns true if the count of the String invocations corresponds
// the number of defined expectations
func (m *PredicateMock) MinimockStringDone() bool {
	if m.StringMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StringMock.invocationsDone()
}

// MinimockStringInspect logs each unmet expectation
func (m *PredicateMock) MinimockStringInspect() {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to PredicateMock.String")
		}
	}

	afterStringCounter := mm_atomic.LoadUint64(&m.afterStringCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && afterStringCounter < 1 {
		m.t.Error("Expected call to PredicateMock.String")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && afterStringCounter < 1 {
		m.t.Error("Expected call to PredicateMock.String")
	}

	if !m.StringMock.invocationsDone() && afterStringCounter > 0 {
		m.t.Errorf("Expected %d calls to PredicateMock.String but found %d calls",
			mm_atomic.LoadUint64(&m.StringMock.expectedInvocations), afterStringCounter)
	}
}

type mPredicateMockTerms struct {
	optional           bool
	mock               *PredicateMock
	defaultExpectation *PredicateMockTermsExpectation
	expectations       []*PredicateMockTermsExpectation

	expectedInvocations uint64
}

// PredicateMockTermsExpectation specifies expectation struct of the Predicate.Terms
type PredicateMockTermsExpectation struct {
	mock *PredicateMock

	results *PredicateMockTermsResults
	Counter uint64
}

// PredicateMockTermsResults contains results of the Predicate.Terms
type PredicateMockTermsResults struct {
	ta1 []mm_scan.Term
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTerms *mPredicateMockTerms) Optional() *mPredicateMockTerms {
	mmTerms.optional = true
	return mmTerms
}

// Expect sets up expected params for Predicate.Terms
func (mmTerms *mPredicateMockTerms) Expect() *mPredicateMockTerms {
	if mmTerms.mock.funcTerms != nil {
		mmTerms.mock.t.Fatalf("PredicateMock.Terms mock is already set by Set")
	}

	if mmTerms.defaultExpectation == nil {
		mmTerms.defaultExpectation = &PredicateMockTermsExpectation{}
	}

	return mmTerms
}

// Inspect accepts an inspector function that has same arguments as the Predicate.Terms
func (mmTerms *mPredicateMockTerms) Inspect(f func()) *mPredicateMockTerms {
	if mmTerms.mock.inspectFuncTerms != nil {
		mmTerms.mock.t.Fatalf("Inspect function is already set for PredicateMock.Terms")
	}

	mmTerms.mock.inspectFuncTerms = f

	return mmTerms
}

// Return sets up results that will be returned by Predicate.Terms
func (mmTerms *mPredicateMockTerms) Return(ta1 []mm_scan.Term) *PredicateMock {
	if mmTerms.mock.funcTerms != nil {
		mmTerms.mock.t.Fatalf("PredicateMock.Terms mock is already set by Set")
	}

	if mmTerms.defaultExpectation == nil {
		mmTerms.defaultExpectation = &PredicateMockTermsExpectation{mock: mmTerms.mock}
	}
	mmTerms.defaultExpectation.results = &PredicateMockTermsResults{ta1}
	return mmTerms.mock
}

// Set uses given function f to mock the Predicate.Terms method
func (mmTerms *mPredicateMockTerms) Set(f func() (ta1 []mm_scan.Term)) *PredicateMock {
	if mmTerms.defaultExpectation != nil {
		mmTerms.mock.t.Fatalf("Default expectation is already set for the Predicate.Terms method")
	}

	if len(mmTerms.expectations) > 0 {
		mmTerms.mock.t.Fatalf("Some expectations are already set for the Predicate.Terms method")
	}

	mmTerms.mock.funcTerms = f
	return mmTerms.mock
}

// Times sets number of times Predicate.Terms should be invoked
func (mmTerms *mPredicateMockTerms) Times(n uint64) *mPredicateMockTerms {
	if n == 0 {
		mmTerms.mock.t.Fatalf("Times of PredicateMock.Terms mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTerms.expectedInvocations, n)
	return mmTerms
}

func (mmTerms *mPredicateMockTerms) invocationsDone() bool {
	if len(mmTerms.expectations) == 0 && mmTerms.defaultExpectation == nil && mmTerms.mock.funcTerms == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTerms.mock.afterTermsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTerms.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Terms implements scan.Predicate
func (mmTerms *PredicateMock) Terms() (ta1 []mm_scan.Term) {
	mm_atomic.AddUint64(&mmTerms.beforeTermsCounter, 1)
	defer mm_atomic.AddUint64(&mmTerms.afterTermsCounter, 1)

	if mmTerms.inspectFuncTerms != nil {
		mmTerms.inspectFuncTerms()
	}

	if mmTerms.TermsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTerms.TermsMock.defaultExpectation.Counter, 1)

		mm_results := mmTerms.TermsMock.defaultExpectation.results
		if mm_results == nil {
			mmTerms.t.Fatal("No results are set for the PredicateMock.Terms")
		}
		return (*mm_results).ta1
	}
	if mmTerms.funcTerms != nil {
		return mmTerms.funcTerms()
	}
	mmTerms.t.Fatalf("Unexpected call to PredicateMock.Terms.")
	return
}

// TermsAfterCounter returns a count of finished PredicateMock.Terms invocations
func (mmTerms *PredicateMock) TermsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTerms.afterTermsCounter)
}

// TermsBeforeCounter returns a count of PredicateMock.Terms invocations
func (mmTerms *PredicateMock) TermsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTerms.beforeTermsCounter)
}

// MinimockTermsDone returns true if the count of the Terms invocations corresponds
// the number of defined expectations
func (m *PredicateMock) MinimockTermsDone() bool {
	if m.TermsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TermsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TermsMock.invocationsDone()
}

// MinimockTermsInspect logs each unmet expectation
func (m *PredicateMock) MinimockTermsInspect() {
	for _, e := range m.TermsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to PredicateMock.Terms")
		}
	}

	afterTermsCounter := mm_atomic.LoadUint64(&m.afterTermsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TermsMock.defaultExpectation != nil && afterTermsCounter < 1 {
		m.t.Error("Expected call to PredicateMock.Terms")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTerms != nil && afterTermsCounter < 1 {
		m.t.Error("Expected call to PredicateMock.Terms")
	}

	if !m.TermsMock.invocationsDone() && afterTermsCounter > 0 {
		m.t.Errorf("Expected %d calls to PredicateMock.Terms but found %d calls",
			mm_atomic.LoadUint64(&m.TermsMock.expectedInvocations), afterTermsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PredicateMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockConjoinWithInspect()

			m.MinimockEquatesWithConstantInspect()

			m.MinimockEquatesWithFieldInspect()

			m.MinimockIsSatisfiedInspect()

			m.MinimockJoinSubPredInspect()

			m.MinimockReductionFactorInspect()

			m.MinimockSelectSubPredInspect()

			m.MinimockStringInspect()

			m.MinimockTermsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PredicateMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PredicateMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockConjoinWithDone() &&
		m.MinimockEquatesWithConstantDone() &&
		m.MinimockEquatesWithFieldDone() &&
		m.MinimockIsSatisfiedDone() &&
		m.MinimockJoinSubPredDone() &&
		m.MinimockReductionFactorDone() &&
		m.MinimockSelectSubPredDone() &&
		m.MinimockStringDone() &&
		m.MinimockTermsDone()
}
