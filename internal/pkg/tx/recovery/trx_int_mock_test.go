// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package recovery

//go:generate minimock -i github.com/unhandled-exception/sophiadb/internal/pkg/tx/recovery.trxInt -o trx_int_mock_test.go -n TrxIntMock -p recovery

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/unhandled-exception/sophiadb/internal/pkg/types"
)

// TrxIntMock implements trxInt
type TrxIntMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcPin          func(block types.Block) (err error)
	inspectFuncPin   func(block types.Block)
	afterPinCounter  uint64
	beforePinCounter uint64
	PinMock          mTrxIntMockPin

	funcSetInt64          func(block types.Block, offset uint32, value int64, okToLog bool) (err error)
	inspectFuncSetInt64   func(block types.Block, offset uint32, value int64, okToLog bool)
	afterSetInt64Counter  uint64
	beforeSetInt64Counter uint64
	SetInt64Mock          mTrxIntMockSetInt64

	funcSetInt8          func(block types.Block, offset uint32, value int8, okToLog bool) (err error)
	inspectFuncSetInt8   func(block types.Block, offset uint32, value int8, okToLog bool)
	afterSetInt8Counter  uint64
	beforeSetInt8Counter uint64
	SetInt8Mock          mTrxIntMockSetInt8

	funcSetString          func(block types.Block, offset uint32, value string, okToLog bool) (err error)
	inspectFuncSetString   func(block types.Block, offset uint32, value string, okToLog bool)
	afterSetStringCounter  uint64
	beforeSetStringCounter uint64
	SetStringMock          mTrxIntMockSetString

	funcTXNum          func() (t1 types.TRX)
	inspectFuncTXNum   func()
	afterTXNumCounter  uint64
	beforeTXNumCounter uint64
	TXNumMock          mTrxIntMockTXNum

	funcUnpin          func(block types.Block)
	inspectFuncUnpin   func(block types.Block)
	afterUnpinCounter  uint64
	beforeUnpinCounter uint64
	UnpinMock          mTrxIntMockUnpin
}

// NewTrxIntMock returns a mock for trxInt
func NewTrxIntMock(t minimock.Tester) *TrxIntMock {
	m := &TrxIntMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.PinMock = mTrxIntMockPin{mock: m}
	m.PinMock.callArgs = []*TrxIntMockPinParams{}

	m.SetInt64Mock = mTrxIntMockSetInt64{mock: m}
	m.SetInt64Mock.callArgs = []*TrxIntMockSetInt64Params{}

	m.SetInt8Mock = mTrxIntMockSetInt8{mock: m}
	m.SetInt8Mock.callArgs = []*TrxIntMockSetInt8Params{}

	m.SetStringMock = mTrxIntMockSetString{mock: m}
	m.SetStringMock.callArgs = []*TrxIntMockSetStringParams{}

	m.TXNumMock = mTrxIntMockTXNum{mock: m}

	m.UnpinMock = mTrxIntMockUnpin{mock: m}
	m.UnpinMock.callArgs = []*TrxIntMockUnpinParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTrxIntMockPin struct {
	optional           bool
	mock               *TrxIntMock
	defaultExpectation *TrxIntMockPinExpectation
	expectations       []*TrxIntMockPinExpectation

	callArgs []*TrxIntMockPinParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TrxIntMockPinExpectation specifies expectation struct of the trxInt.Pin
type TrxIntMockPinExpectation struct {
	mock      *TrxIntMock
	params    *TrxIntMockPinParams
	paramPtrs *TrxIntMockPinParamPtrs
	results   *TrxIntMockPinResults
	Counter   uint64
}

// TrxIntMockPinParams contains parameters of the trxInt.Pin
type TrxIntMockPinParams struct {
	block types.Block
}

// TrxIntMockPinParamPtrs contains pointers to parameters of the trxInt.Pin
type TrxIntMockPinParamPtrs struct {
	block *types.Block
}

// TrxIntMockPinResults contains results of the trxInt.Pin
type TrxIntMockPinResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPin *mTrxIntMockPin) Optional() *mTrxIntMockPin {
	mmPin.optional = true
	return mmPin
}

// Expect sets up expected params for trxInt.Pin
func (mmPin *mTrxIntMockPin) Expect(block types.Block) *mTrxIntMockPin {
	if mmPin.mock.funcPin != nil {
		mmPin.mock.t.Fatalf("TrxIntMock.Pin mock is already set by Set")
	}

	if mmPin.defaultExpectation == nil {
		mmPin.defaultExpectation = &TrxIntMockPinExpectation{}
	}

	if mmPin.defaultExpectation.paramPtrs != nil {
		mmPin.mock.t.Fatalf("TrxIntMock.Pin mock is already set by ExpectParams functions")
	}

	mmPin.defaultExpectation.params = &TrxIntMockPinParams{block}
	for _, e := range mmPin.expectations {
		if minimock.Equal(e.params, mmPin.defaultExpectation.params) {
			mmPin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPin.defaultExpectation.params)
		}
	}

	return mmPin
}

// ExpectBlockParam1 sets up expected param block for trxInt.Pin
func (mmPin *mTrxIntMockPin) ExpectBlockParam1(block types.Block) *mTrxIntMockPin {
	if mmPin.mock.funcPin != nil {
		mmPin.mock.t.Fatalf("TrxIntMock.Pin mock is already set by Set")
	}

	if mmPin.defaultExpectation == nil {
		mmPin.defaultExpectation = &TrxIntMockPinExpectation{}
	}

	if mmPin.defaultExpectation.params != nil {
		mmPin.mock.t.Fatalf("TrxIntMock.Pin mock is already set by Expect")
	}

	if mmPin.defaultExpectation.paramPtrs == nil {
		mmPin.defaultExpectation.paramPtrs = &TrxIntMockPinParamPtrs{}
	}
	mmPin.defaultExpectation.paramPtrs.block = &block

	return mmPin
}

// Inspect accepts an inspector function that has same arguments as the trxInt.Pin
func (mmPin *mTrxIntMockPin) Inspect(f func(block types.Block)) *mTrxIntMockPin {
	if mmPin.mock.inspectFuncPin != nil {
		mmPin.mock.t.Fatalf("Inspect function is already set for TrxIntMock.Pin")
	}

	mmPin.mock.inspectFuncPin = f

	return mmPin
}

// Return sets up results that will be returned by trxInt.Pin
func (mmPin *mTrxIntMockPin) Return(err error) *TrxIntMock {
	if mmPin.mock.funcPin != nil {
		mmPin.mock.t.Fatalf("TrxIntMock.Pin mock is already set by Set")
	}

	if mmPin.defaultExpectation == nil {
		mmPin.defaultExpectation = &TrxIntMockPinExpectation{mock: mmPin.mock}
	}
	mmPin.defaultExpectation.results = &TrxIntMockPinResults{err}
	return mmPin.mock
}

// Set uses given function f to mock the trxInt.Pin method
func (mmPin *mTrxIntMockPin) Set(f func(block types.Block) (err error)) *TrxIntMock {
	if mmPin.defaultExpectation != nil {
		mmPin.mock.t.Fatalf("Default expectation is already set for the trxInt.Pin method")
	}

	if len(mmPin.expectations) > 0 {
		mmPin.mock.t.Fatalf("Some expectations are already set for the trxInt.Pin method")
	}

	mmPin.mock.funcPin = f
	return mmPin.mock
}

// When sets expectation for the trxInt.Pin which will trigger the result defined by the following
// Then helper
func (mmPin *mTrxIntMockPin) When(block types.Block) *TrxIntMockPinExpectation {
	if mmPin.mock.funcPin != nil {
		mmPin.mock.t.Fatalf("TrxIntMock.Pin mock is already set by Set")
	}

	expectation := &TrxIntMockPinExpectation{
		mock:   mmPin.mock,
		params: &TrxIntMockPinParams{block},
	}
	mmPin.expectations = append(mmPin.expectations, expectation)
	return expectation
}

// Then sets up trxInt.Pin return parameters for the expectation previously defined by the When method
func (e *TrxIntMockPinExpectation) Then(err error) *TrxIntMock {
	e.results = &TrxIntMockPinResults{err}
	return e.mock
}

// Times sets number of times trxInt.Pin should be invoked
func (mmPin *mTrxIntMockPin) Times(n uint64) *mTrxIntMockPin {
	if n == 0 {
		mmPin.mock.t.Fatalf("Times of TrxIntMock.Pin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPin.expectedInvocations, n)
	return mmPin
}

func (mmPin *mTrxIntMockPin) invocationsDone() bool {
	if len(mmPin.expectations) == 0 && mmPin.defaultExpectation == nil && mmPin.mock.funcPin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPin.mock.afterPinCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Pin implements trxInt
func (mmPin *TrxIntMock) Pin(block types.Block) (err error) {
	mm_atomic.AddUint64(&mmPin.beforePinCounter, 1)
	defer mm_atomic.AddUint64(&mmPin.afterPinCounter, 1)

	if mmPin.inspectFuncPin != nil {
		mmPin.inspectFuncPin(block)
	}

	mm_params := TrxIntMockPinParams{block}

	// Record call args
	mmPin.PinMock.mutex.Lock()
	mmPin.PinMock.callArgs = append(mmPin.PinMock.callArgs, &mm_params)
	mmPin.PinMock.mutex.Unlock()

	for _, e := range mmPin.PinMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPin.PinMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPin.PinMock.defaultExpectation.Counter, 1)
		mm_want := mmPin.PinMock.defaultExpectation.params
		mm_want_ptrs := mmPin.PinMock.defaultExpectation.paramPtrs

		mm_got := TrxIntMockPinParams{block}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.block != nil && !minimock.Equal(*mm_want_ptrs.block, mm_got.block) {
				mmPin.t.Errorf("TrxIntMock.Pin got unexpected parameter block, want: %#v, got: %#v%s\n", *mm_want_ptrs.block, mm_got.block, minimock.Diff(*mm_want_ptrs.block, mm_got.block))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPin.t.Errorf("TrxIntMock.Pin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPin.PinMock.defaultExpectation.results
		if mm_results == nil {
			mmPin.t.Fatal("No results are set for the TrxIntMock.Pin")
		}
		return (*mm_results).err
	}
	if mmPin.funcPin != nil {
		return mmPin.funcPin(block)
	}
	mmPin.t.Fatalf("Unexpected call to TrxIntMock.Pin. %v", block)
	return
}

// PinAfterCounter returns a count of finished TrxIntMock.Pin invocations
func (mmPin *TrxIntMock) PinAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPin.afterPinCounter)
}

// PinBeforeCounter returns a count of TrxIntMock.Pin invocations
func (mmPin *TrxIntMock) PinBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPin.beforePinCounter)
}

// Calls returns a list of arguments used in each call to TrxIntMock.Pin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPin *mTrxIntMockPin) Calls() []*TrxIntMockPinParams {
	mmPin.mutex.RLock()

	argCopy := make([]*TrxIntMockPinParams, len(mmPin.callArgs))
	copy(argCopy, mmPin.callArgs)

	mmPin.mutex.RUnlock()

	return argCopy
}

// MinimockPinDone returns true if the count of the Pin invocations corresponds
// the number of defined expectations
func (m *TrxIntMock) MinimockPinDone() bool {
	if m.PinMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PinMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PinMock.invocationsDone()
}

// MinimockPinInspect logs each unmet expectation
func (m *TrxIntMock) MinimockPinInspect() {
	for _, e := range m.PinMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TrxIntMock.Pin with params: %#v", *e.params)
		}
	}

	afterPinCounter := mm_atomic.LoadUint64(&m.afterPinCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PinMock.defaultExpectation != nil && afterPinCounter < 1 {
		if m.PinMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TrxIntMock.Pin")
		} else {
			m.t.Errorf("Expected call to TrxIntMock.Pin with params: %#v", *m.PinMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPin != nil && afterPinCounter < 1 {
		m.t.Error("Expected call to TrxIntMock.Pin")
	}

	if !m.PinMock.invocationsDone() && afterPinCounter > 0 {
		m.t.Errorf("Expected %d calls to TrxIntMock.Pin but found %d calls",
			mm_atomic.LoadUint64(&m.PinMock.expectedInvocations), afterPinCounter)
	}
}

type mTrxIntMockSetInt64 struct {
	optional           bool
	mock               *TrxIntMock
	defaultExpectation *TrxIntMockSetInt64Expectation
	expectations       []*TrxIntMockSetInt64Expectation

	callArgs []*TrxIntMockSetInt64Params
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TrxIntMockSetInt64Expectation specifies expectation struct of the trxInt.SetInt64
type TrxIntMockSetInt64Expectation struct {
	mock      *TrxIntMock
	params    *TrxIntMockSetInt64Params
	paramPtrs *TrxIntMockSetInt64ParamPtrs
	results   *TrxIntMockSetInt64Results
	Counter   uint64
}

// TrxIntMockSetInt64Params contains parameters of the trxInt.SetInt64
type TrxIntMockSetInt64Params struct {
	block   types.Block
	offset  uint32
	value   int64
	okToLog bool
}

// TrxIntMockSetInt64ParamPtrs contains pointers to parameters of the trxInt.SetInt64
type TrxIntMockSetInt64ParamPtrs struct {
	block   *types.Block
	offset  *uint32
	value   *int64
	okToLog *bool
}

// TrxIntMockSetInt64Results contains results of the trxInt.SetInt64
type TrxIntMockSetInt64Results struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetInt64 *mTrxIntMockSetInt64) Optional() *mTrxIntMockSetInt64 {
	mmSetInt64.optional = true
	return mmSetInt64
}

// Expect sets up expected params for trxInt.SetInt64
func (mmSetInt64 *mTrxIntMockSetInt64) Expect(block types.Block, offset uint32, value int64, okToLog bool) *mTrxIntMockSetInt64 {
	if mmSetInt64.mock.funcSetInt64 != nil {
		mmSetInt64.mock.t.Fatalf("TrxIntMock.SetInt64 mock is already set by Set")
	}

	if mmSetInt64.defaultExpectation == nil {
		mmSetInt64.defaultExpectation = &TrxIntMockSetInt64Expectation{}
	}

	if mmSetInt64.defaultExpectation.paramPtrs != nil {
		mmSetInt64.mock.t.Fatalf("TrxIntMock.SetInt64 mock is already set by ExpectParams functions")
	}

	mmSetInt64.defaultExpectation.params = &TrxIntMockSetInt64Params{block, offset, value, okToLog}
	for _, e := range mmSetInt64.expectations {
		if minimock.Equal(e.params, mmSetInt64.defaultExpectation.params) {
			mmSetInt64.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetInt64.defaultExpectation.params)
		}
	}

	return mmSetInt64
}

// ExpectBlockParam1 sets up expected param block for trxInt.SetInt64
func (mmSetInt64 *mTrxIntMockSetInt64) ExpectBlockParam1(block types.Block) *mTrxIntMockSetInt64 {
	if mmSetInt64.mock.funcSetInt64 != nil {
		mmSetInt64.mock.t.Fatalf("TrxIntMock.SetInt64 mock is already set by Set")
	}

	if mmSetInt64.defaultExpectation == nil {
		mmSetInt64.defaultExpectation = &TrxIntMockSetInt64Expectation{}
	}

	if mmSetInt64.defaultExpectation.params != nil {
		mmSetInt64.mock.t.Fatalf("TrxIntMock.SetInt64 mock is already set by Expect")
	}

	if mmSetInt64.defaultExpectation.paramPtrs == nil {
		mmSetInt64.defaultExpectation.paramPtrs = &TrxIntMockSetInt64ParamPtrs{}
	}
	mmSetInt64.defaultExpectation.paramPtrs.block = &block

	return mmSetInt64
}

// ExpectOffsetParam2 sets up expected param offset for trxInt.SetInt64
func (mmSetInt64 *mTrxIntMockSetInt64) ExpectOffsetParam2(offset uint32) *mTrxIntMockSetInt64 {
	if mmSetInt64.mock.funcSetInt64 != nil {
		mmSetInt64.mock.t.Fatalf("TrxIntMock.SetInt64 mock is already set by Set")
	}

	if mmSetInt64.defaultExpectation == nil {
		mmSetInt64.defaultExpectation = &TrxIntMockSetInt64Expectation{}
	}

	if mmSetInt64.defaultExpectation.params != nil {
		mmSetInt64.mock.t.Fatalf("TrxIntMock.SetInt64 mock is already set by Expect")
	}

	if mmSetInt64.defaultExpectation.paramPtrs == nil {
		mmSetInt64.defaultExpectation.paramPtrs = &TrxIntMockSetInt64ParamPtrs{}
	}
	mmSetInt64.defaultExpectation.paramPtrs.offset = &offset

	return mmSetInt64
}

// ExpectValueParam3 sets up expected param value for trxInt.SetInt64
func (mmSetInt64 *mTrxIntMockSetInt64) ExpectValueParam3(value int64) *mTrxIntMockSetInt64 {
	if mmSetInt64.mock.funcSetInt64 != nil {
		mmSetInt64.mock.t.Fatalf("TrxIntMock.SetInt64 mock is already set by Set")
	}

	if mmSetInt64.defaultExpectation == nil {
		mmSetInt64.defaultExpectation = &TrxIntMockSetInt64Expectation{}
	}

	if mmSetInt64.defaultExpectation.params != nil {
		mmSetInt64.mock.t.Fatalf("TrxIntMock.SetInt64 mock is already set by Expect")
	}

	if mmSetInt64.defaultExpectation.paramPtrs == nil {
		mmSetInt64.defaultExpectation.paramPtrs = &TrxIntMockSetInt64ParamPtrs{}
	}
	mmSetInt64.defaultExpectation.paramPtrs.value = &value

	return mmSetInt64
}

// ExpectOkToLogParam4 sets up expected param okToLog for trxInt.SetInt64
func (mmSetInt64 *mTrxIntMockSetInt64) ExpectOkToLogParam4(okToLog bool) *mTrxIntMockSetInt64 {
	if mmSetInt64.mock.funcSetInt64 != nil {
		mmSetInt64.mock.t.Fatalf("TrxIntMock.SetInt64 mock is already set by Set")
	}

	if mmSetInt64.defaultExpectation == nil {
		mmSetInt64.defaultExpectation = &TrxIntMockSetInt64Expectation{}
	}

	if mmSetInt64.defaultExpectation.params != nil {
		mmSetInt64.mock.t.Fatalf("TrxIntMock.SetInt64 mock is already set by Expect")
	}

	if mmSetInt64.defaultExpectation.paramPtrs == nil {
		mmSetInt64.defaultExpectation.paramPtrs = &TrxIntMockSetInt64ParamPtrs{}
	}
	mmSetInt64.defaultExpectation.paramPtrs.okToLog = &okToLog

	return mmSetInt64
}

// Inspect accepts an inspector function that has same arguments as the trxInt.SetInt64
func (mmSetInt64 *mTrxIntMockSetInt64) Inspect(f func(block types.Block, offset uint32, value int64, okToLog bool)) *mTrxIntMockSetInt64 {
	if mmSetInt64.mock.inspectFuncSetInt64 != nil {
		mmSetInt64.mock.t.Fatalf("Inspect function is already set for TrxIntMock.SetInt64")
	}

	mmSetInt64.mock.inspectFuncSetInt64 = f

	return mmSetInt64
}

// Return sets up results that will be returned by trxInt.SetInt64
func (mmSetInt64 *mTrxIntMockSetInt64) Return(err error) *TrxIntMock {
	if mmSetInt64.mock.funcSetInt64 != nil {
		mmSetInt64.mock.t.Fatalf("TrxIntMock.SetInt64 mock is already set by Set")
	}

	if mmSetInt64.defaultExpectation == nil {
		mmSetInt64.defaultExpectation = &TrxIntMockSetInt64Expectation{mock: mmSetInt64.mock}
	}
	mmSetInt64.defaultExpectation.results = &TrxIntMockSetInt64Results{err}
	return mmSetInt64.mock
}

// Set uses given function f to mock the trxInt.SetInt64 method
func (mmSetInt64 *mTrxIntMockSetInt64) Set(f func(block types.Block, offset uint32, value int64, okToLog bool) (err error)) *TrxIntMock {
	if mmSetInt64.defaultExpectation != nil {
		mmSetInt64.mock.t.Fatalf("Default expectation is already set for the trxInt.SetInt64 method")
	}

	if len(mmSetInt64.expectations) > 0 {
		mmSetInt64.mock.t.Fatalf("Some expectations are already set for the trxInt.SetInt64 method")
	}

	mmSetInt64.mock.funcSetInt64 = f
	return mmSetInt64.mock
}

// When sets expectation for the trxInt.SetInt64 which will trigger the result defined by the following
// Then helper
func (mmSetInt64 *mTrxIntMockSetInt64) When(block types.Block, offset uint32, value int64, okToLog bool) *TrxIntMockSetInt64Expectation {
	if mmSetInt64.mock.funcSetInt64 != nil {
		mmSetInt64.mock.t.Fatalf("TrxIntMock.SetInt64 mock is already set by Set")
	}

	expectation := &TrxIntMockSetInt64Expectation{
		mock:   mmSetInt64.mock,
		params: &TrxIntMockSetInt64Params{block, offset, value, okToLog},
	}
	mmSetInt64.expectations = append(mmSetInt64.expectations, expectation)
	return expectation
}

// Then sets up trxInt.SetInt64 return parameters for the expectation previously defined by the When method
func (e *TrxIntMockSetInt64Expectation) Then(err error) *TrxIntMock {
	e.results = &TrxIntMockSetInt64Results{err}
	return e.mock
}

// Times sets number of times trxInt.SetInt64 should be invoked
func (mmSetInt64 *mTrxIntMockSetInt64) Times(n uint64) *mTrxIntMockSetInt64 {
	if n == 0 {
		mmSetInt64.mock.t.Fatalf("Times of TrxIntMock.SetInt64 mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetInt64.expectedInvocations, n)
	return mmSetInt64
}

func (mmSetInt64 *mTrxIntMockSetInt64) invocationsDone() bool {
	if len(mmSetInt64.expectations) == 0 && mmSetInt64.defaultExpectation == nil && mmSetInt64.mock.funcSetInt64 == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetInt64.mock.afterSetInt64Counter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetInt64.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetInt64 implements trxInt
func (mmSetInt64 *TrxIntMock) SetInt64(block types.Block, offset uint32, value int64, okToLog bool) (err error) {
	mm_atomic.AddUint64(&mmSetInt64.beforeSetInt64Counter, 1)
	defer mm_atomic.AddUint64(&mmSetInt64.afterSetInt64Counter, 1)

	if mmSetInt64.inspectFuncSetInt64 != nil {
		mmSetInt64.inspectFuncSetInt64(block, offset, value, okToLog)
	}

	mm_params := TrxIntMockSetInt64Params{block, offset, value, okToLog}

	// Record call args
	mmSetInt64.SetInt64Mock.mutex.Lock()
	mmSetInt64.SetInt64Mock.callArgs = append(mmSetInt64.SetInt64Mock.callArgs, &mm_params)
	mmSetInt64.SetInt64Mock.mutex.Unlock()

	for _, e := range mmSetInt64.SetInt64Mock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetInt64.SetInt64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetInt64.SetInt64Mock.defaultExpectation.Counter, 1)
		mm_want := mmSetInt64.SetInt64Mock.defaultExpectation.params
		mm_want_ptrs := mmSetInt64.SetInt64Mock.defaultExpectation.paramPtrs

		mm_got := TrxIntMockSetInt64Params{block, offset, value, okToLog}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.block != nil && !minimock.Equal(*mm_want_ptrs.block, mm_got.block) {
				mmSetInt64.t.Errorf("TrxIntMock.SetInt64 got unexpected parameter block, want: %#v, got: %#v%s\n", *mm_want_ptrs.block, mm_got.block, minimock.Diff(*mm_want_ptrs.block, mm_got.block))
			}

			if mm_want_ptrs.offset != nil && !minimock.Equal(*mm_want_ptrs.offset, mm_got.offset) {
				mmSetInt64.t.Errorf("TrxIntMock.SetInt64 got unexpected parameter offset, want: %#v, got: %#v%s\n", *mm_want_ptrs.offset, mm_got.offset, minimock.Diff(*mm_want_ptrs.offset, mm_got.offset))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSetInt64.t.Errorf("TrxIntMock.SetInt64 got unexpected parameter value, want: %#v, got: %#v%s\n", *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.okToLog != nil && !minimock.Equal(*mm_want_ptrs.okToLog, mm_got.okToLog) {
				mmSetInt64.t.Errorf("TrxIntMock.SetInt64 got unexpected parameter okToLog, want: %#v, got: %#v%s\n", *mm_want_ptrs.okToLog, mm_got.okToLog, minimock.Diff(*mm_want_ptrs.okToLog, mm_got.okToLog))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetInt64.t.Errorf("TrxIntMock.SetInt64 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetInt64.SetInt64Mock.defaultExpectation.results
		if mm_results == nil {
			mmSetInt64.t.Fatal("No results are set for the TrxIntMock.SetInt64")
		}
		return (*mm_results).err
	}
	if mmSetInt64.funcSetInt64 != nil {
		return mmSetInt64.funcSetInt64(block, offset, value, okToLog)
	}
	mmSetInt64.t.Fatalf("Unexpected call to TrxIntMock.SetInt64. %v %v %v %v", block, offset, value, okToLog)
	return
}

// SetInt64AfterCounter returns a count of finished TrxIntMock.SetInt64 invocations
func (mmSetInt64 *TrxIntMock) SetInt64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetInt64.afterSetInt64Counter)
}

// SetInt64BeforeCounter returns a count of TrxIntMock.SetInt64 invocations
func (mmSetInt64 *TrxIntMock) SetInt64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetInt64.beforeSetInt64Counter)
}

// Calls returns a list of arguments used in each call to TrxIntMock.SetInt64.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetInt64 *mTrxIntMockSetInt64) Calls() []*TrxIntMockSetInt64Params {
	mmSetInt64.mutex.RLock()

	argCopy := make([]*TrxIntMockSetInt64Params, len(mmSetInt64.callArgs))
	copy(argCopy, mmSetInt64.callArgs)

	mmSetInt64.mutex.RUnlock()

	return argCopy
}

// MinimockSetInt64Done returns true if the count of the SetInt64 invocations corresponds
// the number of defined expectations
func (m *TrxIntMock) MinimockSetInt64Done() bool {
	if m.SetInt64Mock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetInt64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetInt64Mock.invocationsDone()
}

// MinimockSetInt64Inspect logs each unmet expectation
func (m *TrxIntMock) MinimockSetInt64Inspect() {
	for _, e := range m.SetInt64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TrxIntMock.SetInt64 with params: %#v", *e.params)
		}
	}

	afterSetInt64Counter := mm_atomic.LoadUint64(&m.afterSetInt64Counter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetInt64Mock.defaultExpectation != nil && afterSetInt64Counter < 1 {
		if m.SetInt64Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TrxIntMock.SetInt64")
		} else {
			m.t.Errorf("Expected call to TrxIntMock.SetInt64 with params: %#v", *m.SetInt64Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetInt64 != nil && afterSetInt64Counter < 1 {
		m.t.Error("Expected call to TrxIntMock.SetInt64")
	}

	if !m.SetInt64Mock.invocationsDone() && afterSetInt64Counter > 0 {
		m.t.Errorf("Expected %d calls to TrxIntMock.SetInt64 but found %d calls",
			mm_atomic.LoadUint64(&m.SetInt64Mock.expectedInvocations), afterSetInt64Counter)
	}
}

type mTrxIntMockSetInt8 struct {
	optional           bool
	mock               *TrxIntMock
	defaultExpectation *TrxIntMockSetInt8Expectation
	expectations       []*TrxIntMockSetInt8Expectation

	callArgs []*TrxIntMockSetInt8Params
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TrxIntMockSetInt8Expectation specifies expectation struct of the trxInt.SetInt8
type TrxIntMockSetInt8Expectation struct {
	mock      *TrxIntMock
	params    *TrxIntMockSetInt8Params
	paramPtrs *TrxIntMockSetInt8ParamPtrs
	results   *TrxIntMockSetInt8Results
	Counter   uint64
}

// TrxIntMockSetInt8Params contains parameters of the trxInt.SetInt8
type TrxIntMockSetInt8Params struct {
	block   types.Block
	offset  uint32
	value   int8
	okToLog bool
}

// TrxIntMockSetInt8ParamPtrs contains pointers to parameters of the trxInt.SetInt8
type TrxIntMockSetInt8ParamPtrs struct {
	block   *types.Block
	offset  *uint32
	value   *int8
	okToLog *bool
}

// TrxIntMockSetInt8Results contains results of the trxInt.SetInt8
type TrxIntMockSetInt8Results struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetInt8 *mTrxIntMockSetInt8) Optional() *mTrxIntMockSetInt8 {
	mmSetInt8.optional = true
	return mmSetInt8
}

// Expect sets up expected params for trxInt.SetInt8
func (mmSetInt8 *mTrxIntMockSetInt8) Expect(block types.Block, offset uint32, value int8, okToLog bool) *mTrxIntMockSetInt8 {
	if mmSetInt8.mock.funcSetInt8 != nil {
		mmSetInt8.mock.t.Fatalf("TrxIntMock.SetInt8 mock is already set by Set")
	}

	if mmSetInt8.defaultExpectation == nil {
		mmSetInt8.defaultExpectation = &TrxIntMockSetInt8Expectation{}
	}

	if mmSetInt8.defaultExpectation.paramPtrs != nil {
		mmSetInt8.mock.t.Fatalf("TrxIntMock.SetInt8 mock is already set by ExpectParams functions")
	}

	mmSetInt8.defaultExpectation.params = &TrxIntMockSetInt8Params{block, offset, value, okToLog}
	for _, e := range mmSetInt8.expectations {
		if minimock.Equal(e.params, mmSetInt8.defaultExpectation.params) {
			mmSetInt8.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetInt8.defaultExpectation.params)
		}
	}

	return mmSetInt8
}

// ExpectBlockParam1 sets up expected param block for trxInt.SetInt8
func (mmSetInt8 *mTrxIntMockSetInt8) ExpectBlockParam1(block types.Block) *mTrxIntMockSetInt8 {
	if mmSetInt8.mock.funcSetInt8 != nil {
		mmSetInt8.mock.t.Fatalf("TrxIntMock.SetInt8 mock is already set by Set")
	}

	if mmSetInt8.defaultExpectation == nil {
		mmSetInt8.defaultExpectation = &TrxIntMockSetInt8Expectation{}
	}

	if mmSetInt8.defaultExpectation.params != nil {
		mmSetInt8.mock.t.Fatalf("TrxIntMock.SetInt8 mock is already set by Expect")
	}

	if mmSetInt8.defaultExpectation.paramPtrs == nil {
		mmSetInt8.defaultExpectation.paramPtrs = &TrxIntMockSetInt8ParamPtrs{}
	}
	mmSetInt8.defaultExpectation.paramPtrs.block = &block

	return mmSetInt8
}

// ExpectOffsetParam2 sets up expected param offset for trxInt.SetInt8
func (mmSetInt8 *mTrxIntMockSetInt8) ExpectOffsetParam2(offset uint32) *mTrxIntMockSetInt8 {
	if mmSetInt8.mock.funcSetInt8 != nil {
		mmSetInt8.mock.t.Fatalf("TrxIntMock.SetInt8 mock is already set by Set")
	}

	if mmSetInt8.defaultExpectation == nil {
		mmSetInt8.defaultExpectation = &TrxIntMockSetInt8Expectation{}
	}

	if mmSetInt8.defaultExpectation.params != nil {
		mmSetInt8.mock.t.Fatalf("TrxIntMock.SetInt8 mock is already set by Expect")
	}

	if mmSetInt8.defaultExpectation.paramPtrs == nil {
		mmSetInt8.defaultExpectation.paramPtrs = &TrxIntMockSetInt8ParamPtrs{}
	}
	mmSetInt8.defaultExpectation.paramPtrs.offset = &offset

	return mmSetInt8
}

// ExpectValueParam3 sets up expected param value for trxInt.SetInt8
func (mmSetInt8 *mTrxIntMockSetInt8) ExpectValueParam3(value int8) *mTrxIntMockSetInt8 {
	if mmSetInt8.mock.funcSetInt8 != nil {
		mmSetInt8.mock.t.Fatalf("TrxIntMock.SetInt8 mock is already set by Set")
	}

	if mmSetInt8.defaultExpectation == nil {
		mmSetInt8.defaultExpectation = &TrxIntMockSetInt8Expectation{}
	}

	if mmSetInt8.defaultExpectation.params != nil {
		mmSetInt8.mock.t.Fatalf("TrxIntMock.SetInt8 mock is already set by Expect")
	}

	if mmSetInt8.defaultExpectation.paramPtrs == nil {
		mmSetInt8.defaultExpectation.paramPtrs = &TrxIntMockSetInt8ParamPtrs{}
	}
	mmSetInt8.defaultExpectation.paramPtrs.value = &value

	return mmSetInt8
}

// ExpectOkToLogParam4 sets up expected param okToLog for trxInt.SetInt8
func (mmSetInt8 *mTrxIntMockSetInt8) ExpectOkToLogParam4(okToLog bool) *mTrxIntMockSetInt8 {
	if mmSetInt8.mock.funcSetInt8 != nil {
		mmSetInt8.mock.t.Fatalf("TrxIntMock.SetInt8 mock is already set by Set")
	}

	if mmSetInt8.defaultExpectation == nil {
		mmSetInt8.defaultExpectation = &TrxIntMockSetInt8Expectation{}
	}

	if mmSetInt8.defaultExpectation.params != nil {
		mmSetInt8.mock.t.Fatalf("TrxIntMock.SetInt8 mock is already set by Expect")
	}

	if mmSetInt8.defaultExpectation.paramPtrs == nil {
		mmSetInt8.defaultExpectation.paramPtrs = &TrxIntMockSetInt8ParamPtrs{}
	}
	mmSetInt8.defaultExpectation.paramPtrs.okToLog = &okToLog

	return mmSetInt8
}

// Inspect accepts an inspector function that has same arguments as the trxInt.SetInt8
func (mmSetInt8 *mTrxIntMockSetInt8) Inspect(f func(block types.Block, offset uint32, value int8, okToLog bool)) *mTrxIntMockSetInt8 {
	if mmSetInt8.mock.inspectFuncSetInt8 != nil {
		mmSetInt8.mock.t.Fatalf("Inspect function is already set for TrxIntMock.SetInt8")
	}

	mmSetInt8.mock.inspectFuncSetInt8 = f

	return mmSetInt8
}

// Return sets up results that will be returned by trxInt.SetInt8
func (mmSetInt8 *mTrxIntMockSetInt8) Return(err error) *TrxIntMock {
	if mmSetInt8.mock.funcSetInt8 != nil {
		mmSetInt8.mock.t.Fatalf("TrxIntMock.SetInt8 mock is already set by Set")
	}

	if mmSetInt8.defaultExpectation == nil {
		mmSetInt8.defaultExpectation = &TrxIntMockSetInt8Expectation{mock: mmSetInt8.mock}
	}
	mmSetInt8.defaultExpectation.results = &TrxIntMockSetInt8Results{err}
	return mmSetInt8.mock
}

// Set uses given function f to mock the trxInt.SetInt8 method
func (mmSetInt8 *mTrxIntMockSetInt8) Set(f func(block types.Block, offset uint32, value int8, okToLog bool) (err error)) *TrxIntMock {
	if mmSetInt8.defaultExpectation != nil {
		mmSetInt8.mock.t.Fatalf("Default expectation is already set for the trxInt.SetInt8 method")
	}

	if len(mmSetInt8.expectations) > 0 {
		mmSetInt8.mock.t.Fatalf("Some expectations are already set for the trxInt.SetInt8 method")
	}

	mmSetInt8.mock.funcSetInt8 = f
	return mmSetInt8.mock
}

// When sets expectation for the trxInt.SetInt8 which will trigger the result defined by the following
// Then helper
func (mmSetInt8 *mTrxIntMockSetInt8) When(block types.Block, offset uint32, value int8, okToLog bool) *TrxIntMockSetInt8Expectation {
	if mmSetInt8.mock.funcSetInt8 != nil {
		mmSetInt8.mock.t.Fatalf("TrxIntMock.SetInt8 mock is already set by Set")
	}

	expectation := &TrxIntMockSetInt8Expectation{
		mock:   mmSetInt8.mock,
		params: &TrxIntMockSetInt8Params{block, offset, value, okToLog},
	}
	mmSetInt8.expectations = append(mmSetInt8.expectations, expectation)
	return expectation
}

// Then sets up trxInt.SetInt8 return parameters for the expectation previously defined by the When method
func (e *TrxIntMockSetInt8Expectation) Then(err error) *TrxIntMock {
	e.results = &TrxIntMockSetInt8Results{err}
	return e.mock
}

// Times sets number of times trxInt.SetInt8 should be invoked
func (mmSetInt8 *mTrxIntMockSetInt8) Times(n uint64) *mTrxIntMockSetInt8 {
	if n == 0 {
		mmSetInt8.mock.t.Fatalf("Times of TrxIntMock.SetInt8 mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetInt8.expectedInvocations, n)
	return mmSetInt8
}

func (mmSetInt8 *mTrxIntMockSetInt8) invocationsDone() bool {
	if len(mmSetInt8.expectations) == 0 && mmSetInt8.defaultExpectation == nil && mmSetInt8.mock.funcSetInt8 == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetInt8.mock.afterSetInt8Counter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetInt8.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetInt8 implements trxInt
func (mmSetInt8 *TrxIntMock) SetInt8(block types.Block, offset uint32, value int8, okToLog bool) (err error) {
	mm_atomic.AddUint64(&mmSetInt8.beforeSetInt8Counter, 1)
	defer mm_atomic.AddUint64(&mmSetInt8.afterSetInt8Counter, 1)

	if mmSetInt8.inspectFuncSetInt8 != nil {
		mmSetInt8.inspectFuncSetInt8(block, offset, value, okToLog)
	}

	mm_params := TrxIntMockSetInt8Params{block, offset, value, okToLog}

	// Record call args
	mmSetInt8.SetInt8Mock.mutex.Lock()
	mmSetInt8.SetInt8Mock.callArgs = append(mmSetInt8.SetInt8Mock.callArgs, &mm_params)
	mmSetInt8.SetInt8Mock.mutex.Unlock()

	for _, e := range mmSetInt8.SetInt8Mock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetInt8.SetInt8Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetInt8.SetInt8Mock.defaultExpectation.Counter, 1)
		mm_want := mmSetInt8.SetInt8Mock.defaultExpectation.params
		mm_want_ptrs := mmSetInt8.SetInt8Mock.defaultExpectation.paramPtrs

		mm_got := TrxIntMockSetInt8Params{block, offset, value, okToLog}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.block != nil && !minimock.Equal(*mm_want_ptrs.block, mm_got.block) {
				mmSetInt8.t.Errorf("TrxIntMock.SetInt8 got unexpected parameter block, want: %#v, got: %#v%s\n", *mm_want_ptrs.block, mm_got.block, minimock.Diff(*mm_want_ptrs.block, mm_got.block))
			}

			if mm_want_ptrs.offset != nil && !minimock.Equal(*mm_want_ptrs.offset, mm_got.offset) {
				mmSetInt8.t.Errorf("TrxIntMock.SetInt8 got unexpected parameter offset, want: %#v, got: %#v%s\n", *mm_want_ptrs.offset, mm_got.offset, minimock.Diff(*mm_want_ptrs.offset, mm_got.offset))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSetInt8.t.Errorf("TrxIntMock.SetInt8 got unexpected parameter value, want: %#v, got: %#v%s\n", *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.okToLog != nil && !minimock.Equal(*mm_want_ptrs.okToLog, mm_got.okToLog) {
				mmSetInt8.t.Errorf("TrxIntMock.SetInt8 got unexpected parameter okToLog, want: %#v, got: %#v%s\n", *mm_want_ptrs.okToLog, mm_got.okToLog, minimock.Diff(*mm_want_ptrs.okToLog, mm_got.okToLog))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetInt8.t.Errorf("TrxIntMock.SetInt8 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetInt8.SetInt8Mock.defaultExpectation.results
		if mm_results == nil {
			mmSetInt8.t.Fatal("No results are set for the TrxIntMock.SetInt8")
		}
		return (*mm_results).err
	}
	if mmSetInt8.funcSetInt8 != nil {
		return mmSetInt8.funcSetInt8(block, offset, value, okToLog)
	}
	mmSetInt8.t.Fatalf("Unexpected call to TrxIntMock.SetInt8. %v %v %v %v", block, offset, value, okToLog)
	return
}

// SetInt8AfterCounter returns a count of finished TrxIntMock.SetInt8 invocations
func (mmSetInt8 *TrxIntMock) SetInt8AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetInt8.afterSetInt8Counter)
}

// SetInt8BeforeCounter returns a count of TrxIntMock.SetInt8 invocations
func (mmSetInt8 *TrxIntMock) SetInt8BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetInt8.beforeSetInt8Counter)
}

// Calls returns a list of arguments used in each call to TrxIntMock.SetInt8.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetInt8 *mTrxIntMockSetInt8) Calls() []*TrxIntMockSetInt8Params {
	mmSetInt8.mutex.RLock()

	argCopy := make([]*TrxIntMockSetInt8Params, len(mmSetInt8.callArgs))
	copy(argCopy, mmSetInt8.callArgs)

	mmSetInt8.mutex.RUnlock()

	return argCopy
}

// MinimockSetInt8Done returns true if the count of the SetInt8 invocations corresponds
// the number of defined expectations
func (m *TrxIntMock) MinimockSetInt8Done() bool {
	if m.SetInt8Mock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetInt8Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetInt8Mock.invocationsDone()
}

// MinimockSetInt8Inspect logs each unmet expectation
func (m *TrxIntMock) MinimockSetInt8Inspect() {
	for _, e := range m.SetInt8Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TrxIntMock.SetInt8 with params: %#v", *e.params)
		}
	}

	afterSetInt8Counter := mm_atomic.LoadUint64(&m.afterSetInt8Counter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetInt8Mock.defaultExpectation != nil && afterSetInt8Counter < 1 {
		if m.SetInt8Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TrxIntMock.SetInt8")
		} else {
			m.t.Errorf("Expected call to TrxIntMock.SetInt8 with params: %#v", *m.SetInt8Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetInt8 != nil && afterSetInt8Counter < 1 {
		m.t.Error("Expected call to TrxIntMock.SetInt8")
	}

	if !m.SetInt8Mock.invocationsDone() && afterSetInt8Counter > 0 {
		m.t.Errorf("Expected %d calls to TrxIntMock.SetInt8 but found %d calls",
			mm_atomic.LoadUint64(&m.SetInt8Mock.expectedInvocations), afterSetInt8Counter)
	}
}

type mTrxIntMockSetString struct {
	optional           bool
	mock               *TrxIntMock
	defaultExpectation *TrxIntMockSetStringExpectation
	expectations       []*TrxIntMockSetStringExpectation

	callArgs []*TrxIntMockSetStringParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TrxIntMockSetStringExpectation specifies expectation struct of the trxInt.SetString
type TrxIntMockSetStringExpectation struct {
	mock      *TrxIntMock
	params    *TrxIntMockSetStringParams
	paramPtrs *TrxIntMockSetStringParamPtrs
	results   *TrxIntMockSetStringResults
	Counter   uint64
}

// TrxIntMockSetStringParams contains parameters of the trxInt.SetString
type TrxIntMockSetStringParams struct {
	block   types.Block
	offset  uint32
	value   string
	okToLog bool
}

// TrxIntMockSetStringParamPtrs contains pointers to parameters of the trxInt.SetString
type TrxIntMockSetStringParamPtrs struct {
	block   *types.Block
	offset  *uint32
	value   *string
	okToLog *bool
}

// TrxIntMockSetStringResults contains results of the trxInt.SetString
type TrxIntMockSetStringResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetString *mTrxIntMockSetString) Optional() *mTrxIntMockSetString {
	mmSetString.optional = true
	return mmSetString
}

// Expect sets up expected params for trxInt.SetString
func (mmSetString *mTrxIntMockSetString) Expect(block types.Block, offset uint32, value string, okToLog bool) *mTrxIntMockSetString {
	if mmSetString.mock.funcSetString != nil {
		mmSetString.mock.t.Fatalf("TrxIntMock.SetString mock is already set by Set")
	}

	if mmSetString.defaultExpectation == nil {
		mmSetString.defaultExpectation = &TrxIntMockSetStringExpectation{}
	}

	if mmSetString.defaultExpectation.paramPtrs != nil {
		mmSetString.mock.t.Fatalf("TrxIntMock.SetString mock is already set by ExpectParams functions")
	}

	mmSetString.defaultExpectation.params = &TrxIntMockSetStringParams{block, offset, value, okToLog}
	for _, e := range mmSetString.expectations {
		if minimock.Equal(e.params, mmSetString.defaultExpectation.params) {
			mmSetString.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetString.defaultExpectation.params)
		}
	}

	return mmSetString
}

// ExpectBlockParam1 sets up expected param block for trxInt.SetString
func (mmSetString *mTrxIntMockSetString) ExpectBlockParam1(block types.Block) *mTrxIntMockSetString {
	if mmSetString.mock.funcSetString != nil {
		mmSetString.mock.t.Fatalf("TrxIntMock.SetString mock is already set by Set")
	}

	if mmSetString.defaultExpectation == nil {
		mmSetString.defaultExpectation = &TrxIntMockSetStringExpectation{}
	}

	if mmSetString.defaultExpectation.params != nil {
		mmSetString.mock.t.Fatalf("TrxIntMock.SetString mock is already set by Expect")
	}

	if mmSetString.defaultExpectation.paramPtrs == nil {
		mmSetString.defaultExpectation.paramPtrs = &TrxIntMockSetStringParamPtrs{}
	}
	mmSetString.defaultExpectation.paramPtrs.block = &block

	return mmSetString
}

// ExpectOffsetParam2 sets up expected param offset for trxInt.SetString
func (mmSetString *mTrxIntMockSetString) ExpectOffsetParam2(offset uint32) *mTrxIntMockSetString {
	if mmSetString.mock.funcSetString != nil {
		mmSetString.mock.t.Fatalf("TrxIntMock.SetString mock is already set by Set")
	}

	if mmSetString.defaultExpectation == nil {
		mmSetString.defaultExpectation = &TrxIntMockSetStringExpectation{}
	}

	if mmSetString.defaultExpectation.params != nil {
		mmSetString.mock.t.Fatalf("TrxIntMock.SetString mock is already set by Expect")
	}

	if mmSetString.defaultExpectation.paramPtrs == nil {
		mmSetString.defaultExpectation.paramPtrs = &TrxIntMockSetStringParamPtrs{}
	}
	mmSetString.defaultExpectation.paramPtrs.offset = &offset

	return mmSetString
}

// ExpectValueParam3 sets up expected param value for trxInt.SetString
func (mmSetString *mTrxIntMockSetString) ExpectValueParam3(value string) *mTrxIntMockSetString {
	if mmSetString.mock.funcSetString != nil {
		mmSetString.mock.t.Fatalf("TrxIntMock.SetString mock is already set by Set")
	}

	if mmSetString.defaultExpectation == nil {
		mmSetString.defaultExpectation = &TrxIntMockSetStringExpectation{}
	}

	if mmSetString.defaultExpectation.params != nil {
		mmSetString.mock.t.Fatalf("TrxIntMock.SetString mock is already set by Expect")
	}

	if mmSetString.defaultExpectation.paramPtrs == nil {
		mmSetString.defaultExpectation.paramPtrs = &TrxIntMockSetStringParamPtrs{}
	}
	mmSetString.defaultExpectation.paramPtrs.value = &value

	return mmSetString
}

// ExpectOkToLogParam4 sets up expected param okToLog for trxInt.SetString
func (mmSetString *mTrxIntMockSetString) ExpectOkToLogParam4(okToLog bool) *mTrxIntMockSetString {
	if mmSetString.mock.funcSetString != nil {
		mmSetString.mock.t.Fatalf("TrxIntMock.SetString mock is already set by Set")
	}

	if mmSetString.defaultExpectation == nil {
		mmSetString.defaultExpectation = &TrxIntMockSetStringExpectation{}
	}

	if mmSetString.defaultExpectation.params != nil {
		mmSetString.mock.t.Fatalf("TrxIntMock.SetString mock is already set by Expect")
	}

	if mmSetString.defaultExpectation.paramPtrs == nil {
		mmSetString.defaultExpectation.paramPtrs = &TrxIntMockSetStringParamPtrs{}
	}
	mmSetString.defaultExpectation.paramPtrs.okToLog = &okToLog

	return mmSetString
}

// Inspect accepts an inspector function that has same arguments as the trxInt.SetString
func (mmSetString *mTrxIntMockSetString) Inspect(f func(block types.Block, offset uint32, value string, okToLog bool)) *mTrxIntMockSetString {
	if mmSetString.mock.inspectFuncSetString != nil {
		mmSetString.mock.t.Fatalf("Inspect function is already set for TrxIntMock.SetString")
	}

	mmSetString.mock.inspectFuncSetString = f

	return mmSetString
}

// Return sets up results that will be returned by trxInt.SetString
func (mmSetString *mTrxIntMockSetString) Return(err error) *TrxIntMock {
	if mmSetString.mock.funcSetString != nil {
		mmSetString.mock.t.Fatalf("TrxIntMock.SetString mock is already set by Set")
	}

	if mmSetString.defaultExpectation == nil {
		mmSetString.defaultExpectation = &TrxIntMockSetStringExpectation{mock: mmSetString.mock}
	}
	mmSetString.defaultExpectation.results = &TrxIntMockSetStringResults{err}
	return mmSetString.mock
}

// Set uses given function f to mock the trxInt.SetString method
func (mmSetString *mTrxIntMockSetString) Set(f func(block types.Block, offset uint32, value string, okToLog bool) (err error)) *TrxIntMock {
	if mmSetString.defaultExpectation != nil {
		mmSetString.mock.t.Fatalf("Default expectation is already set for the trxInt.SetString method")
	}

	if len(mmSetString.expectations) > 0 {
		mmSetString.mock.t.Fatalf("Some expectations are already set for the trxInt.SetString method")
	}

	mmSetString.mock.funcSetString = f
	return mmSetString.mock
}

// When sets expectation for the trxInt.SetString which will trigger the result defined by the following
// Then helper
func (mmSetString *mTrxIntMockSetString) When(block types.Block, offset uint32, value string, okToLog bool) *TrxIntMockSetStringExpectation {
	if mmSetString.mock.funcSetString != nil {
		mmSetString.mock.t.Fatalf("TrxIntMock.SetString mock is already set by Set")
	}

	expectation := &TrxIntMockSetStringExpectation{
		mock:   mmSetString.mock,
		params: &TrxIntMockSetStringParams{block, offset, value, okToLog},
	}
	mmSetString.expectations = append(mmSetString.expectations, expectation)
	return expectation
}

// Then sets up trxInt.SetString return parameters for the expectation previously defined by the When method
func (e *TrxIntMockSetStringExpectation) Then(err error) *TrxIntMock {
	e.results = &TrxIntMockSetStringResults{err}
	return e.mock
}

// Times sets number of times trxInt.SetString should be invoked
func (mmSetString *mTrxIntMockSetString) Times(n uint64) *mTrxIntMockSetString {
	if n == 0 {
		mmSetString.mock.t.Fatalf("Times of TrxIntMock.SetString mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetString.expectedInvocations, n)
	return mmSetString
}

func (mmSetString *mTrxIntMockSetString) invocationsDone() bool {
	if len(mmSetString.expectations) == 0 && mmSetString.defaultExpectation == nil && mmSetString.mock.funcSetString == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetString.mock.afterSetStringCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetString.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetString implements trxInt
func (mmSetString *TrxIntMock) SetString(block types.Block, offset uint32, value string, okToLog bool) (err error) {
	mm_atomic.AddUint64(&mmSetString.beforeSetStringCounter, 1)
	defer mm_atomic.AddUint64(&mmSetString.afterSetStringCounter, 1)

	if mmSetString.inspectFuncSetString != nil {
		mmSetString.inspectFuncSetString(block, offset, value, okToLog)
	}

	mm_params := TrxIntMockSetStringParams{block, offset, value, okToLog}

	// Record call args
	mmSetString.SetStringMock.mutex.Lock()
	mmSetString.SetStringMock.callArgs = append(mmSetString.SetStringMock.callArgs, &mm_params)
	mmSetString.SetStringMock.mutex.Unlock()

	for _, e := range mmSetString.SetStringMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetString.SetStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetString.SetStringMock.defaultExpectation.Counter, 1)
		mm_want := mmSetString.SetStringMock.defaultExpectation.params
		mm_want_ptrs := mmSetString.SetStringMock.defaultExpectation.paramPtrs

		mm_got := TrxIntMockSetStringParams{block, offset, value, okToLog}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.block != nil && !minimock.Equal(*mm_want_ptrs.block, mm_got.block) {
				mmSetString.t.Errorf("TrxIntMock.SetString got unexpected parameter block, want: %#v, got: %#v%s\n", *mm_want_ptrs.block, mm_got.block, minimock.Diff(*mm_want_ptrs.block, mm_got.block))
			}

			if mm_want_ptrs.offset != nil && !minimock.Equal(*mm_want_ptrs.offset, mm_got.offset) {
				mmSetString.t.Errorf("TrxIntMock.SetString got unexpected parameter offset, want: %#v, got: %#v%s\n", *mm_want_ptrs.offset, mm_got.offset, minimock.Diff(*mm_want_ptrs.offset, mm_got.offset))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSetString.t.Errorf("TrxIntMock.SetString got unexpected parameter value, want: %#v, got: %#v%s\n", *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.okToLog != nil && !minimock.Equal(*mm_want_ptrs.okToLog, mm_got.okToLog) {
				mmSetString.t.Errorf("TrxIntMock.SetString got unexpected parameter okToLog, want: %#v, got: %#v%s\n", *mm_want_ptrs.okToLog, mm_got.okToLog, minimock.Diff(*mm_want_ptrs.okToLog, mm_got.okToLog))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetString.t.Errorf("TrxIntMock.SetString got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetString.SetStringMock.defaultExpectation.results
		if mm_results == nil {
			mmSetString.t.Fatal("No results are set for the TrxIntMock.SetString")
		}
		return (*mm_results).err
	}
	if mmSetString.funcSetString != nil {
		return mmSetString.funcSetString(block, offset, value, okToLog)
	}
	mmSetString.t.Fatalf("Unexpected call to TrxIntMock.SetString. %v %v %v %v", block, offset, value, okToLog)
	return
}

// SetStringAfterCounter returns a count of finished TrxIntMock.SetString invocations
func (mmSetString *TrxIntMock) SetStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetString.afterSetStringCounter)
}

// SetStringBeforeCounter returns a count of TrxIntMock.SetString invocations
func (mmSetString *TrxIntMock) SetStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetString.beforeSetStringCounter)
}

// Calls returns a list of arguments used in each call to TrxIntMock.SetString.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetString *mTrxIntMockSetString) Calls() []*TrxIntMockSetStringParams {
	mmSetString.mutex.RLock()

	argCopy := make([]*TrxIntMockSetStringParams, len(mmSetString.callArgs))
	copy(argCopy, mmSetString.callArgs)

	mmSetString.mutex.RUnlock()

	return argCopy
}

// MinimockSetStringDone returns true if the count of the SetString invocations corresponds
// the number of defined expectations
func (m *TrxIntMock) MinimockSetStringDone() bool {
	if m.SetStringMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStringMock.invocationsDone()
}

// MinimockSetStringInspect logs each unmet expectation
func (m *TrxIntMock) MinimockSetStringInspect() {
	for _, e := range m.SetStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TrxIntMock.SetString with params: %#v", *e.params)
		}
	}

	afterSetStringCounter := mm_atomic.LoadUint64(&m.afterSetStringCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStringMock.defaultExpectation != nil && afterSetStringCounter < 1 {
		if m.SetStringMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TrxIntMock.SetString")
		} else {
			m.t.Errorf("Expected call to TrxIntMock.SetString with params: %#v", *m.SetStringMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetString != nil && afterSetStringCounter < 1 {
		m.t.Error("Expected call to TrxIntMock.SetString")
	}

	if !m.SetStringMock.invocationsDone() && afterSetStringCounter > 0 {
		m.t.Errorf("Expected %d calls to TrxIntMock.SetString but found %d calls",
			mm_atomic.LoadUint64(&m.SetStringMock.expectedInvocations), afterSetStringCounter)
	}
}

type mTrxIntMockTXNum struct {
	optional           bool
	mock               *TrxIntMock
	defaultExpectation *TrxIntMockTXNumExpectation
	expectations       []*TrxIntMockTXNumExpectation

	expectedInvocations uint64
}

// TrxIntMockTXNumExpectation specifies expectation struct of the trxInt.TXNum
type TrxIntMockTXNumExpectation struct {
	mock *TrxIntMock

	results *TrxIntMockTXNumResults
	Counter uint64
}

// TrxIntMockTXNumResults contains results of the trxInt.TXNum
type TrxIntMockTXNumResults struct {
	t1 types.TRX
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTXNum *mTrxIntMockTXNum) Optional() *mTrxIntMockTXNum {
	mmTXNum.optional = true
	return mmTXNum
}

// Expect sets up expected params for trxInt.TXNum
func (mmTXNum *mTrxIntMockTXNum) Expect() *mTrxIntMockTXNum {
	if mmTXNum.mock.funcTXNum != nil {
		mmTXNum.mock.t.Fatalf("TrxIntMock.TXNum mock is already set by Set")
	}

	if mmTXNum.defaultExpectation == nil {
		mmTXNum.defaultExpectation = &TrxIntMockTXNumExpectation{}
	}

	return mmTXNum
}

// Inspect accepts an inspector function that has same arguments as the trxInt.TXNum
func (mmTXNum *mTrxIntMockTXNum) Inspect(f func()) *mTrxIntMockTXNum {
	if mmTXNum.mock.inspectFuncTXNum != nil {
		mmTXNum.mock.t.Fatalf("Inspect function is already set for TrxIntMock.TXNum")
	}

	mmTXNum.mock.inspectFuncTXNum = f

	return mmTXNum
}

// Return sets up results that will be returned by trxInt.TXNum
func (mmTXNum *mTrxIntMockTXNum) Return(t1 types.TRX) *TrxIntMock {
	if mmTXNum.mock.funcTXNum != nil {
		mmTXNum.mock.t.Fatalf("TrxIntMock.TXNum mock is already set by Set")
	}

	if mmTXNum.defaultExpectation == nil {
		mmTXNum.defaultExpectation = &TrxIntMockTXNumExpectation{mock: mmTXNum.mock}
	}
	mmTXNum.defaultExpectation.results = &TrxIntMockTXNumResults{t1}
	return mmTXNum.mock
}

// Set uses given function f to mock the trxInt.TXNum method
func (mmTXNum *mTrxIntMockTXNum) Set(f func() (t1 types.TRX)) *TrxIntMock {
	if mmTXNum.defaultExpectation != nil {
		mmTXNum.mock.t.Fatalf("Default expectation is already set for the trxInt.TXNum method")
	}

	if len(mmTXNum.expectations) > 0 {
		mmTXNum.mock.t.Fatalf("Some expectations are already set for the trxInt.TXNum method")
	}

	mmTXNum.mock.funcTXNum = f
	return mmTXNum.mock
}

// Times sets number of times trxInt.TXNum should be invoked
func (mmTXNum *mTrxIntMockTXNum) Times(n uint64) *mTrxIntMockTXNum {
	if n == 0 {
		mmTXNum.mock.t.Fatalf("Times of TrxIntMock.TXNum mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTXNum.expectedInvocations, n)
	return mmTXNum
}

func (mmTXNum *mTrxIntMockTXNum) invocationsDone() bool {
	if len(mmTXNum.expectations) == 0 && mmTXNum.defaultExpectation == nil && mmTXNum.mock.funcTXNum == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTXNum.mock.afterTXNumCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTXNum.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TXNum implements trxInt
func (mmTXNum *TrxIntMock) TXNum() (t1 types.TRX) {
	mm_atomic.AddUint64(&mmTXNum.beforeTXNumCounter, 1)
	defer mm_atomic.AddUint64(&mmTXNum.afterTXNumCounter, 1)

	if mmTXNum.inspectFuncTXNum != nil {
		mmTXNum.inspectFuncTXNum()
	}

	if mmTXNum.TXNumMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTXNum.TXNumMock.defaultExpectation.Counter, 1)

		mm_results := mmTXNum.TXNumMock.defaultExpectation.results
		if mm_results == nil {
			mmTXNum.t.Fatal("No results are set for the TrxIntMock.TXNum")
		}
		return (*mm_results).t1
	}
	if mmTXNum.funcTXNum != nil {
		return mmTXNum.funcTXNum()
	}
	mmTXNum.t.Fatalf("Unexpected call to TrxIntMock.TXNum.")
	return
}

// TXNumAfterCounter returns a count of finished TrxIntMock.TXNum invocations
func (mmTXNum *TrxIntMock) TXNumAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTXNum.afterTXNumCounter)
}

// TXNumBeforeCounter returns a count of TrxIntMock.TXNum invocations
func (mmTXNum *TrxIntMock) TXNumBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTXNum.beforeTXNumCounter)
}

// MinimockTXNumDone returns true if the count of the TXNum invocations corresponds
// the number of defined expectations
func (m *TrxIntMock) MinimockTXNumDone() bool {
	if m.TXNumMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TXNumMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TXNumMock.invocationsDone()
}

// MinimockTXNumInspect logs each unmet expectation
func (m *TrxIntMock) MinimockTXNumInspect() {
	for _, e := range m.TXNumMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TrxIntMock.TXNum")
		}
	}

	afterTXNumCounter := mm_atomic.LoadUint64(&m.afterTXNumCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TXNumMock.defaultExpectation != nil && afterTXNumCounter < 1 {
		m.t.Error("Expected call to TrxIntMock.TXNum")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTXNum != nil && afterTXNumCounter < 1 {
		m.t.Error("Expected call to TrxIntMock.TXNum")
	}

	if !m.TXNumMock.invocationsDone() && afterTXNumCounter > 0 {
		m.t.Errorf("Expected %d calls to TrxIntMock.TXNum but found %d calls",
			mm_atomic.LoadUint64(&m.TXNumMock.expectedInvocations), afterTXNumCounter)
	}
}

type mTrxIntMockUnpin struct {
	optional           bool
	mock               *TrxIntMock
	defaultExpectation *TrxIntMockUnpinExpectation
	expectations       []*TrxIntMockUnpinExpectation

	callArgs []*TrxIntMockUnpinParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TrxIntMockUnpinExpectation specifies expectation struct of the trxInt.Unpin
type TrxIntMockUnpinExpectation struct {
	mock      *TrxIntMock
	params    *TrxIntMockUnpinParams
	paramPtrs *TrxIntMockUnpinParamPtrs

	Counter uint64
}

// TrxIntMockUnpinParams contains parameters of the trxInt.Unpin
type TrxIntMockUnpinParams struct {
	block types.Block
}

// TrxIntMockUnpinParamPtrs contains pointers to parameters of the trxInt.Unpin
type TrxIntMockUnpinParamPtrs struct {
	block *types.Block
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUnpin *mTrxIntMockUnpin) Optional() *mTrxIntMockUnpin {
	mmUnpin.optional = true
	return mmUnpin
}

// Expect sets up expected params for trxInt.Unpin
func (mmUnpin *mTrxIntMockUnpin) Expect(block types.Block) *mTrxIntMockUnpin {
	if mmUnpin.mock.funcUnpin != nil {
		mmUnpin.mock.t.Fatalf("TrxIntMock.Unpin mock is already set by Set")
	}

	if mmUnpin.defaultExpectation == nil {
		mmUnpin.defaultExpectation = &TrxIntMockUnpinExpectation{}
	}

	if mmUnpin.defaultExpectation.paramPtrs != nil {
		mmUnpin.mock.t.Fatalf("TrxIntMock.Unpin mock is already set by ExpectParams functions")
	}

	mmUnpin.defaultExpectation.params = &TrxIntMockUnpinParams{block}
	for _, e := range mmUnpin.expectations {
		if minimock.Equal(e.params, mmUnpin.defaultExpectation.params) {
			mmUnpin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnpin.defaultExpectation.params)
		}
	}

	return mmUnpin
}

// ExpectBlockParam1 sets up expected param block for trxInt.Unpin
func (mmUnpin *mTrxIntMockUnpin) ExpectBlockParam1(block types.Block) *mTrxIntMockUnpin {
	if mmUnpin.mock.funcUnpin != nil {
		mmUnpin.mock.t.Fatalf("TrxIntMock.Unpin mock is already set by Set")
	}

	if mmUnpin.defaultExpectation == nil {
		mmUnpin.defaultExpectation = &TrxIntMockUnpinExpectation{}
	}

	if mmUnpin.defaultExpectation.params != nil {
		mmUnpin.mock.t.Fatalf("TrxIntMock.Unpin mock is already set by Expect")
	}

	if mmUnpin.defaultExpectation.paramPtrs == nil {
		mmUnpin.defaultExpectation.paramPtrs = &TrxIntMockUnpinParamPtrs{}
	}
	mmUnpin.defaultExpectation.paramPtrs.block = &block

	return mmUnpin
}

// Inspect accepts an inspector function that has same arguments as the trxInt.Unpin
func (mmUnpin *mTrxIntMockUnpin) Inspect(f func(block types.Block)) *mTrxIntMockUnpin {
	if mmUnpin.mock.inspectFuncUnpin != nil {
		mmUnpin.mock.t.Fatalf("Inspect function is already set for TrxIntMock.Unpin")
	}

	mmUnpin.mock.inspectFuncUnpin = f

	return mmUnpin
}

// Return sets up results that will be returned by trxInt.Unpin
func (mmUnpin *mTrxIntMockUnpin) Return() *TrxIntMock {
	if mmUnpin.mock.funcUnpin != nil {
		mmUnpin.mock.t.Fatalf("TrxIntMock.Unpin mock is already set by Set")
	}

	if mmUnpin.defaultExpectation == nil {
		mmUnpin.defaultExpectation = &TrxIntMockUnpinExpectation{mock: mmUnpin.mock}
	}

	return mmUnpin.mock
}

// Set uses given function f to mock the trxInt.Unpin method
func (mmUnpin *mTrxIntMockUnpin) Set(f func(block types.Block)) *TrxIntMock {
	if mmUnpin.defaultExpectation != nil {
		mmUnpin.mock.t.Fatalf("Default expectation is already set for the trxInt.Unpin method")
	}

	if len(mmUnpin.expectations) > 0 {
		mmUnpin.mock.t.Fatalf("Some expectations are already set for the trxInt.Unpin method")
	}

	mmUnpin.mock.funcUnpin = f
	return mmUnpin.mock
}

// Times sets number of times trxInt.Unpin should be invoked
func (mmUnpin *mTrxIntMockUnpin) Times(n uint64) *mTrxIntMockUnpin {
	if n == 0 {
		mmUnpin.mock.t.Fatalf("Times of TrxIntMock.Unpin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUnpin.expectedInvocations, n)
	return mmUnpin
}

func (mmUnpin *mTrxIntMockUnpin) invocationsDone() bool {
	if len(mmUnpin.expectations) == 0 && mmUnpin.defaultExpectation == nil && mmUnpin.mock.funcUnpin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUnpin.mock.afterUnpinCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUnpin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Unpin implements trxInt
func (mmUnpin *TrxIntMock) Unpin(block types.Block) {
	mm_atomic.AddUint64(&mmUnpin.beforeUnpinCounter, 1)
	defer mm_atomic.AddUint64(&mmUnpin.afterUnpinCounter, 1)

	if mmUnpin.inspectFuncUnpin != nil {
		mmUnpin.inspectFuncUnpin(block)
	}

	mm_params := TrxIntMockUnpinParams{block}

	// Record call args
	mmUnpin.UnpinMock.mutex.Lock()
	mmUnpin.UnpinMock.callArgs = append(mmUnpin.UnpinMock.callArgs, &mm_params)
	mmUnpin.UnpinMock.mutex.Unlock()

	for _, e := range mmUnpin.UnpinMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmUnpin.UnpinMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnpin.UnpinMock.defaultExpectation.Counter, 1)
		mm_want := mmUnpin.UnpinMock.defaultExpectation.params
		mm_want_ptrs := mmUnpin.UnpinMock.defaultExpectation.paramPtrs

		mm_got := TrxIntMockUnpinParams{block}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.block != nil && !minimock.Equal(*mm_want_ptrs.block, mm_got.block) {
				mmUnpin.t.Errorf("TrxIntMock.Unpin got unexpected parameter block, want: %#v, got: %#v%s\n", *mm_want_ptrs.block, mm_got.block, minimock.Diff(*mm_want_ptrs.block, mm_got.block))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnpin.t.Errorf("TrxIntMock.Unpin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmUnpin.funcUnpin != nil {
		mmUnpin.funcUnpin(block)
		return
	}
	mmUnpin.t.Fatalf("Unexpected call to TrxIntMock.Unpin. %v", block)

}

// UnpinAfterCounter returns a count of finished TrxIntMock.Unpin invocations
func (mmUnpin *TrxIntMock) UnpinAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpin.afterUnpinCounter)
}

// UnpinBeforeCounter returns a count of TrxIntMock.Unpin invocations
func (mmUnpin *TrxIntMock) UnpinBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpin.beforeUnpinCounter)
}

// Calls returns a list of arguments used in each call to TrxIntMock.Unpin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnpin *mTrxIntMockUnpin) Calls() []*TrxIntMockUnpinParams {
	mmUnpin.mutex.RLock()

	argCopy := make([]*TrxIntMockUnpinParams, len(mmUnpin.callArgs))
	copy(argCopy, mmUnpin.callArgs)

	mmUnpin.mutex.RUnlock()

	return argCopy
}

// MinimockUnpinDone returns true if the count of the Unpin invocations corresponds
// the number of defined expectations
func (m *TrxIntMock) MinimockUnpinDone() bool {
	if m.UnpinMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UnpinMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UnpinMock.invocationsDone()
}

// MinimockUnpinInspect logs each unmet expectation
func (m *TrxIntMock) MinimockUnpinInspect() {
	for _, e := range m.UnpinMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TrxIntMock.Unpin with params: %#v", *e.params)
		}
	}

	afterUnpinCounter := mm_atomic.LoadUint64(&m.afterUnpinCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UnpinMock.defaultExpectation != nil && afterUnpinCounter < 1 {
		if m.UnpinMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TrxIntMock.Unpin")
		} else {
			m.t.Errorf("Expected call to TrxIntMock.Unpin with params: %#v", *m.UnpinMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpin != nil && afterUnpinCounter < 1 {
		m.t.Error("Expected call to TrxIntMock.Unpin")
	}

	if !m.UnpinMock.invocationsDone() && afterUnpinCounter > 0 {
		m.t.Errorf("Expected %d calls to TrxIntMock.Unpin but found %d calls",
			mm_atomic.LoadUint64(&m.UnpinMock.expectedInvocations), afterUnpinCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TrxIntMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockPinInspect()

			m.MinimockSetInt64Inspect()

			m.MinimockSetInt8Inspect()

			m.MinimockSetStringInspect()

			m.MinimockTXNumInspect()

			m.MinimockUnpinInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TrxIntMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TrxIntMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockPinDone() &&
		m.MinimockSetInt64Done() &&
		m.MinimockSetInt8Done() &&
		m.MinimockSetStringDone() &&
		m.MinimockTXNumDone() &&
		m.MinimockUnpinDone()
}
