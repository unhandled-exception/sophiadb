package recovery

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/unhandled-exception/sophiadb/internal/pkg/tx/recovery.trxInt -o ./trx_int_mock_test.go -n TrxIntMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/unhandled-exception/sophiadb/internal/pkg/types"
)

// TrxIntMock implements trxInt
type TrxIntMock struct {
	t minimock.Tester

	funcPin          func(block *types.BlockID) (err error)
	inspectFuncPin   func(block *types.BlockID)
	afterPinCounter  uint64
	beforePinCounter uint64
	PinMock          mTrxIntMockPin

	funcSetInt64          func(block *types.BlockID, offset uint32, value int64, okToLog bool) (err error)
	inspectFuncSetInt64   func(block *types.BlockID, offset uint32, value int64, okToLog bool)
	afterSetInt64Counter  uint64
	beforeSetInt64Counter uint64
	SetInt64Mock          mTrxIntMockSetInt64

	funcSetString          func(block *types.BlockID, offset uint32, value string, okToLog bool) (err error)
	inspectFuncSetString   func(block *types.BlockID, offset uint32, value string, okToLog bool)
	afterSetStringCounter  uint64
	beforeSetStringCounter uint64
	SetStringMock          mTrxIntMockSetString

	funcUnpin          func(block *types.BlockID) (err error)
	inspectFuncUnpin   func(block *types.BlockID)
	afterUnpinCounter  uint64
	beforeUnpinCounter uint64
	UnpinMock          mTrxIntMockUnpin
}

// NewTrxIntMock returns a mock for trxInt
func NewTrxIntMock(t minimock.Tester) *TrxIntMock {
	m := &TrxIntMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.PinMock = mTrxIntMockPin{mock: m}
	m.PinMock.callArgs = []*TrxIntMockPinParams{}

	m.SetInt64Mock = mTrxIntMockSetInt64{mock: m}
	m.SetInt64Mock.callArgs = []*TrxIntMockSetInt64Params{}

	m.SetStringMock = mTrxIntMockSetString{mock: m}
	m.SetStringMock.callArgs = []*TrxIntMockSetStringParams{}

	m.UnpinMock = mTrxIntMockUnpin{mock: m}
	m.UnpinMock.callArgs = []*TrxIntMockUnpinParams{}

	return m
}

type mTrxIntMockPin struct {
	mock               *TrxIntMock
	defaultExpectation *TrxIntMockPinExpectation
	expectations       []*TrxIntMockPinExpectation

	callArgs []*TrxIntMockPinParams
	mutex    sync.RWMutex
}

// TrxIntMockPinExpectation specifies expectation struct of the trxInt.Pin
type TrxIntMockPinExpectation struct {
	mock    *TrxIntMock
	params  *TrxIntMockPinParams
	results *TrxIntMockPinResults
	Counter uint64
}

// TrxIntMockPinParams contains parameters of the trxInt.Pin
type TrxIntMockPinParams struct {
	block *types.BlockID
}

// TrxIntMockPinResults contains results of the trxInt.Pin
type TrxIntMockPinResults struct {
	err error
}

// Expect sets up expected params for trxInt.Pin
func (mmPin *mTrxIntMockPin) Expect(block *types.BlockID) *mTrxIntMockPin {
	if mmPin.mock.funcPin != nil {
		mmPin.mock.t.Fatalf("TrxIntMock.Pin mock is already set by Set")
	}

	if mmPin.defaultExpectation == nil {
		mmPin.defaultExpectation = &TrxIntMockPinExpectation{}
	}

	mmPin.defaultExpectation.params = &TrxIntMockPinParams{block}
	for _, e := range mmPin.expectations {
		if minimock.Equal(e.params, mmPin.defaultExpectation.params) {
			mmPin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPin.defaultExpectation.params)
		}
	}

	return mmPin
}

// Inspect accepts an inspector function that has same arguments as the trxInt.Pin
func (mmPin *mTrxIntMockPin) Inspect(f func(block *types.BlockID)) *mTrxIntMockPin {
	if mmPin.mock.inspectFuncPin != nil {
		mmPin.mock.t.Fatalf("Inspect function is already set for TrxIntMock.Pin")
	}

	mmPin.mock.inspectFuncPin = f

	return mmPin
}

// Return sets up results that will be returned by trxInt.Pin
func (mmPin *mTrxIntMockPin) Return(err error) *TrxIntMock {
	if mmPin.mock.funcPin != nil {
		mmPin.mock.t.Fatalf("TrxIntMock.Pin mock is already set by Set")
	}

	if mmPin.defaultExpectation == nil {
		mmPin.defaultExpectation = &TrxIntMockPinExpectation{mock: mmPin.mock}
	}
	mmPin.defaultExpectation.results = &TrxIntMockPinResults{err}
	return mmPin.mock
}

//Set uses given function f to mock the trxInt.Pin method
func (mmPin *mTrxIntMockPin) Set(f func(block *types.BlockID) (err error)) *TrxIntMock {
	if mmPin.defaultExpectation != nil {
		mmPin.mock.t.Fatalf("Default expectation is already set for the trxInt.Pin method")
	}

	if len(mmPin.expectations) > 0 {
		mmPin.mock.t.Fatalf("Some expectations are already set for the trxInt.Pin method")
	}

	mmPin.mock.funcPin = f
	return mmPin.mock
}

// When sets expectation for the trxInt.Pin which will trigger the result defined by the following
// Then helper
func (mmPin *mTrxIntMockPin) When(block *types.BlockID) *TrxIntMockPinExpectation {
	if mmPin.mock.funcPin != nil {
		mmPin.mock.t.Fatalf("TrxIntMock.Pin mock is already set by Set")
	}

	expectation := &TrxIntMockPinExpectation{
		mock:   mmPin.mock,
		params: &TrxIntMockPinParams{block},
	}
	mmPin.expectations = append(mmPin.expectations, expectation)
	return expectation
}

// Then sets up trxInt.Pin return parameters for the expectation previously defined by the When method
func (e *TrxIntMockPinExpectation) Then(err error) *TrxIntMock {
	e.results = &TrxIntMockPinResults{err}
	return e.mock
}

// Pin implements trxInt
func (mmPin *TrxIntMock) Pin(block *types.BlockID) (err error) {
	mm_atomic.AddUint64(&mmPin.beforePinCounter, 1)
	defer mm_atomic.AddUint64(&mmPin.afterPinCounter, 1)

	if mmPin.inspectFuncPin != nil {
		mmPin.inspectFuncPin(block)
	}

	mm_params := &TrxIntMockPinParams{block}

	// Record call args
	mmPin.PinMock.mutex.Lock()
	mmPin.PinMock.callArgs = append(mmPin.PinMock.callArgs, mm_params)
	mmPin.PinMock.mutex.Unlock()

	for _, e := range mmPin.PinMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPin.PinMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPin.PinMock.defaultExpectation.Counter, 1)
		mm_want := mmPin.PinMock.defaultExpectation.params
		mm_got := TrxIntMockPinParams{block}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPin.t.Errorf("TrxIntMock.Pin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPin.PinMock.defaultExpectation.results
		if mm_results == nil {
			mmPin.t.Fatal("No results are set for the TrxIntMock.Pin")
		}
		return (*mm_results).err
	}
	if mmPin.funcPin != nil {
		return mmPin.funcPin(block)
	}
	mmPin.t.Fatalf("Unexpected call to TrxIntMock.Pin. %v", block)
	return
}

// PinAfterCounter returns a count of finished TrxIntMock.Pin invocations
func (mmPin *TrxIntMock) PinAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPin.afterPinCounter)
}

// PinBeforeCounter returns a count of TrxIntMock.Pin invocations
func (mmPin *TrxIntMock) PinBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPin.beforePinCounter)
}

// Calls returns a list of arguments used in each call to TrxIntMock.Pin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPin *mTrxIntMockPin) Calls() []*TrxIntMockPinParams {
	mmPin.mutex.RLock()

	argCopy := make([]*TrxIntMockPinParams, len(mmPin.callArgs))
	copy(argCopy, mmPin.callArgs)

	mmPin.mutex.RUnlock()

	return argCopy
}

// MinimockPinDone returns true if the count of the Pin invocations corresponds
// the number of defined expectations
func (m *TrxIntMock) MinimockPinDone() bool {
	for _, e := range m.PinMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PinMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPinCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPin != nil && mm_atomic.LoadUint64(&m.afterPinCounter) < 1 {
		return false
	}
	return true
}

// MinimockPinInspect logs each unmet expectation
func (m *TrxIntMock) MinimockPinInspect() {
	for _, e := range m.PinMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TrxIntMock.Pin with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PinMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPinCounter) < 1 {
		if m.PinMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TrxIntMock.Pin")
		} else {
			m.t.Errorf("Expected call to TrxIntMock.Pin with params: %#v", *m.PinMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPin != nil && mm_atomic.LoadUint64(&m.afterPinCounter) < 1 {
		m.t.Error("Expected call to TrxIntMock.Pin")
	}
}

type mTrxIntMockSetInt64 struct {
	mock               *TrxIntMock
	defaultExpectation *TrxIntMockSetInt64Expectation
	expectations       []*TrxIntMockSetInt64Expectation

	callArgs []*TrxIntMockSetInt64Params
	mutex    sync.RWMutex
}

// TrxIntMockSetInt64Expectation specifies expectation struct of the trxInt.SetInt64
type TrxIntMockSetInt64Expectation struct {
	mock    *TrxIntMock
	params  *TrxIntMockSetInt64Params
	results *TrxIntMockSetInt64Results
	Counter uint64
}

// TrxIntMockSetInt64Params contains parameters of the trxInt.SetInt64
type TrxIntMockSetInt64Params struct {
	block   *types.BlockID
	offset  uint32
	value   int64
	okToLog bool
}

// TrxIntMockSetInt64Results contains results of the trxInt.SetInt64
type TrxIntMockSetInt64Results struct {
	err error
}

// Expect sets up expected params for trxInt.SetInt64
func (mmSetInt64 *mTrxIntMockSetInt64) Expect(block *types.BlockID, offset uint32, value int64, okToLog bool) *mTrxIntMockSetInt64 {
	if mmSetInt64.mock.funcSetInt64 != nil {
		mmSetInt64.mock.t.Fatalf("TrxIntMock.SetInt64 mock is already set by Set")
	}

	if mmSetInt64.defaultExpectation == nil {
		mmSetInt64.defaultExpectation = &TrxIntMockSetInt64Expectation{}
	}

	mmSetInt64.defaultExpectation.params = &TrxIntMockSetInt64Params{block, offset, value, okToLog}
	for _, e := range mmSetInt64.expectations {
		if minimock.Equal(e.params, mmSetInt64.defaultExpectation.params) {
			mmSetInt64.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetInt64.defaultExpectation.params)
		}
	}

	return mmSetInt64
}

// Inspect accepts an inspector function that has same arguments as the trxInt.SetInt64
func (mmSetInt64 *mTrxIntMockSetInt64) Inspect(f func(block *types.BlockID, offset uint32, value int64, okToLog bool)) *mTrxIntMockSetInt64 {
	if mmSetInt64.mock.inspectFuncSetInt64 != nil {
		mmSetInt64.mock.t.Fatalf("Inspect function is already set for TrxIntMock.SetInt64")
	}

	mmSetInt64.mock.inspectFuncSetInt64 = f

	return mmSetInt64
}

// Return sets up results that will be returned by trxInt.SetInt64
func (mmSetInt64 *mTrxIntMockSetInt64) Return(err error) *TrxIntMock {
	if mmSetInt64.mock.funcSetInt64 != nil {
		mmSetInt64.mock.t.Fatalf("TrxIntMock.SetInt64 mock is already set by Set")
	}

	if mmSetInt64.defaultExpectation == nil {
		mmSetInt64.defaultExpectation = &TrxIntMockSetInt64Expectation{mock: mmSetInt64.mock}
	}
	mmSetInt64.defaultExpectation.results = &TrxIntMockSetInt64Results{err}
	return mmSetInt64.mock
}

//Set uses given function f to mock the trxInt.SetInt64 method
func (mmSetInt64 *mTrxIntMockSetInt64) Set(f func(block *types.BlockID, offset uint32, value int64, okToLog bool) (err error)) *TrxIntMock {
	if mmSetInt64.defaultExpectation != nil {
		mmSetInt64.mock.t.Fatalf("Default expectation is already set for the trxInt.SetInt64 method")
	}

	if len(mmSetInt64.expectations) > 0 {
		mmSetInt64.mock.t.Fatalf("Some expectations are already set for the trxInt.SetInt64 method")
	}

	mmSetInt64.mock.funcSetInt64 = f
	return mmSetInt64.mock
}

// When sets expectation for the trxInt.SetInt64 which will trigger the result defined by the following
// Then helper
func (mmSetInt64 *mTrxIntMockSetInt64) When(block *types.BlockID, offset uint32, value int64, okToLog bool) *TrxIntMockSetInt64Expectation {
	if mmSetInt64.mock.funcSetInt64 != nil {
		mmSetInt64.mock.t.Fatalf("TrxIntMock.SetInt64 mock is already set by Set")
	}

	expectation := &TrxIntMockSetInt64Expectation{
		mock:   mmSetInt64.mock,
		params: &TrxIntMockSetInt64Params{block, offset, value, okToLog},
	}
	mmSetInt64.expectations = append(mmSetInt64.expectations, expectation)
	return expectation
}

// Then sets up trxInt.SetInt64 return parameters for the expectation previously defined by the When method
func (e *TrxIntMockSetInt64Expectation) Then(err error) *TrxIntMock {
	e.results = &TrxIntMockSetInt64Results{err}
	return e.mock
}

// SetInt64 implements trxInt
func (mmSetInt64 *TrxIntMock) SetInt64(block *types.BlockID, offset uint32, value int64, okToLog bool) (err error) {
	mm_atomic.AddUint64(&mmSetInt64.beforeSetInt64Counter, 1)
	defer mm_atomic.AddUint64(&mmSetInt64.afterSetInt64Counter, 1)

	if mmSetInt64.inspectFuncSetInt64 != nil {
		mmSetInt64.inspectFuncSetInt64(block, offset, value, okToLog)
	}

	mm_params := &TrxIntMockSetInt64Params{block, offset, value, okToLog}

	// Record call args
	mmSetInt64.SetInt64Mock.mutex.Lock()
	mmSetInt64.SetInt64Mock.callArgs = append(mmSetInt64.SetInt64Mock.callArgs, mm_params)
	mmSetInt64.SetInt64Mock.mutex.Unlock()

	for _, e := range mmSetInt64.SetInt64Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetInt64.SetInt64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetInt64.SetInt64Mock.defaultExpectation.Counter, 1)
		mm_want := mmSetInt64.SetInt64Mock.defaultExpectation.params
		mm_got := TrxIntMockSetInt64Params{block, offset, value, okToLog}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetInt64.t.Errorf("TrxIntMock.SetInt64 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetInt64.SetInt64Mock.defaultExpectation.results
		if mm_results == nil {
			mmSetInt64.t.Fatal("No results are set for the TrxIntMock.SetInt64")
		}
		return (*mm_results).err
	}
	if mmSetInt64.funcSetInt64 != nil {
		return mmSetInt64.funcSetInt64(block, offset, value, okToLog)
	}
	mmSetInt64.t.Fatalf("Unexpected call to TrxIntMock.SetInt64. %v %v %v %v", block, offset, value, okToLog)
	return
}

// SetInt64AfterCounter returns a count of finished TrxIntMock.SetInt64 invocations
func (mmSetInt64 *TrxIntMock) SetInt64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetInt64.afterSetInt64Counter)
}

// SetInt64BeforeCounter returns a count of TrxIntMock.SetInt64 invocations
func (mmSetInt64 *TrxIntMock) SetInt64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetInt64.beforeSetInt64Counter)
}

// Calls returns a list of arguments used in each call to TrxIntMock.SetInt64.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetInt64 *mTrxIntMockSetInt64) Calls() []*TrxIntMockSetInt64Params {
	mmSetInt64.mutex.RLock()

	argCopy := make([]*TrxIntMockSetInt64Params, len(mmSetInt64.callArgs))
	copy(argCopy, mmSetInt64.callArgs)

	mmSetInt64.mutex.RUnlock()

	return argCopy
}

// MinimockSetInt64Done returns true if the count of the SetInt64 invocations corresponds
// the number of defined expectations
func (m *TrxIntMock) MinimockSetInt64Done() bool {
	for _, e := range m.SetInt64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetInt64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetInt64Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetInt64 != nil && mm_atomic.LoadUint64(&m.afterSetInt64Counter) < 1 {
		return false
	}
	return true
}

// MinimockSetInt64Inspect logs each unmet expectation
func (m *TrxIntMock) MinimockSetInt64Inspect() {
	for _, e := range m.SetInt64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TrxIntMock.SetInt64 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetInt64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetInt64Counter) < 1 {
		if m.SetInt64Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TrxIntMock.SetInt64")
		} else {
			m.t.Errorf("Expected call to TrxIntMock.SetInt64 with params: %#v", *m.SetInt64Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetInt64 != nil && mm_atomic.LoadUint64(&m.afterSetInt64Counter) < 1 {
		m.t.Error("Expected call to TrxIntMock.SetInt64")
	}
}

type mTrxIntMockSetString struct {
	mock               *TrxIntMock
	defaultExpectation *TrxIntMockSetStringExpectation
	expectations       []*TrxIntMockSetStringExpectation

	callArgs []*TrxIntMockSetStringParams
	mutex    sync.RWMutex
}

// TrxIntMockSetStringExpectation specifies expectation struct of the trxInt.SetString
type TrxIntMockSetStringExpectation struct {
	mock    *TrxIntMock
	params  *TrxIntMockSetStringParams
	results *TrxIntMockSetStringResults
	Counter uint64
}

// TrxIntMockSetStringParams contains parameters of the trxInt.SetString
type TrxIntMockSetStringParams struct {
	block   *types.BlockID
	offset  uint32
	value   string
	okToLog bool
}

// TrxIntMockSetStringResults contains results of the trxInt.SetString
type TrxIntMockSetStringResults struct {
	err error
}

// Expect sets up expected params for trxInt.SetString
func (mmSetString *mTrxIntMockSetString) Expect(block *types.BlockID, offset uint32, value string, okToLog bool) *mTrxIntMockSetString {
	if mmSetString.mock.funcSetString != nil {
		mmSetString.mock.t.Fatalf("TrxIntMock.SetString mock is already set by Set")
	}

	if mmSetString.defaultExpectation == nil {
		mmSetString.defaultExpectation = &TrxIntMockSetStringExpectation{}
	}

	mmSetString.defaultExpectation.params = &TrxIntMockSetStringParams{block, offset, value, okToLog}
	for _, e := range mmSetString.expectations {
		if minimock.Equal(e.params, mmSetString.defaultExpectation.params) {
			mmSetString.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetString.defaultExpectation.params)
		}
	}

	return mmSetString
}

// Inspect accepts an inspector function that has same arguments as the trxInt.SetString
func (mmSetString *mTrxIntMockSetString) Inspect(f func(block *types.BlockID, offset uint32, value string, okToLog bool)) *mTrxIntMockSetString {
	if mmSetString.mock.inspectFuncSetString != nil {
		mmSetString.mock.t.Fatalf("Inspect function is already set for TrxIntMock.SetString")
	}

	mmSetString.mock.inspectFuncSetString = f

	return mmSetString
}

// Return sets up results that will be returned by trxInt.SetString
func (mmSetString *mTrxIntMockSetString) Return(err error) *TrxIntMock {
	if mmSetString.mock.funcSetString != nil {
		mmSetString.mock.t.Fatalf("TrxIntMock.SetString mock is already set by Set")
	}

	if mmSetString.defaultExpectation == nil {
		mmSetString.defaultExpectation = &TrxIntMockSetStringExpectation{mock: mmSetString.mock}
	}
	mmSetString.defaultExpectation.results = &TrxIntMockSetStringResults{err}
	return mmSetString.mock
}

//Set uses given function f to mock the trxInt.SetString method
func (mmSetString *mTrxIntMockSetString) Set(f func(block *types.BlockID, offset uint32, value string, okToLog bool) (err error)) *TrxIntMock {
	if mmSetString.defaultExpectation != nil {
		mmSetString.mock.t.Fatalf("Default expectation is already set for the trxInt.SetString method")
	}

	if len(mmSetString.expectations) > 0 {
		mmSetString.mock.t.Fatalf("Some expectations are already set for the trxInt.SetString method")
	}

	mmSetString.mock.funcSetString = f
	return mmSetString.mock
}

// When sets expectation for the trxInt.SetString which will trigger the result defined by the following
// Then helper
func (mmSetString *mTrxIntMockSetString) When(block *types.BlockID, offset uint32, value string, okToLog bool) *TrxIntMockSetStringExpectation {
	if mmSetString.mock.funcSetString != nil {
		mmSetString.mock.t.Fatalf("TrxIntMock.SetString mock is already set by Set")
	}

	expectation := &TrxIntMockSetStringExpectation{
		mock:   mmSetString.mock,
		params: &TrxIntMockSetStringParams{block, offset, value, okToLog},
	}
	mmSetString.expectations = append(mmSetString.expectations, expectation)
	return expectation
}

// Then sets up trxInt.SetString return parameters for the expectation previously defined by the When method
func (e *TrxIntMockSetStringExpectation) Then(err error) *TrxIntMock {
	e.results = &TrxIntMockSetStringResults{err}
	return e.mock
}

// SetString implements trxInt
func (mmSetString *TrxIntMock) SetString(block *types.BlockID, offset uint32, value string, okToLog bool) (err error) {
	mm_atomic.AddUint64(&mmSetString.beforeSetStringCounter, 1)
	defer mm_atomic.AddUint64(&mmSetString.afterSetStringCounter, 1)

	if mmSetString.inspectFuncSetString != nil {
		mmSetString.inspectFuncSetString(block, offset, value, okToLog)
	}

	mm_params := &TrxIntMockSetStringParams{block, offset, value, okToLog}

	// Record call args
	mmSetString.SetStringMock.mutex.Lock()
	mmSetString.SetStringMock.callArgs = append(mmSetString.SetStringMock.callArgs, mm_params)
	mmSetString.SetStringMock.mutex.Unlock()

	for _, e := range mmSetString.SetStringMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetString.SetStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetString.SetStringMock.defaultExpectation.Counter, 1)
		mm_want := mmSetString.SetStringMock.defaultExpectation.params
		mm_got := TrxIntMockSetStringParams{block, offset, value, okToLog}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetString.t.Errorf("TrxIntMock.SetString got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetString.SetStringMock.defaultExpectation.results
		if mm_results == nil {
			mmSetString.t.Fatal("No results are set for the TrxIntMock.SetString")
		}
		return (*mm_results).err
	}
	if mmSetString.funcSetString != nil {
		return mmSetString.funcSetString(block, offset, value, okToLog)
	}
	mmSetString.t.Fatalf("Unexpected call to TrxIntMock.SetString. %v %v %v %v", block, offset, value, okToLog)
	return
}

// SetStringAfterCounter returns a count of finished TrxIntMock.SetString invocations
func (mmSetString *TrxIntMock) SetStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetString.afterSetStringCounter)
}

// SetStringBeforeCounter returns a count of TrxIntMock.SetString invocations
func (mmSetString *TrxIntMock) SetStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetString.beforeSetStringCounter)
}

// Calls returns a list of arguments used in each call to TrxIntMock.SetString.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetString *mTrxIntMockSetString) Calls() []*TrxIntMockSetStringParams {
	mmSetString.mutex.RLock()

	argCopy := make([]*TrxIntMockSetStringParams, len(mmSetString.callArgs))
	copy(argCopy, mmSetString.callArgs)

	mmSetString.mutex.RUnlock()

	return argCopy
}

// MinimockSetStringDone returns true if the count of the SetString invocations corresponds
// the number of defined expectations
func (m *TrxIntMock) MinimockSetStringDone() bool {
	for _, e := range m.SetStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetString != nil && mm_atomic.LoadUint64(&m.afterSetStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetStringInspect logs each unmet expectation
func (m *TrxIntMock) MinimockSetStringInspect() {
	for _, e := range m.SetStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TrxIntMock.SetString with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStringCounter) < 1 {
		if m.SetStringMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TrxIntMock.SetString")
		} else {
			m.t.Errorf("Expected call to TrxIntMock.SetString with params: %#v", *m.SetStringMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetString != nil && mm_atomic.LoadUint64(&m.afterSetStringCounter) < 1 {
		m.t.Error("Expected call to TrxIntMock.SetString")
	}
}

type mTrxIntMockUnpin struct {
	mock               *TrxIntMock
	defaultExpectation *TrxIntMockUnpinExpectation
	expectations       []*TrxIntMockUnpinExpectation

	callArgs []*TrxIntMockUnpinParams
	mutex    sync.RWMutex
}

// TrxIntMockUnpinExpectation specifies expectation struct of the trxInt.Unpin
type TrxIntMockUnpinExpectation struct {
	mock    *TrxIntMock
	params  *TrxIntMockUnpinParams
	results *TrxIntMockUnpinResults
	Counter uint64
}

// TrxIntMockUnpinParams contains parameters of the trxInt.Unpin
type TrxIntMockUnpinParams struct {
	block *types.BlockID
}

// TrxIntMockUnpinResults contains results of the trxInt.Unpin
type TrxIntMockUnpinResults struct {
	err error
}

// Expect sets up expected params for trxInt.Unpin
func (mmUnpin *mTrxIntMockUnpin) Expect(block *types.BlockID) *mTrxIntMockUnpin {
	if mmUnpin.mock.funcUnpin != nil {
		mmUnpin.mock.t.Fatalf("TrxIntMock.Unpin mock is already set by Set")
	}

	if mmUnpin.defaultExpectation == nil {
		mmUnpin.defaultExpectation = &TrxIntMockUnpinExpectation{}
	}

	mmUnpin.defaultExpectation.params = &TrxIntMockUnpinParams{block}
	for _, e := range mmUnpin.expectations {
		if minimock.Equal(e.params, mmUnpin.defaultExpectation.params) {
			mmUnpin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnpin.defaultExpectation.params)
		}
	}

	return mmUnpin
}

// Inspect accepts an inspector function that has same arguments as the trxInt.Unpin
func (mmUnpin *mTrxIntMockUnpin) Inspect(f func(block *types.BlockID)) *mTrxIntMockUnpin {
	if mmUnpin.mock.inspectFuncUnpin != nil {
		mmUnpin.mock.t.Fatalf("Inspect function is already set for TrxIntMock.Unpin")
	}

	mmUnpin.mock.inspectFuncUnpin = f

	return mmUnpin
}

// Return sets up results that will be returned by trxInt.Unpin
func (mmUnpin *mTrxIntMockUnpin) Return(err error) *TrxIntMock {
	if mmUnpin.mock.funcUnpin != nil {
		mmUnpin.mock.t.Fatalf("TrxIntMock.Unpin mock is already set by Set")
	}

	if mmUnpin.defaultExpectation == nil {
		mmUnpin.defaultExpectation = &TrxIntMockUnpinExpectation{mock: mmUnpin.mock}
	}
	mmUnpin.defaultExpectation.results = &TrxIntMockUnpinResults{err}
	return mmUnpin.mock
}

//Set uses given function f to mock the trxInt.Unpin method
func (mmUnpin *mTrxIntMockUnpin) Set(f func(block *types.BlockID) (err error)) *TrxIntMock {
	if mmUnpin.defaultExpectation != nil {
		mmUnpin.mock.t.Fatalf("Default expectation is already set for the trxInt.Unpin method")
	}

	if len(mmUnpin.expectations) > 0 {
		mmUnpin.mock.t.Fatalf("Some expectations are already set for the trxInt.Unpin method")
	}

	mmUnpin.mock.funcUnpin = f
	return mmUnpin.mock
}

// When sets expectation for the trxInt.Unpin which will trigger the result defined by the following
// Then helper
func (mmUnpin *mTrxIntMockUnpin) When(block *types.BlockID) *TrxIntMockUnpinExpectation {
	if mmUnpin.mock.funcUnpin != nil {
		mmUnpin.mock.t.Fatalf("TrxIntMock.Unpin mock is already set by Set")
	}

	expectation := &TrxIntMockUnpinExpectation{
		mock:   mmUnpin.mock,
		params: &TrxIntMockUnpinParams{block},
	}
	mmUnpin.expectations = append(mmUnpin.expectations, expectation)
	return expectation
}

// Then sets up trxInt.Unpin return parameters for the expectation previously defined by the When method
func (e *TrxIntMockUnpinExpectation) Then(err error) *TrxIntMock {
	e.results = &TrxIntMockUnpinResults{err}
	return e.mock
}

// Unpin implements trxInt
func (mmUnpin *TrxIntMock) Unpin(block *types.BlockID) (err error) {
	mm_atomic.AddUint64(&mmUnpin.beforeUnpinCounter, 1)
	defer mm_atomic.AddUint64(&mmUnpin.afterUnpinCounter, 1)

	if mmUnpin.inspectFuncUnpin != nil {
		mmUnpin.inspectFuncUnpin(block)
	}

	mm_params := &TrxIntMockUnpinParams{block}

	// Record call args
	mmUnpin.UnpinMock.mutex.Lock()
	mmUnpin.UnpinMock.callArgs = append(mmUnpin.UnpinMock.callArgs, mm_params)
	mmUnpin.UnpinMock.mutex.Unlock()

	for _, e := range mmUnpin.UnpinMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUnpin.UnpinMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnpin.UnpinMock.defaultExpectation.Counter, 1)
		mm_want := mmUnpin.UnpinMock.defaultExpectation.params
		mm_got := TrxIntMockUnpinParams{block}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnpin.t.Errorf("TrxIntMock.Unpin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnpin.UnpinMock.defaultExpectation.results
		if mm_results == nil {
			mmUnpin.t.Fatal("No results are set for the TrxIntMock.Unpin")
		}
		return (*mm_results).err
	}
	if mmUnpin.funcUnpin != nil {
		return mmUnpin.funcUnpin(block)
	}
	mmUnpin.t.Fatalf("Unexpected call to TrxIntMock.Unpin. %v", block)
	return
}

// UnpinAfterCounter returns a count of finished TrxIntMock.Unpin invocations
func (mmUnpin *TrxIntMock) UnpinAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpin.afterUnpinCounter)
}

// UnpinBeforeCounter returns a count of TrxIntMock.Unpin invocations
func (mmUnpin *TrxIntMock) UnpinBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpin.beforeUnpinCounter)
}

// Calls returns a list of arguments used in each call to TrxIntMock.Unpin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnpin *mTrxIntMockUnpin) Calls() []*TrxIntMockUnpinParams {
	mmUnpin.mutex.RLock()

	argCopy := make([]*TrxIntMockUnpinParams, len(mmUnpin.callArgs))
	copy(argCopy, mmUnpin.callArgs)

	mmUnpin.mutex.RUnlock()

	return argCopy
}

// MinimockUnpinDone returns true if the count of the Unpin invocations corresponds
// the number of defined expectations
func (m *TrxIntMock) MinimockUnpinDone() bool {
	for _, e := range m.UnpinMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnpinMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnpinCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpin != nil && mm_atomic.LoadUint64(&m.afterUnpinCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnpinInspect logs each unmet expectation
func (m *TrxIntMock) MinimockUnpinInspect() {
	for _, e := range m.UnpinMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TrxIntMock.Unpin with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnpinMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnpinCounter) < 1 {
		if m.UnpinMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TrxIntMock.Unpin")
		} else {
			m.t.Errorf("Expected call to TrxIntMock.Unpin with params: %#v", *m.UnpinMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpin != nil && mm_atomic.LoadUint64(&m.afterUnpinCounter) < 1 {
		m.t.Error("Expected call to TrxIntMock.Unpin")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TrxIntMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockPinInspect()

		m.MinimockSetInt64Inspect()

		m.MinimockSetStringInspect()

		m.MinimockUnpinInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TrxIntMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TrxIntMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockPinDone() &&
		m.MinimockSetInt64Done() &&
		m.MinimockSetStringDone() &&
		m.MinimockUnpinDone()
}
