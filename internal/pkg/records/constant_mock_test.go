package records

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/unhandled-exception/sophiadb/internal/pkg/types.Constant -o ./constant_mock_test.go -n ConstantMock

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ConstantMock implements types.Constant
type ConstantMock struct {
	t minimock.Tester

	funcValue          func() (p1 interface{})
	inspectFuncValue   func()
	afterValueCounter  uint64
	beforeValueCounter uint64
	ValueMock          mConstantMockValue
}

// NewConstantMock returns a mock for types.Constant
func NewConstantMock(t minimock.Tester) *ConstantMock {
	m := &ConstantMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ValueMock = mConstantMockValue{mock: m}

	return m
}

type mConstantMockValue struct {
	mock               *ConstantMock
	defaultExpectation *ConstantMockValueExpectation
	expectations       []*ConstantMockValueExpectation
}

// ConstantMockValueExpectation specifies expectation struct of the Constant.Value
type ConstantMockValueExpectation struct {
	mock *ConstantMock

	results *ConstantMockValueResults
	Counter uint64
}

// ConstantMockValueResults contains results of the Constant.Value
type ConstantMockValueResults struct {
	p1 interface{}
}

// Expect sets up expected params for Constant.Value
func (mmValue *mConstantMockValue) Expect() *mConstantMockValue {
	if mmValue.mock.funcValue != nil {
		mmValue.mock.t.Fatalf("ConstantMock.Value mock is already set by Set")
	}

	if mmValue.defaultExpectation == nil {
		mmValue.defaultExpectation = &ConstantMockValueExpectation{}
	}

	return mmValue
}

// Inspect accepts an inspector function that has same arguments as the Constant.Value
func (mmValue *mConstantMockValue) Inspect(f func()) *mConstantMockValue {
	if mmValue.mock.inspectFuncValue != nil {
		mmValue.mock.t.Fatalf("Inspect function is already set for ConstantMock.Value")
	}

	mmValue.mock.inspectFuncValue = f

	return mmValue
}

// Return sets up results that will be returned by Constant.Value
func (mmValue *mConstantMockValue) Return(p1 interface{}) *ConstantMock {
	if mmValue.mock.funcValue != nil {
		mmValue.mock.t.Fatalf("ConstantMock.Value mock is already set by Set")
	}

	if mmValue.defaultExpectation == nil {
		mmValue.defaultExpectation = &ConstantMockValueExpectation{mock: mmValue.mock}
	}
	mmValue.defaultExpectation.results = &ConstantMockValueResults{p1}
	return mmValue.mock
}

//Set uses given function f to mock the Constant.Value method
func (mmValue *mConstantMockValue) Set(f func() (p1 interface{})) *ConstantMock {
	if mmValue.defaultExpectation != nil {
		mmValue.mock.t.Fatalf("Default expectation is already set for the Constant.Value method")
	}

	if len(mmValue.expectations) > 0 {
		mmValue.mock.t.Fatalf("Some expectations are already set for the Constant.Value method")
	}

	mmValue.mock.funcValue = f
	return mmValue.mock
}

// Value implements types.Constant
func (mmValue *ConstantMock) Value() (p1 interface{}) {
	mm_atomic.AddUint64(&mmValue.beforeValueCounter, 1)
	defer mm_atomic.AddUint64(&mmValue.afterValueCounter, 1)

	if mmValue.inspectFuncValue != nil {
		mmValue.inspectFuncValue()
	}

	if mmValue.ValueMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValue.ValueMock.defaultExpectation.Counter, 1)

		mm_results := mmValue.ValueMock.defaultExpectation.results
		if mm_results == nil {
			mmValue.t.Fatal("No results are set for the ConstantMock.Value")
		}
		return (*mm_results).p1
	}
	if mmValue.funcValue != nil {
		return mmValue.funcValue()
	}
	mmValue.t.Fatalf("Unexpected call to ConstantMock.Value.")
	return
}

// ValueAfterCounter returns a count of finished ConstantMock.Value invocations
func (mmValue *ConstantMock) ValueAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValue.afterValueCounter)
}

// ValueBeforeCounter returns a count of ConstantMock.Value invocations
func (mmValue *ConstantMock) ValueBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValue.beforeValueCounter)
}

// MinimockValueDone returns true if the count of the Value invocations corresponds
// the number of defined expectations
func (m *ConstantMock) MinimockValueDone() bool {
	for _, e := range m.ValueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ValueMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValue != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		return false
	}
	return true
}

// MinimockValueInspect logs each unmet expectation
func (m *ConstantMock) MinimockValueInspect() {
	for _, e := range m.ValueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConstantMock.Value")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ValueMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		m.t.Error("Expected call to ConstantMock.Value")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValue != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		m.t.Error("Expected call to ConstantMock.Value")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ConstantMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockValueInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ConstantMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ConstantMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockValueDone()
}
