package scan

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/unhandled-exception/sophiadb/pkg/scan.Constant -o ./constant_mock_test.go -n ConstantMock

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/unhandled-exception/sophiadb/pkg/records"
)

// ConstantMock implements Constant
type ConstantMock struct {
	t minimock.Tester

	funcType          func() (f1 records.FieldType)
	inspectFuncType   func()
	afterTypeCounter  uint64
	beforeTypeCounter uint64
	TypeMock          mConstantMockType

	funcValue          func() (p1 interface{})
	inspectFuncValue   func()
	afterValueCounter  uint64
	beforeValueCounter uint64
	ValueMock          mConstantMockValue
}

// NewConstantMock returns a mock for Constant
func NewConstantMock(t minimock.Tester) *ConstantMock {
	m := &ConstantMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.TypeMock = mConstantMockType{mock: m}

	m.ValueMock = mConstantMockValue{mock: m}

	return m
}

type mConstantMockType struct {
	mock               *ConstantMock
	defaultExpectation *ConstantMockTypeExpectation
	expectations       []*ConstantMockTypeExpectation
}

// ConstantMockTypeExpectation specifies expectation struct of the Constant.Type
type ConstantMockTypeExpectation struct {
	mock *ConstantMock

	results *ConstantMockTypeResults
	Counter uint64
}

// ConstantMockTypeResults contains results of the Constant.Type
type ConstantMockTypeResults struct {
	f1 records.FieldType
}

// Expect sets up expected params for Constant.Type
func (mmType *mConstantMockType) Expect() *mConstantMockType {
	if mmType.mock.funcType != nil {
		mmType.mock.t.Fatalf("ConstantMock.Type mock is already set by Set")
	}

	if mmType.defaultExpectation == nil {
		mmType.defaultExpectation = &ConstantMockTypeExpectation{}
	}

	return mmType
}

// Inspect accepts an inspector function that has same arguments as the Constant.Type
func (mmType *mConstantMockType) Inspect(f func()) *mConstantMockType {
	if mmType.mock.inspectFuncType != nil {
		mmType.mock.t.Fatalf("Inspect function is already set for ConstantMock.Type")
	}

	mmType.mock.inspectFuncType = f

	return mmType
}

// Return sets up results that will be returned by Constant.Type
func (mmType *mConstantMockType) Return(f1 records.FieldType) *ConstantMock {
	if mmType.mock.funcType != nil {
		mmType.mock.t.Fatalf("ConstantMock.Type mock is already set by Set")
	}

	if mmType.defaultExpectation == nil {
		mmType.defaultExpectation = &ConstantMockTypeExpectation{mock: mmType.mock}
	}
	mmType.defaultExpectation.results = &ConstantMockTypeResults{f1}
	return mmType.mock
}

//Set uses given function f to mock the Constant.Type method
func (mmType *mConstantMockType) Set(f func() (f1 records.FieldType)) *ConstantMock {
	if mmType.defaultExpectation != nil {
		mmType.mock.t.Fatalf("Default expectation is already set for the Constant.Type method")
	}

	if len(mmType.expectations) > 0 {
		mmType.mock.t.Fatalf("Some expectations are already set for the Constant.Type method")
	}

	mmType.mock.funcType = f
	return mmType.mock
}

// Type implements Constant
func (mmType *ConstantMock) Type() (f1 records.FieldType) {
	mm_atomic.AddUint64(&mmType.beforeTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmType.afterTypeCounter, 1)

	if mmType.inspectFuncType != nil {
		mmType.inspectFuncType()
	}

	if mmType.TypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmType.TypeMock.defaultExpectation.Counter, 1)

		mm_results := mmType.TypeMock.defaultExpectation.results
		if mm_results == nil {
			mmType.t.Fatal("No results are set for the ConstantMock.Type")
		}
		return (*mm_results).f1
	}
	if mmType.funcType != nil {
		return mmType.funcType()
	}
	mmType.t.Fatalf("Unexpected call to ConstantMock.Type.")
	return
}

// TypeAfterCounter returns a count of finished ConstantMock.Type invocations
func (mmType *ConstantMock) TypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmType.afterTypeCounter)
}

// TypeBeforeCounter returns a count of ConstantMock.Type invocations
func (mmType *ConstantMock) TypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmType.beforeTypeCounter)
}

// MinimockTypeDone returns true if the count of the Type invocations corresponds
// the number of defined expectations
func (m *ConstantMock) MinimockTypeDone() bool {
	for _, e := range m.TypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTypeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcType != nil && mm_atomic.LoadUint64(&m.afterTypeCounter) < 1 {
		return false
	}
	return true
}

// MinimockTypeInspect logs each unmet expectation
func (m *ConstantMock) MinimockTypeInspect() {
	for _, e := range m.TypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConstantMock.Type")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTypeCounter) < 1 {
		m.t.Error("Expected call to ConstantMock.Type")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcType != nil && mm_atomic.LoadUint64(&m.afterTypeCounter) < 1 {
		m.t.Error("Expected call to ConstantMock.Type")
	}
}

type mConstantMockValue struct {
	mock               *ConstantMock
	defaultExpectation *ConstantMockValueExpectation
	expectations       []*ConstantMockValueExpectation
}

// ConstantMockValueExpectation specifies expectation struct of the Constant.Value
type ConstantMockValueExpectation struct {
	mock *ConstantMock

	results *ConstantMockValueResults
	Counter uint64
}

// ConstantMockValueResults contains results of the Constant.Value
type ConstantMockValueResults struct {
	p1 interface{}
}

// Expect sets up expected params for Constant.Value
func (mmValue *mConstantMockValue) Expect() *mConstantMockValue {
	if mmValue.mock.funcValue != nil {
		mmValue.mock.t.Fatalf("ConstantMock.Value mock is already set by Set")
	}

	if mmValue.defaultExpectation == nil {
		mmValue.defaultExpectation = &ConstantMockValueExpectation{}
	}

	return mmValue
}

// Inspect accepts an inspector function that has same arguments as the Constant.Value
func (mmValue *mConstantMockValue) Inspect(f func()) *mConstantMockValue {
	if mmValue.mock.inspectFuncValue != nil {
		mmValue.mock.t.Fatalf("Inspect function is already set for ConstantMock.Value")
	}

	mmValue.mock.inspectFuncValue = f

	return mmValue
}

// Return sets up results that will be returned by Constant.Value
func (mmValue *mConstantMockValue) Return(p1 interface{}) *ConstantMock {
	if mmValue.mock.funcValue != nil {
		mmValue.mock.t.Fatalf("ConstantMock.Value mock is already set by Set")
	}

	if mmValue.defaultExpectation == nil {
		mmValue.defaultExpectation = &ConstantMockValueExpectation{mock: mmValue.mock}
	}
	mmValue.defaultExpectation.results = &ConstantMockValueResults{p1}
	return mmValue.mock
}

//Set uses given function f to mock the Constant.Value method
func (mmValue *mConstantMockValue) Set(f func() (p1 interface{})) *ConstantMock {
	if mmValue.defaultExpectation != nil {
		mmValue.mock.t.Fatalf("Default expectation is already set for the Constant.Value method")
	}

	if len(mmValue.expectations) > 0 {
		mmValue.mock.t.Fatalf("Some expectations are already set for the Constant.Value method")
	}

	mmValue.mock.funcValue = f
	return mmValue.mock
}

// Value implements Constant
func (mmValue *ConstantMock) Value() (p1 interface{}) {
	mm_atomic.AddUint64(&mmValue.beforeValueCounter, 1)
	defer mm_atomic.AddUint64(&mmValue.afterValueCounter, 1)

	if mmValue.inspectFuncValue != nil {
		mmValue.inspectFuncValue()
	}

	if mmValue.ValueMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValue.ValueMock.defaultExpectation.Counter, 1)

		mm_results := mmValue.ValueMock.defaultExpectation.results
		if mm_results == nil {
			mmValue.t.Fatal("No results are set for the ConstantMock.Value")
		}
		return (*mm_results).p1
	}
	if mmValue.funcValue != nil {
		return mmValue.funcValue()
	}
	mmValue.t.Fatalf("Unexpected call to ConstantMock.Value.")
	return
}

// ValueAfterCounter returns a count of finished ConstantMock.Value invocations
func (mmValue *ConstantMock) ValueAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValue.afterValueCounter)
}

// ValueBeforeCounter returns a count of ConstantMock.Value invocations
func (mmValue *ConstantMock) ValueBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValue.beforeValueCounter)
}

// MinimockValueDone returns true if the count of the Value invocations corresponds
// the number of defined expectations
func (m *ConstantMock) MinimockValueDone() bool {
	for _, e := range m.ValueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ValueMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValue != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		return false
	}
	return true
}

// MinimockValueInspect logs each unmet expectation
func (m *ConstantMock) MinimockValueInspect() {
	for _, e := range m.ValueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConstantMock.Value")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ValueMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		m.t.Error("Expected call to ConstantMock.Value")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValue != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		m.t.Error("Expected call to ConstantMock.Value")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ConstantMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockTypeInspect()

		m.MinimockValueInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ConstantMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ConstantMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockTypeDone() &&
		m.MinimockValueDone()
}
