package scan

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/unhandled-exception/sophiadb/pkg/scan.Scan -o ./scan_mock_test.go -n ScanMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/unhandled-exception/sophiadb/pkg/records"
)

// ScanMock implements Scan
type ScanMock struct {
	t minimock.Tester

	funcBeforeFirst          func() (err error)
	inspectFuncBeforeFirst   func()
	afterBeforeFirstCounter  uint64
	beforeBeforeFirstCounter uint64
	BeforeFirstMock          mScanMockBeforeFirst

	funcClose          func()
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mScanMockClose

	funcGetInt64          func(fieldName string) (i1 int64, err error)
	inspectFuncGetInt64   func(fieldName string)
	afterGetInt64Counter  uint64
	beforeGetInt64Counter uint64
	GetInt64Mock          mScanMockGetInt64

	funcGetInt8          func(fieldName string) (i1 int8, err error)
	inspectFuncGetInt8   func(fieldName string)
	afterGetInt8Counter  uint64
	beforeGetInt8Counter uint64
	GetInt8Mock          mScanMockGetInt8

	funcGetString          func(fieldName string) (s1 string, err error)
	inspectFuncGetString   func(fieldName string)
	afterGetStringCounter  uint64
	beforeGetStringCounter uint64
	GetStringMock          mScanMockGetString

	funcGetVal          func(fieldName string) (c1 Constant, err error)
	inspectFuncGetVal   func(fieldName string)
	afterGetValCounter  uint64
	beforeGetValCounter uint64
	GetValMock          mScanMockGetVal

	funcHasField          func(fieldName string) (b1 bool)
	inspectFuncHasField   func(fieldName string)
	afterHasFieldCounter  uint64
	beforeHasFieldCounter uint64
	HasFieldMock          mScanMockHasField

	funcNext          func() (b1 bool, err error)
	inspectFuncNext   func()
	afterNextCounter  uint64
	beforeNextCounter uint64
	NextMock          mScanMockNext

	funcSchema          func() (s1 records.Schema)
	inspectFuncSchema   func()
	afterSchemaCounter  uint64
	beforeSchemaCounter uint64
	SchemaMock          mScanMockSchema
}

// NewScanMock returns a mock for Scan
func NewScanMock(t minimock.Tester) *ScanMock {
	m := &ScanMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeforeFirstMock = mScanMockBeforeFirst{mock: m}

	m.CloseMock = mScanMockClose{mock: m}

	m.GetInt64Mock = mScanMockGetInt64{mock: m}
	m.GetInt64Mock.callArgs = []*ScanMockGetInt64Params{}

	m.GetInt8Mock = mScanMockGetInt8{mock: m}
	m.GetInt8Mock.callArgs = []*ScanMockGetInt8Params{}

	m.GetStringMock = mScanMockGetString{mock: m}
	m.GetStringMock.callArgs = []*ScanMockGetStringParams{}

	m.GetValMock = mScanMockGetVal{mock: m}
	m.GetValMock.callArgs = []*ScanMockGetValParams{}

	m.HasFieldMock = mScanMockHasField{mock: m}
	m.HasFieldMock.callArgs = []*ScanMockHasFieldParams{}

	m.NextMock = mScanMockNext{mock: m}

	m.SchemaMock = mScanMockSchema{mock: m}

	return m
}

type mScanMockBeforeFirst struct {
	mock               *ScanMock
	defaultExpectation *ScanMockBeforeFirstExpectation
	expectations       []*ScanMockBeforeFirstExpectation
}

// ScanMockBeforeFirstExpectation specifies expectation struct of the Scan.BeforeFirst
type ScanMockBeforeFirstExpectation struct {
	mock *ScanMock

	results *ScanMockBeforeFirstResults
	Counter uint64
}

// ScanMockBeforeFirstResults contains results of the Scan.BeforeFirst
type ScanMockBeforeFirstResults struct {
	err error
}

// Expect sets up expected params for Scan.BeforeFirst
func (mmBeforeFirst *mScanMockBeforeFirst) Expect() *mScanMockBeforeFirst {
	if mmBeforeFirst.mock.funcBeforeFirst != nil {
		mmBeforeFirst.mock.t.Fatalf("ScanMock.BeforeFirst mock is already set by Set")
	}

	if mmBeforeFirst.defaultExpectation == nil {
		mmBeforeFirst.defaultExpectation = &ScanMockBeforeFirstExpectation{}
	}

	return mmBeforeFirst
}

// Inspect accepts an inspector function that has same arguments as the Scan.BeforeFirst
func (mmBeforeFirst *mScanMockBeforeFirst) Inspect(f func()) *mScanMockBeforeFirst {
	if mmBeforeFirst.mock.inspectFuncBeforeFirst != nil {
		mmBeforeFirst.mock.t.Fatalf("Inspect function is already set for ScanMock.BeforeFirst")
	}

	mmBeforeFirst.mock.inspectFuncBeforeFirst = f

	return mmBeforeFirst
}

// Return sets up results that will be returned by Scan.BeforeFirst
func (mmBeforeFirst *mScanMockBeforeFirst) Return(err error) *ScanMock {
	if mmBeforeFirst.mock.funcBeforeFirst != nil {
		mmBeforeFirst.mock.t.Fatalf("ScanMock.BeforeFirst mock is already set by Set")
	}

	if mmBeforeFirst.defaultExpectation == nil {
		mmBeforeFirst.defaultExpectation = &ScanMockBeforeFirstExpectation{mock: mmBeforeFirst.mock}
	}
	mmBeforeFirst.defaultExpectation.results = &ScanMockBeforeFirstResults{err}
	return mmBeforeFirst.mock
}

//Set uses given function f to mock the Scan.BeforeFirst method
func (mmBeforeFirst *mScanMockBeforeFirst) Set(f func() (err error)) *ScanMock {
	if mmBeforeFirst.defaultExpectation != nil {
		mmBeforeFirst.mock.t.Fatalf("Default expectation is already set for the Scan.BeforeFirst method")
	}

	if len(mmBeforeFirst.expectations) > 0 {
		mmBeforeFirst.mock.t.Fatalf("Some expectations are already set for the Scan.BeforeFirst method")
	}

	mmBeforeFirst.mock.funcBeforeFirst = f
	return mmBeforeFirst.mock
}

// BeforeFirst implements Scan
func (mmBeforeFirst *ScanMock) BeforeFirst() (err error) {
	mm_atomic.AddUint64(&mmBeforeFirst.beforeBeforeFirstCounter, 1)
	defer mm_atomic.AddUint64(&mmBeforeFirst.afterBeforeFirstCounter, 1)

	if mmBeforeFirst.inspectFuncBeforeFirst != nil {
		mmBeforeFirst.inspectFuncBeforeFirst()
	}

	if mmBeforeFirst.BeforeFirstMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBeforeFirst.BeforeFirstMock.defaultExpectation.Counter, 1)

		mm_results := mmBeforeFirst.BeforeFirstMock.defaultExpectation.results
		if mm_results == nil {
			mmBeforeFirst.t.Fatal("No results are set for the ScanMock.BeforeFirst")
		}
		return (*mm_results).err
	}
	if mmBeforeFirst.funcBeforeFirst != nil {
		return mmBeforeFirst.funcBeforeFirst()
	}
	mmBeforeFirst.t.Fatalf("Unexpected call to ScanMock.BeforeFirst.")
	return
}

// BeforeFirstAfterCounter returns a count of finished ScanMock.BeforeFirst invocations
func (mmBeforeFirst *ScanMock) BeforeFirstAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeforeFirst.afterBeforeFirstCounter)
}

// BeforeFirstBeforeCounter returns a count of ScanMock.BeforeFirst invocations
func (mmBeforeFirst *ScanMock) BeforeFirstBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeforeFirst.beforeBeforeFirstCounter)
}

// MinimockBeforeFirstDone returns true if the count of the BeforeFirst invocations corresponds
// the number of defined expectations
func (m *ScanMock) MinimockBeforeFirstDone() bool {
	for _, e := range m.BeforeFirstMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeforeFirstMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeforeFirstCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeforeFirst != nil && mm_atomic.LoadUint64(&m.afterBeforeFirstCounter) < 1 {
		return false
	}
	return true
}

// MinimockBeforeFirstInspect logs each unmet expectation
func (m *ScanMock) MinimockBeforeFirstInspect() {
	for _, e := range m.BeforeFirstMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScanMock.BeforeFirst")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeforeFirstMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeforeFirstCounter) < 1 {
		m.t.Error("Expected call to ScanMock.BeforeFirst")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeforeFirst != nil && mm_atomic.LoadUint64(&m.afterBeforeFirstCounter) < 1 {
		m.t.Error("Expected call to ScanMock.BeforeFirst")
	}
}

type mScanMockClose struct {
	mock               *ScanMock
	defaultExpectation *ScanMockCloseExpectation
	expectations       []*ScanMockCloseExpectation
}

// ScanMockCloseExpectation specifies expectation struct of the Scan.Close
type ScanMockCloseExpectation struct {
	mock *ScanMock

	Counter uint64
}

// Expect sets up expected params for Scan.Close
func (mmClose *mScanMockClose) Expect() *mScanMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ScanMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ScanMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Scan.Close
func (mmClose *mScanMockClose) Inspect(f func()) *mScanMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for ScanMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Scan.Close
func (mmClose *mScanMockClose) Return() *ScanMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ScanMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ScanMockCloseExpectation{mock: mmClose.mock}
	}

	return mmClose.mock
}

//Set uses given function f to mock the Scan.Close method
func (mmClose *mScanMockClose) Set(f func()) *ScanMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Scan.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Scan.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Close implements Scan
func (mmClose *ScanMock) Close() {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		return

	}
	if mmClose.funcClose != nil {
		mmClose.funcClose()
		return
	}
	mmClose.t.Fatalf("Unexpected call to ScanMock.Close.")

}

// CloseAfterCounter returns a count of finished ScanMock.Close invocations
func (mmClose *ScanMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of ScanMock.Close invocations
func (mmClose *ScanMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *ScanMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *ScanMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScanMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to ScanMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to ScanMock.Close")
	}
}

type mScanMockGetInt64 struct {
	mock               *ScanMock
	defaultExpectation *ScanMockGetInt64Expectation
	expectations       []*ScanMockGetInt64Expectation

	callArgs []*ScanMockGetInt64Params
	mutex    sync.RWMutex
}

// ScanMockGetInt64Expectation specifies expectation struct of the Scan.GetInt64
type ScanMockGetInt64Expectation struct {
	mock    *ScanMock
	params  *ScanMockGetInt64Params
	results *ScanMockGetInt64Results
	Counter uint64
}

// ScanMockGetInt64Params contains parameters of the Scan.GetInt64
type ScanMockGetInt64Params struct {
	fieldName string
}

// ScanMockGetInt64Results contains results of the Scan.GetInt64
type ScanMockGetInt64Results struct {
	i1  int64
	err error
}

// Expect sets up expected params for Scan.GetInt64
func (mmGetInt64 *mScanMockGetInt64) Expect(fieldName string) *mScanMockGetInt64 {
	if mmGetInt64.mock.funcGetInt64 != nil {
		mmGetInt64.mock.t.Fatalf("ScanMock.GetInt64 mock is already set by Set")
	}

	if mmGetInt64.defaultExpectation == nil {
		mmGetInt64.defaultExpectation = &ScanMockGetInt64Expectation{}
	}

	mmGetInt64.defaultExpectation.params = &ScanMockGetInt64Params{fieldName}
	for _, e := range mmGetInt64.expectations {
		if minimock.Equal(e.params, mmGetInt64.defaultExpectation.params) {
			mmGetInt64.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetInt64.defaultExpectation.params)
		}
	}

	return mmGetInt64
}

// Inspect accepts an inspector function that has same arguments as the Scan.GetInt64
func (mmGetInt64 *mScanMockGetInt64) Inspect(f func(fieldName string)) *mScanMockGetInt64 {
	if mmGetInt64.mock.inspectFuncGetInt64 != nil {
		mmGetInt64.mock.t.Fatalf("Inspect function is already set for ScanMock.GetInt64")
	}

	mmGetInt64.mock.inspectFuncGetInt64 = f

	return mmGetInt64
}

// Return sets up results that will be returned by Scan.GetInt64
func (mmGetInt64 *mScanMockGetInt64) Return(i1 int64, err error) *ScanMock {
	if mmGetInt64.mock.funcGetInt64 != nil {
		mmGetInt64.mock.t.Fatalf("ScanMock.GetInt64 mock is already set by Set")
	}

	if mmGetInt64.defaultExpectation == nil {
		mmGetInt64.defaultExpectation = &ScanMockGetInt64Expectation{mock: mmGetInt64.mock}
	}
	mmGetInt64.defaultExpectation.results = &ScanMockGetInt64Results{i1, err}
	return mmGetInt64.mock
}

//Set uses given function f to mock the Scan.GetInt64 method
func (mmGetInt64 *mScanMockGetInt64) Set(f func(fieldName string) (i1 int64, err error)) *ScanMock {
	if mmGetInt64.defaultExpectation != nil {
		mmGetInt64.mock.t.Fatalf("Default expectation is already set for the Scan.GetInt64 method")
	}

	if len(mmGetInt64.expectations) > 0 {
		mmGetInt64.mock.t.Fatalf("Some expectations are already set for the Scan.GetInt64 method")
	}

	mmGetInt64.mock.funcGetInt64 = f
	return mmGetInt64.mock
}

// When sets expectation for the Scan.GetInt64 which will trigger the result defined by the following
// Then helper
func (mmGetInt64 *mScanMockGetInt64) When(fieldName string) *ScanMockGetInt64Expectation {
	if mmGetInt64.mock.funcGetInt64 != nil {
		mmGetInt64.mock.t.Fatalf("ScanMock.GetInt64 mock is already set by Set")
	}

	expectation := &ScanMockGetInt64Expectation{
		mock:   mmGetInt64.mock,
		params: &ScanMockGetInt64Params{fieldName},
	}
	mmGetInt64.expectations = append(mmGetInt64.expectations, expectation)
	return expectation
}

// Then sets up Scan.GetInt64 return parameters for the expectation previously defined by the When method
func (e *ScanMockGetInt64Expectation) Then(i1 int64, err error) *ScanMock {
	e.results = &ScanMockGetInt64Results{i1, err}
	return e.mock
}

// GetInt64 implements Scan
func (mmGetInt64 *ScanMock) GetInt64(fieldName string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetInt64.beforeGetInt64Counter, 1)
	defer mm_atomic.AddUint64(&mmGetInt64.afterGetInt64Counter, 1)

	if mmGetInt64.inspectFuncGetInt64 != nil {
		mmGetInt64.inspectFuncGetInt64(fieldName)
	}

	mm_params := &ScanMockGetInt64Params{fieldName}

	// Record call args
	mmGetInt64.GetInt64Mock.mutex.Lock()
	mmGetInt64.GetInt64Mock.callArgs = append(mmGetInt64.GetInt64Mock.callArgs, mm_params)
	mmGetInt64.GetInt64Mock.mutex.Unlock()

	for _, e := range mmGetInt64.GetInt64Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetInt64.GetInt64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetInt64.GetInt64Mock.defaultExpectation.Counter, 1)
		mm_want := mmGetInt64.GetInt64Mock.defaultExpectation.params
		mm_got := ScanMockGetInt64Params{fieldName}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetInt64.t.Errorf("ScanMock.GetInt64 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetInt64.GetInt64Mock.defaultExpectation.results
		if mm_results == nil {
			mmGetInt64.t.Fatal("No results are set for the ScanMock.GetInt64")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetInt64.funcGetInt64 != nil {
		return mmGetInt64.funcGetInt64(fieldName)
	}
	mmGetInt64.t.Fatalf("Unexpected call to ScanMock.GetInt64. %v", fieldName)
	return
}

// GetInt64AfterCounter returns a count of finished ScanMock.GetInt64 invocations
func (mmGetInt64 *ScanMock) GetInt64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInt64.afterGetInt64Counter)
}

// GetInt64BeforeCounter returns a count of ScanMock.GetInt64 invocations
func (mmGetInt64 *ScanMock) GetInt64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInt64.beforeGetInt64Counter)
}

// Calls returns a list of arguments used in each call to ScanMock.GetInt64.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetInt64 *mScanMockGetInt64) Calls() []*ScanMockGetInt64Params {
	mmGetInt64.mutex.RLock()

	argCopy := make([]*ScanMockGetInt64Params, len(mmGetInt64.callArgs))
	copy(argCopy, mmGetInt64.callArgs)

	mmGetInt64.mutex.RUnlock()

	return argCopy
}

// MinimockGetInt64Done returns true if the count of the GetInt64 invocations corresponds
// the number of defined expectations
func (m *ScanMock) MinimockGetInt64Done() bool {
	for _, e := range m.GetInt64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetInt64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetInt64Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetInt64 != nil && mm_atomic.LoadUint64(&m.afterGetInt64Counter) < 1 {
		return false
	}
	return true
}

// MinimockGetInt64Inspect logs each unmet expectation
func (m *ScanMock) MinimockGetInt64Inspect() {
	for _, e := range m.GetInt64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScanMock.GetInt64 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetInt64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetInt64Counter) < 1 {
		if m.GetInt64Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScanMock.GetInt64")
		} else {
			m.t.Errorf("Expected call to ScanMock.GetInt64 with params: %#v", *m.GetInt64Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetInt64 != nil && mm_atomic.LoadUint64(&m.afterGetInt64Counter) < 1 {
		m.t.Error("Expected call to ScanMock.GetInt64")
	}
}

type mScanMockGetInt8 struct {
	mock               *ScanMock
	defaultExpectation *ScanMockGetInt8Expectation
	expectations       []*ScanMockGetInt8Expectation

	callArgs []*ScanMockGetInt8Params
	mutex    sync.RWMutex
}

// ScanMockGetInt8Expectation specifies expectation struct of the Scan.GetInt8
type ScanMockGetInt8Expectation struct {
	mock    *ScanMock
	params  *ScanMockGetInt8Params
	results *ScanMockGetInt8Results
	Counter uint64
}

// ScanMockGetInt8Params contains parameters of the Scan.GetInt8
type ScanMockGetInt8Params struct {
	fieldName string
}

// ScanMockGetInt8Results contains results of the Scan.GetInt8
type ScanMockGetInt8Results struct {
	i1  int8
	err error
}

// Expect sets up expected params for Scan.GetInt8
func (mmGetInt8 *mScanMockGetInt8) Expect(fieldName string) *mScanMockGetInt8 {
	if mmGetInt8.mock.funcGetInt8 != nil {
		mmGetInt8.mock.t.Fatalf("ScanMock.GetInt8 mock is already set by Set")
	}

	if mmGetInt8.defaultExpectation == nil {
		mmGetInt8.defaultExpectation = &ScanMockGetInt8Expectation{}
	}

	mmGetInt8.defaultExpectation.params = &ScanMockGetInt8Params{fieldName}
	for _, e := range mmGetInt8.expectations {
		if minimock.Equal(e.params, mmGetInt8.defaultExpectation.params) {
			mmGetInt8.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetInt8.defaultExpectation.params)
		}
	}

	return mmGetInt8
}

// Inspect accepts an inspector function that has same arguments as the Scan.GetInt8
func (mmGetInt8 *mScanMockGetInt8) Inspect(f func(fieldName string)) *mScanMockGetInt8 {
	if mmGetInt8.mock.inspectFuncGetInt8 != nil {
		mmGetInt8.mock.t.Fatalf("Inspect function is already set for ScanMock.GetInt8")
	}

	mmGetInt8.mock.inspectFuncGetInt8 = f

	return mmGetInt8
}

// Return sets up results that will be returned by Scan.GetInt8
func (mmGetInt8 *mScanMockGetInt8) Return(i1 int8, err error) *ScanMock {
	if mmGetInt8.mock.funcGetInt8 != nil {
		mmGetInt8.mock.t.Fatalf("ScanMock.GetInt8 mock is already set by Set")
	}

	if mmGetInt8.defaultExpectation == nil {
		mmGetInt8.defaultExpectation = &ScanMockGetInt8Expectation{mock: mmGetInt8.mock}
	}
	mmGetInt8.defaultExpectation.results = &ScanMockGetInt8Results{i1, err}
	return mmGetInt8.mock
}

//Set uses given function f to mock the Scan.GetInt8 method
func (mmGetInt8 *mScanMockGetInt8) Set(f func(fieldName string) (i1 int8, err error)) *ScanMock {
	if mmGetInt8.defaultExpectation != nil {
		mmGetInt8.mock.t.Fatalf("Default expectation is already set for the Scan.GetInt8 method")
	}

	if len(mmGetInt8.expectations) > 0 {
		mmGetInt8.mock.t.Fatalf("Some expectations are already set for the Scan.GetInt8 method")
	}

	mmGetInt8.mock.funcGetInt8 = f
	return mmGetInt8.mock
}

// When sets expectation for the Scan.GetInt8 which will trigger the result defined by the following
// Then helper
func (mmGetInt8 *mScanMockGetInt8) When(fieldName string) *ScanMockGetInt8Expectation {
	if mmGetInt8.mock.funcGetInt8 != nil {
		mmGetInt8.mock.t.Fatalf("ScanMock.GetInt8 mock is already set by Set")
	}

	expectation := &ScanMockGetInt8Expectation{
		mock:   mmGetInt8.mock,
		params: &ScanMockGetInt8Params{fieldName},
	}
	mmGetInt8.expectations = append(mmGetInt8.expectations, expectation)
	return expectation
}

// Then sets up Scan.GetInt8 return parameters for the expectation previously defined by the When method
func (e *ScanMockGetInt8Expectation) Then(i1 int8, err error) *ScanMock {
	e.results = &ScanMockGetInt8Results{i1, err}
	return e.mock
}

// GetInt8 implements Scan
func (mmGetInt8 *ScanMock) GetInt8(fieldName string) (i1 int8, err error) {
	mm_atomic.AddUint64(&mmGetInt8.beforeGetInt8Counter, 1)
	defer mm_atomic.AddUint64(&mmGetInt8.afterGetInt8Counter, 1)

	if mmGetInt8.inspectFuncGetInt8 != nil {
		mmGetInt8.inspectFuncGetInt8(fieldName)
	}

	mm_params := &ScanMockGetInt8Params{fieldName}

	// Record call args
	mmGetInt8.GetInt8Mock.mutex.Lock()
	mmGetInt8.GetInt8Mock.callArgs = append(mmGetInt8.GetInt8Mock.callArgs, mm_params)
	mmGetInt8.GetInt8Mock.mutex.Unlock()

	for _, e := range mmGetInt8.GetInt8Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetInt8.GetInt8Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetInt8.GetInt8Mock.defaultExpectation.Counter, 1)
		mm_want := mmGetInt8.GetInt8Mock.defaultExpectation.params
		mm_got := ScanMockGetInt8Params{fieldName}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetInt8.t.Errorf("ScanMock.GetInt8 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetInt8.GetInt8Mock.defaultExpectation.results
		if mm_results == nil {
			mmGetInt8.t.Fatal("No results are set for the ScanMock.GetInt8")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetInt8.funcGetInt8 != nil {
		return mmGetInt8.funcGetInt8(fieldName)
	}
	mmGetInt8.t.Fatalf("Unexpected call to ScanMock.GetInt8. %v", fieldName)
	return
}

// GetInt8AfterCounter returns a count of finished ScanMock.GetInt8 invocations
func (mmGetInt8 *ScanMock) GetInt8AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInt8.afterGetInt8Counter)
}

// GetInt8BeforeCounter returns a count of ScanMock.GetInt8 invocations
func (mmGetInt8 *ScanMock) GetInt8BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInt8.beforeGetInt8Counter)
}

// Calls returns a list of arguments used in each call to ScanMock.GetInt8.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetInt8 *mScanMockGetInt8) Calls() []*ScanMockGetInt8Params {
	mmGetInt8.mutex.RLock()

	argCopy := make([]*ScanMockGetInt8Params, len(mmGetInt8.callArgs))
	copy(argCopy, mmGetInt8.callArgs)

	mmGetInt8.mutex.RUnlock()

	return argCopy
}

// MinimockGetInt8Done returns true if the count of the GetInt8 invocations corresponds
// the number of defined expectations
func (m *ScanMock) MinimockGetInt8Done() bool {
	for _, e := range m.GetInt8Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetInt8Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetInt8Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetInt8 != nil && mm_atomic.LoadUint64(&m.afterGetInt8Counter) < 1 {
		return false
	}
	return true
}

// MinimockGetInt8Inspect logs each unmet expectation
func (m *ScanMock) MinimockGetInt8Inspect() {
	for _, e := range m.GetInt8Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScanMock.GetInt8 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetInt8Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetInt8Counter) < 1 {
		if m.GetInt8Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScanMock.GetInt8")
		} else {
			m.t.Errorf("Expected call to ScanMock.GetInt8 with params: %#v", *m.GetInt8Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetInt8 != nil && mm_atomic.LoadUint64(&m.afterGetInt8Counter) < 1 {
		m.t.Error("Expected call to ScanMock.GetInt8")
	}
}

type mScanMockGetString struct {
	mock               *ScanMock
	defaultExpectation *ScanMockGetStringExpectation
	expectations       []*ScanMockGetStringExpectation

	callArgs []*ScanMockGetStringParams
	mutex    sync.RWMutex
}

// ScanMockGetStringExpectation specifies expectation struct of the Scan.GetString
type ScanMockGetStringExpectation struct {
	mock    *ScanMock
	params  *ScanMockGetStringParams
	results *ScanMockGetStringResults
	Counter uint64
}

// ScanMockGetStringParams contains parameters of the Scan.GetString
type ScanMockGetStringParams struct {
	fieldName string
}

// ScanMockGetStringResults contains results of the Scan.GetString
type ScanMockGetStringResults struct {
	s1  string
	err error
}

// Expect sets up expected params for Scan.GetString
func (mmGetString *mScanMockGetString) Expect(fieldName string) *mScanMockGetString {
	if mmGetString.mock.funcGetString != nil {
		mmGetString.mock.t.Fatalf("ScanMock.GetString mock is already set by Set")
	}

	if mmGetString.defaultExpectation == nil {
		mmGetString.defaultExpectation = &ScanMockGetStringExpectation{}
	}

	mmGetString.defaultExpectation.params = &ScanMockGetStringParams{fieldName}
	for _, e := range mmGetString.expectations {
		if minimock.Equal(e.params, mmGetString.defaultExpectation.params) {
			mmGetString.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetString.defaultExpectation.params)
		}
	}

	return mmGetString
}

// Inspect accepts an inspector function that has same arguments as the Scan.GetString
func (mmGetString *mScanMockGetString) Inspect(f func(fieldName string)) *mScanMockGetString {
	if mmGetString.mock.inspectFuncGetString != nil {
		mmGetString.mock.t.Fatalf("Inspect function is already set for ScanMock.GetString")
	}

	mmGetString.mock.inspectFuncGetString = f

	return mmGetString
}

// Return sets up results that will be returned by Scan.GetString
func (mmGetString *mScanMockGetString) Return(s1 string, err error) *ScanMock {
	if mmGetString.mock.funcGetString != nil {
		mmGetString.mock.t.Fatalf("ScanMock.GetString mock is already set by Set")
	}

	if mmGetString.defaultExpectation == nil {
		mmGetString.defaultExpectation = &ScanMockGetStringExpectation{mock: mmGetString.mock}
	}
	mmGetString.defaultExpectation.results = &ScanMockGetStringResults{s1, err}
	return mmGetString.mock
}

//Set uses given function f to mock the Scan.GetString method
func (mmGetString *mScanMockGetString) Set(f func(fieldName string) (s1 string, err error)) *ScanMock {
	if mmGetString.defaultExpectation != nil {
		mmGetString.mock.t.Fatalf("Default expectation is already set for the Scan.GetString method")
	}

	if len(mmGetString.expectations) > 0 {
		mmGetString.mock.t.Fatalf("Some expectations are already set for the Scan.GetString method")
	}

	mmGetString.mock.funcGetString = f
	return mmGetString.mock
}

// When sets expectation for the Scan.GetString which will trigger the result defined by the following
// Then helper
func (mmGetString *mScanMockGetString) When(fieldName string) *ScanMockGetStringExpectation {
	if mmGetString.mock.funcGetString != nil {
		mmGetString.mock.t.Fatalf("ScanMock.GetString mock is already set by Set")
	}

	expectation := &ScanMockGetStringExpectation{
		mock:   mmGetString.mock,
		params: &ScanMockGetStringParams{fieldName},
	}
	mmGetString.expectations = append(mmGetString.expectations, expectation)
	return expectation
}

// Then sets up Scan.GetString return parameters for the expectation previously defined by the When method
func (e *ScanMockGetStringExpectation) Then(s1 string, err error) *ScanMock {
	e.results = &ScanMockGetStringResults{s1, err}
	return e.mock
}

// GetString implements Scan
func (mmGetString *ScanMock) GetString(fieldName string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetString.beforeGetStringCounter, 1)
	defer mm_atomic.AddUint64(&mmGetString.afterGetStringCounter, 1)

	if mmGetString.inspectFuncGetString != nil {
		mmGetString.inspectFuncGetString(fieldName)
	}

	mm_params := &ScanMockGetStringParams{fieldName}

	// Record call args
	mmGetString.GetStringMock.mutex.Lock()
	mmGetString.GetStringMock.callArgs = append(mmGetString.GetStringMock.callArgs, mm_params)
	mmGetString.GetStringMock.mutex.Unlock()

	for _, e := range mmGetString.GetStringMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetString.GetStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetString.GetStringMock.defaultExpectation.Counter, 1)
		mm_want := mmGetString.GetStringMock.defaultExpectation.params
		mm_got := ScanMockGetStringParams{fieldName}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetString.t.Errorf("ScanMock.GetString got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetString.GetStringMock.defaultExpectation.results
		if mm_results == nil {
			mmGetString.t.Fatal("No results are set for the ScanMock.GetString")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetString.funcGetString != nil {
		return mmGetString.funcGetString(fieldName)
	}
	mmGetString.t.Fatalf("Unexpected call to ScanMock.GetString. %v", fieldName)
	return
}

// GetStringAfterCounter returns a count of finished ScanMock.GetString invocations
func (mmGetString *ScanMock) GetStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetString.afterGetStringCounter)
}

// GetStringBeforeCounter returns a count of ScanMock.GetString invocations
func (mmGetString *ScanMock) GetStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetString.beforeGetStringCounter)
}

// Calls returns a list of arguments used in each call to ScanMock.GetString.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetString *mScanMockGetString) Calls() []*ScanMockGetStringParams {
	mmGetString.mutex.RLock()

	argCopy := make([]*ScanMockGetStringParams, len(mmGetString.callArgs))
	copy(argCopy, mmGetString.callArgs)

	mmGetString.mutex.RUnlock()

	return argCopy
}

// MinimockGetStringDone returns true if the count of the GetString invocations corresponds
// the number of defined expectations
func (m *ScanMock) MinimockGetStringDone() bool {
	for _, e := range m.GetStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetString != nil && mm_atomic.LoadUint64(&m.afterGetStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetStringInspect logs each unmet expectation
func (m *ScanMock) MinimockGetStringInspect() {
	for _, e := range m.GetStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScanMock.GetString with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStringCounter) < 1 {
		if m.GetStringMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScanMock.GetString")
		} else {
			m.t.Errorf("Expected call to ScanMock.GetString with params: %#v", *m.GetStringMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetString != nil && mm_atomic.LoadUint64(&m.afterGetStringCounter) < 1 {
		m.t.Error("Expected call to ScanMock.GetString")
	}
}

type mScanMockGetVal struct {
	mock               *ScanMock
	defaultExpectation *ScanMockGetValExpectation
	expectations       []*ScanMockGetValExpectation

	callArgs []*ScanMockGetValParams
	mutex    sync.RWMutex
}

// ScanMockGetValExpectation specifies expectation struct of the Scan.GetVal
type ScanMockGetValExpectation struct {
	mock    *ScanMock
	params  *ScanMockGetValParams
	results *ScanMockGetValResults
	Counter uint64
}

// ScanMockGetValParams contains parameters of the Scan.GetVal
type ScanMockGetValParams struct {
	fieldName string
}

// ScanMockGetValResults contains results of the Scan.GetVal
type ScanMockGetValResults struct {
	c1  Constant
	err error
}

// Expect sets up expected params for Scan.GetVal
func (mmGetVal *mScanMockGetVal) Expect(fieldName string) *mScanMockGetVal {
	if mmGetVal.mock.funcGetVal != nil {
		mmGetVal.mock.t.Fatalf("ScanMock.GetVal mock is already set by Set")
	}

	if mmGetVal.defaultExpectation == nil {
		mmGetVal.defaultExpectation = &ScanMockGetValExpectation{}
	}

	mmGetVal.defaultExpectation.params = &ScanMockGetValParams{fieldName}
	for _, e := range mmGetVal.expectations {
		if minimock.Equal(e.params, mmGetVal.defaultExpectation.params) {
			mmGetVal.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetVal.defaultExpectation.params)
		}
	}

	return mmGetVal
}

// Inspect accepts an inspector function that has same arguments as the Scan.GetVal
func (mmGetVal *mScanMockGetVal) Inspect(f func(fieldName string)) *mScanMockGetVal {
	if mmGetVal.mock.inspectFuncGetVal != nil {
		mmGetVal.mock.t.Fatalf("Inspect function is already set for ScanMock.GetVal")
	}

	mmGetVal.mock.inspectFuncGetVal = f

	return mmGetVal
}

// Return sets up results that will be returned by Scan.GetVal
func (mmGetVal *mScanMockGetVal) Return(c1 Constant, err error) *ScanMock {
	if mmGetVal.mock.funcGetVal != nil {
		mmGetVal.mock.t.Fatalf("ScanMock.GetVal mock is already set by Set")
	}

	if mmGetVal.defaultExpectation == nil {
		mmGetVal.defaultExpectation = &ScanMockGetValExpectation{mock: mmGetVal.mock}
	}
	mmGetVal.defaultExpectation.results = &ScanMockGetValResults{c1, err}
	return mmGetVal.mock
}

//Set uses given function f to mock the Scan.GetVal method
func (mmGetVal *mScanMockGetVal) Set(f func(fieldName string) (c1 Constant, err error)) *ScanMock {
	if mmGetVal.defaultExpectation != nil {
		mmGetVal.mock.t.Fatalf("Default expectation is already set for the Scan.GetVal method")
	}

	if len(mmGetVal.expectations) > 0 {
		mmGetVal.mock.t.Fatalf("Some expectations are already set for the Scan.GetVal method")
	}

	mmGetVal.mock.funcGetVal = f
	return mmGetVal.mock
}

// When sets expectation for the Scan.GetVal which will trigger the result defined by the following
// Then helper
func (mmGetVal *mScanMockGetVal) When(fieldName string) *ScanMockGetValExpectation {
	if mmGetVal.mock.funcGetVal != nil {
		mmGetVal.mock.t.Fatalf("ScanMock.GetVal mock is already set by Set")
	}

	expectation := &ScanMockGetValExpectation{
		mock:   mmGetVal.mock,
		params: &ScanMockGetValParams{fieldName},
	}
	mmGetVal.expectations = append(mmGetVal.expectations, expectation)
	return expectation
}

// Then sets up Scan.GetVal return parameters for the expectation previously defined by the When method
func (e *ScanMockGetValExpectation) Then(c1 Constant, err error) *ScanMock {
	e.results = &ScanMockGetValResults{c1, err}
	return e.mock
}

// GetVal implements Scan
func (mmGetVal *ScanMock) GetVal(fieldName string) (c1 Constant, err error) {
	mm_atomic.AddUint64(&mmGetVal.beforeGetValCounter, 1)
	defer mm_atomic.AddUint64(&mmGetVal.afterGetValCounter, 1)

	if mmGetVal.inspectFuncGetVal != nil {
		mmGetVal.inspectFuncGetVal(fieldName)
	}

	mm_params := &ScanMockGetValParams{fieldName}

	// Record call args
	mmGetVal.GetValMock.mutex.Lock()
	mmGetVal.GetValMock.callArgs = append(mmGetVal.GetValMock.callArgs, mm_params)
	mmGetVal.GetValMock.mutex.Unlock()

	for _, e := range mmGetVal.GetValMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c1, e.results.err
		}
	}

	if mmGetVal.GetValMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetVal.GetValMock.defaultExpectation.Counter, 1)
		mm_want := mmGetVal.GetValMock.defaultExpectation.params
		mm_got := ScanMockGetValParams{fieldName}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetVal.t.Errorf("ScanMock.GetVal got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetVal.GetValMock.defaultExpectation.results
		if mm_results == nil {
			mmGetVal.t.Fatal("No results are set for the ScanMock.GetVal")
		}
		return (*mm_results).c1, (*mm_results).err
	}
	if mmGetVal.funcGetVal != nil {
		return mmGetVal.funcGetVal(fieldName)
	}
	mmGetVal.t.Fatalf("Unexpected call to ScanMock.GetVal. %v", fieldName)
	return
}

// GetValAfterCounter returns a count of finished ScanMock.GetVal invocations
func (mmGetVal *ScanMock) GetValAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetVal.afterGetValCounter)
}

// GetValBeforeCounter returns a count of ScanMock.GetVal invocations
func (mmGetVal *ScanMock) GetValBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetVal.beforeGetValCounter)
}

// Calls returns a list of arguments used in each call to ScanMock.GetVal.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetVal *mScanMockGetVal) Calls() []*ScanMockGetValParams {
	mmGetVal.mutex.RLock()

	argCopy := make([]*ScanMockGetValParams, len(mmGetVal.callArgs))
	copy(argCopy, mmGetVal.callArgs)

	mmGetVal.mutex.RUnlock()

	return argCopy
}

// MinimockGetValDone returns true if the count of the GetVal invocations corresponds
// the number of defined expectations
func (m *ScanMock) MinimockGetValDone() bool {
	for _, e := range m.GetValMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetValMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetValCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetVal != nil && mm_atomic.LoadUint64(&m.afterGetValCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetValInspect logs each unmet expectation
func (m *ScanMock) MinimockGetValInspect() {
	for _, e := range m.GetValMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScanMock.GetVal with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetValMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetValCounter) < 1 {
		if m.GetValMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScanMock.GetVal")
		} else {
			m.t.Errorf("Expected call to ScanMock.GetVal with params: %#v", *m.GetValMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetVal != nil && mm_atomic.LoadUint64(&m.afterGetValCounter) < 1 {
		m.t.Error("Expected call to ScanMock.GetVal")
	}
}

type mScanMockHasField struct {
	mock               *ScanMock
	defaultExpectation *ScanMockHasFieldExpectation
	expectations       []*ScanMockHasFieldExpectation

	callArgs []*ScanMockHasFieldParams
	mutex    sync.RWMutex
}

// ScanMockHasFieldExpectation specifies expectation struct of the Scan.HasField
type ScanMockHasFieldExpectation struct {
	mock    *ScanMock
	params  *ScanMockHasFieldParams
	results *ScanMockHasFieldResults
	Counter uint64
}

// ScanMockHasFieldParams contains parameters of the Scan.HasField
type ScanMockHasFieldParams struct {
	fieldName string
}

// ScanMockHasFieldResults contains results of the Scan.HasField
type ScanMockHasFieldResults struct {
	b1 bool
}

// Expect sets up expected params for Scan.HasField
func (mmHasField *mScanMockHasField) Expect(fieldName string) *mScanMockHasField {
	if mmHasField.mock.funcHasField != nil {
		mmHasField.mock.t.Fatalf("ScanMock.HasField mock is already set by Set")
	}

	if mmHasField.defaultExpectation == nil {
		mmHasField.defaultExpectation = &ScanMockHasFieldExpectation{}
	}

	mmHasField.defaultExpectation.params = &ScanMockHasFieldParams{fieldName}
	for _, e := range mmHasField.expectations {
		if minimock.Equal(e.params, mmHasField.defaultExpectation.params) {
			mmHasField.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHasField.defaultExpectation.params)
		}
	}

	return mmHasField
}

// Inspect accepts an inspector function that has same arguments as the Scan.HasField
func (mmHasField *mScanMockHasField) Inspect(f func(fieldName string)) *mScanMockHasField {
	if mmHasField.mock.inspectFuncHasField != nil {
		mmHasField.mock.t.Fatalf("Inspect function is already set for ScanMock.HasField")
	}

	mmHasField.mock.inspectFuncHasField = f

	return mmHasField
}

// Return sets up results that will be returned by Scan.HasField
func (mmHasField *mScanMockHasField) Return(b1 bool) *ScanMock {
	if mmHasField.mock.funcHasField != nil {
		mmHasField.mock.t.Fatalf("ScanMock.HasField mock is already set by Set")
	}

	if mmHasField.defaultExpectation == nil {
		mmHasField.defaultExpectation = &ScanMockHasFieldExpectation{mock: mmHasField.mock}
	}
	mmHasField.defaultExpectation.results = &ScanMockHasFieldResults{b1}
	return mmHasField.mock
}

//Set uses given function f to mock the Scan.HasField method
func (mmHasField *mScanMockHasField) Set(f func(fieldName string) (b1 bool)) *ScanMock {
	if mmHasField.defaultExpectation != nil {
		mmHasField.mock.t.Fatalf("Default expectation is already set for the Scan.HasField method")
	}

	if len(mmHasField.expectations) > 0 {
		mmHasField.mock.t.Fatalf("Some expectations are already set for the Scan.HasField method")
	}

	mmHasField.mock.funcHasField = f
	return mmHasField.mock
}

// When sets expectation for the Scan.HasField which will trigger the result defined by the following
// Then helper
func (mmHasField *mScanMockHasField) When(fieldName string) *ScanMockHasFieldExpectation {
	if mmHasField.mock.funcHasField != nil {
		mmHasField.mock.t.Fatalf("ScanMock.HasField mock is already set by Set")
	}

	expectation := &ScanMockHasFieldExpectation{
		mock:   mmHasField.mock,
		params: &ScanMockHasFieldParams{fieldName},
	}
	mmHasField.expectations = append(mmHasField.expectations, expectation)
	return expectation
}

// Then sets up Scan.HasField return parameters for the expectation previously defined by the When method
func (e *ScanMockHasFieldExpectation) Then(b1 bool) *ScanMock {
	e.results = &ScanMockHasFieldResults{b1}
	return e.mock
}

// HasField implements Scan
func (mmHasField *ScanMock) HasField(fieldName string) (b1 bool) {
	mm_atomic.AddUint64(&mmHasField.beforeHasFieldCounter, 1)
	defer mm_atomic.AddUint64(&mmHasField.afterHasFieldCounter, 1)

	if mmHasField.inspectFuncHasField != nil {
		mmHasField.inspectFuncHasField(fieldName)
	}

	mm_params := &ScanMockHasFieldParams{fieldName}

	// Record call args
	mmHasField.HasFieldMock.mutex.Lock()
	mmHasField.HasFieldMock.callArgs = append(mmHasField.HasFieldMock.callArgs, mm_params)
	mmHasField.HasFieldMock.mutex.Unlock()

	for _, e := range mmHasField.HasFieldMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmHasField.HasFieldMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHasField.HasFieldMock.defaultExpectation.Counter, 1)
		mm_want := mmHasField.HasFieldMock.defaultExpectation.params
		mm_got := ScanMockHasFieldParams{fieldName}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHasField.t.Errorf("ScanMock.HasField got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHasField.HasFieldMock.defaultExpectation.results
		if mm_results == nil {
			mmHasField.t.Fatal("No results are set for the ScanMock.HasField")
		}
		return (*mm_results).b1
	}
	if mmHasField.funcHasField != nil {
		return mmHasField.funcHasField(fieldName)
	}
	mmHasField.t.Fatalf("Unexpected call to ScanMock.HasField. %v", fieldName)
	return
}

// HasFieldAfterCounter returns a count of finished ScanMock.HasField invocations
func (mmHasField *ScanMock) HasFieldAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasField.afterHasFieldCounter)
}

// HasFieldBeforeCounter returns a count of ScanMock.HasField invocations
func (mmHasField *ScanMock) HasFieldBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasField.beforeHasFieldCounter)
}

// Calls returns a list of arguments used in each call to ScanMock.HasField.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHasField *mScanMockHasField) Calls() []*ScanMockHasFieldParams {
	mmHasField.mutex.RLock()

	argCopy := make([]*ScanMockHasFieldParams, len(mmHasField.callArgs))
	copy(argCopy, mmHasField.callArgs)

	mmHasField.mutex.RUnlock()

	return argCopy
}

// MinimockHasFieldDone returns true if the count of the HasField invocations corresponds
// the number of defined expectations
func (m *ScanMock) MinimockHasFieldDone() bool {
	for _, e := range m.HasFieldMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasFieldMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasFieldCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasField != nil && mm_atomic.LoadUint64(&m.afterHasFieldCounter) < 1 {
		return false
	}
	return true
}

// MinimockHasFieldInspect logs each unmet expectation
func (m *ScanMock) MinimockHasFieldInspect() {
	for _, e := range m.HasFieldMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScanMock.HasField with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasFieldMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasFieldCounter) < 1 {
		if m.HasFieldMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScanMock.HasField")
		} else {
			m.t.Errorf("Expected call to ScanMock.HasField with params: %#v", *m.HasFieldMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasField != nil && mm_atomic.LoadUint64(&m.afterHasFieldCounter) < 1 {
		m.t.Error("Expected call to ScanMock.HasField")
	}
}

type mScanMockNext struct {
	mock               *ScanMock
	defaultExpectation *ScanMockNextExpectation
	expectations       []*ScanMockNextExpectation
}

// ScanMockNextExpectation specifies expectation struct of the Scan.Next
type ScanMockNextExpectation struct {
	mock *ScanMock

	results *ScanMockNextResults
	Counter uint64
}

// ScanMockNextResults contains results of the Scan.Next
type ScanMockNextResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for Scan.Next
func (mmNext *mScanMockNext) Expect() *mScanMockNext {
	if mmNext.mock.funcNext != nil {
		mmNext.mock.t.Fatalf("ScanMock.Next mock is already set by Set")
	}

	if mmNext.defaultExpectation == nil {
		mmNext.defaultExpectation = &ScanMockNextExpectation{}
	}

	return mmNext
}

// Inspect accepts an inspector function that has same arguments as the Scan.Next
func (mmNext *mScanMockNext) Inspect(f func()) *mScanMockNext {
	if mmNext.mock.inspectFuncNext != nil {
		mmNext.mock.t.Fatalf("Inspect function is already set for ScanMock.Next")
	}

	mmNext.mock.inspectFuncNext = f

	return mmNext
}

// Return sets up results that will be returned by Scan.Next
func (mmNext *mScanMockNext) Return(b1 bool, err error) *ScanMock {
	if mmNext.mock.funcNext != nil {
		mmNext.mock.t.Fatalf("ScanMock.Next mock is already set by Set")
	}

	if mmNext.defaultExpectation == nil {
		mmNext.defaultExpectation = &ScanMockNextExpectation{mock: mmNext.mock}
	}
	mmNext.defaultExpectation.results = &ScanMockNextResults{b1, err}
	return mmNext.mock
}

//Set uses given function f to mock the Scan.Next method
func (mmNext *mScanMockNext) Set(f func() (b1 bool, err error)) *ScanMock {
	if mmNext.defaultExpectation != nil {
		mmNext.mock.t.Fatalf("Default expectation is already set for the Scan.Next method")
	}

	if len(mmNext.expectations) > 0 {
		mmNext.mock.t.Fatalf("Some expectations are already set for the Scan.Next method")
	}

	mmNext.mock.funcNext = f
	return mmNext.mock
}

// Next implements Scan
func (mmNext *ScanMock) Next() (b1 bool, err error) {
	mm_atomic.AddUint64(&mmNext.beforeNextCounter, 1)
	defer mm_atomic.AddUint64(&mmNext.afterNextCounter, 1)

	if mmNext.inspectFuncNext != nil {
		mmNext.inspectFuncNext()
	}

	if mmNext.NextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNext.NextMock.defaultExpectation.Counter, 1)

		mm_results := mmNext.NextMock.defaultExpectation.results
		if mm_results == nil {
			mmNext.t.Fatal("No results are set for the ScanMock.Next")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmNext.funcNext != nil {
		return mmNext.funcNext()
	}
	mmNext.t.Fatalf("Unexpected call to ScanMock.Next.")
	return
}

// NextAfterCounter returns a count of finished ScanMock.Next invocations
func (mmNext *ScanMock) NextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNext.afterNextCounter)
}

// NextBeforeCounter returns a count of ScanMock.Next invocations
func (mmNext *ScanMock) NextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNext.beforeNextCounter)
}

// MinimockNextDone returns true if the count of the Next invocations corresponds
// the number of defined expectations
func (m *ScanMock) MinimockNextDone() bool {
	for _, e := range m.NextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNext != nil && mm_atomic.LoadUint64(&m.afterNextCounter) < 1 {
		return false
	}
	return true
}

// MinimockNextInspect logs each unmet expectation
func (m *ScanMock) MinimockNextInspect() {
	for _, e := range m.NextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScanMock.Next")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNextCounter) < 1 {
		m.t.Error("Expected call to ScanMock.Next")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNext != nil && mm_atomic.LoadUint64(&m.afterNextCounter) < 1 {
		m.t.Error("Expected call to ScanMock.Next")
	}
}

type mScanMockSchema struct {
	mock               *ScanMock
	defaultExpectation *ScanMockSchemaExpectation
	expectations       []*ScanMockSchemaExpectation
}

// ScanMockSchemaExpectation specifies expectation struct of the Scan.Schema
type ScanMockSchemaExpectation struct {
	mock *ScanMock

	results *ScanMockSchemaResults
	Counter uint64
}

// ScanMockSchemaResults contains results of the Scan.Schema
type ScanMockSchemaResults struct {
	s1 records.Schema
}

// Expect sets up expected params for Scan.Schema
func (mmSchema *mScanMockSchema) Expect() *mScanMockSchema {
	if mmSchema.mock.funcSchema != nil {
		mmSchema.mock.t.Fatalf("ScanMock.Schema mock is already set by Set")
	}

	if mmSchema.defaultExpectation == nil {
		mmSchema.defaultExpectation = &ScanMockSchemaExpectation{}
	}

	return mmSchema
}

// Inspect accepts an inspector function that has same arguments as the Scan.Schema
func (mmSchema *mScanMockSchema) Inspect(f func()) *mScanMockSchema {
	if mmSchema.mock.inspectFuncSchema != nil {
		mmSchema.mock.t.Fatalf("Inspect function is already set for ScanMock.Schema")
	}

	mmSchema.mock.inspectFuncSchema = f

	return mmSchema
}

// Return sets up results that will be returned by Scan.Schema
func (mmSchema *mScanMockSchema) Return(s1 records.Schema) *ScanMock {
	if mmSchema.mock.funcSchema != nil {
		mmSchema.mock.t.Fatalf("ScanMock.Schema mock is already set by Set")
	}

	if mmSchema.defaultExpectation == nil {
		mmSchema.defaultExpectation = &ScanMockSchemaExpectation{mock: mmSchema.mock}
	}
	mmSchema.defaultExpectation.results = &ScanMockSchemaResults{s1}
	return mmSchema.mock
}

//Set uses given function f to mock the Scan.Schema method
func (mmSchema *mScanMockSchema) Set(f func() (s1 records.Schema)) *ScanMock {
	if mmSchema.defaultExpectation != nil {
		mmSchema.mock.t.Fatalf("Default expectation is already set for the Scan.Schema method")
	}

	if len(mmSchema.expectations) > 0 {
		mmSchema.mock.t.Fatalf("Some expectations are already set for the Scan.Schema method")
	}

	mmSchema.mock.funcSchema = f
	return mmSchema.mock
}

// Schema implements Scan
func (mmSchema *ScanMock) Schema() (s1 records.Schema) {
	mm_atomic.AddUint64(&mmSchema.beforeSchemaCounter, 1)
	defer mm_atomic.AddUint64(&mmSchema.afterSchemaCounter, 1)

	if mmSchema.inspectFuncSchema != nil {
		mmSchema.inspectFuncSchema()
	}

	if mmSchema.SchemaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSchema.SchemaMock.defaultExpectation.Counter, 1)

		mm_results := mmSchema.SchemaMock.defaultExpectation.results
		if mm_results == nil {
			mmSchema.t.Fatal("No results are set for the ScanMock.Schema")
		}
		return (*mm_results).s1
	}
	if mmSchema.funcSchema != nil {
		return mmSchema.funcSchema()
	}
	mmSchema.t.Fatalf("Unexpected call to ScanMock.Schema.")
	return
}

// SchemaAfterCounter returns a count of finished ScanMock.Schema invocations
func (mmSchema *ScanMock) SchemaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSchema.afterSchemaCounter)
}

// SchemaBeforeCounter returns a count of ScanMock.Schema invocations
func (mmSchema *ScanMock) SchemaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSchema.beforeSchemaCounter)
}

// MinimockSchemaDone returns true if the count of the Schema invocations corresponds
// the number of defined expectations
func (m *ScanMock) MinimockSchemaDone() bool {
	for _, e := range m.SchemaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SchemaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSchemaCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSchema != nil && mm_atomic.LoadUint64(&m.afterSchemaCounter) < 1 {
		return false
	}
	return true
}

// MinimockSchemaInspect logs each unmet expectation
func (m *ScanMock) MinimockSchemaInspect() {
	for _, e := range m.SchemaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScanMock.Schema")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SchemaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSchemaCounter) < 1 {
		m.t.Error("Expected call to ScanMock.Schema")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSchema != nil && mm_atomic.LoadUint64(&m.afterSchemaCounter) < 1 {
		m.t.Error("Expected call to ScanMock.Schema")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ScanMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBeforeFirstInspect()

		m.MinimockCloseInspect()

		m.MinimockGetInt64Inspect()

		m.MinimockGetInt8Inspect()

		m.MinimockGetStringInspect()

		m.MinimockGetValInspect()

		m.MinimockHasFieldInspect()

		m.MinimockNextInspect()

		m.MinimockSchemaInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ScanMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ScanMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeforeFirstDone() &&
		m.MinimockCloseDone() &&
		m.MinimockGetInt64Done() &&
		m.MinimockGetInt8Done() &&
		m.MinimockGetStringDone() &&
		m.MinimockGetValDone() &&
		m.MinimockHasFieldDone() &&
		m.MinimockNextDone() &&
		m.MinimockSchemaDone()
}
